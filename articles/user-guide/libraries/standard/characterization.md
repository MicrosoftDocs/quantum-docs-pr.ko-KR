---
title: 퀀텀 특성화 및 통계
description: 추정 단계의 측정 통계를 사용 하 여 퀀텀 프로그래밍에서 결과 값을 예측 하는 방법을 알아봅니다.
author: bradben
uid: microsoft.quantum.libraries.characterization
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
no-loc:
- ':::no-loc(Q#):::'
- ':::no-loc($$v):::'
ms.openlocfilehash: 51e7b3bcf4402a4d0ba5647643f284e9f10c3bb3
ms.sourcegitcommit: 29e0d88a30e4166fa580132124b0eb57e1f0e986
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/27/2020
ms.locfileid: "92692153"
---
# <a name="quantum-characterization-and-statistics"></a><span data-ttu-id="5830f-103">퀀텀 특성화 및 통계</span><span class="sxs-lookup"><span data-stu-id="5830f-103">Quantum Characterization and Statistics</span></span> #

<span data-ttu-id="5830f-104">유용한 퀀텀 알고리즘을 개발 하기 위해 작업 효과의 특징을 지정할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-104">It is critical to be able to characterize the effects of operations in order to develop useful quantum algorithms.</span></span>
<span data-ttu-id="5830f-105">이는 퀀텀 시스템의 모든 측정값이 최대 1 비트 정보를 생성 하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-105">This is challenging because every measurement of a quantum system yields at most one bit of information.</span></span>
<span data-ttu-id="5830f-106">사용자가 이러한 개념을 나타내는 데 필요한 많은 양의 정보를 공개할 수 있도록 eigenvalue를 학습 하 고,이를 사용 하 여 여러 측정값의 결과를 함께 연결 되어 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-106">In order to learn an eigenvalue, let alone a quantum state, the results of many measurements must be stitched together so that the user can glean the many bits of information needed to represent these concepts.</span></span>
<span data-ttu-id="5830f-107">퀀텀 상태는 특히 상태를 복사 하는 것이 가능 하기 때문에 [정리](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) 의 단일 복사본에서 임의의 퀀텀 상태를 학습할 방법이 없다는 것을 vexing 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-107">Quantum states are especially vexing because the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) states that there is no way to learn an arbitrary quantum state from a single copy of the state, because doing so would let you make copies of the state.</span></span>
<span data-ttu-id="5830f-108">사용자의 퀀텀 상태 난독 처리는 :::no-loc(Q#)::: 퀀텀 프로그램의 상태 *를* 노출 하거나 정의 하지 않는 팩트에 반영 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-108">This obfuscation of the quantum state from the user is reflected in the fact that :::no-loc(Q#)::: does not expose or even define what a state *is* to quantum programs.</span></span>
<span data-ttu-id="5830f-109">따라서 작업 및 상태를 블랙 박스로 처리 하 여 퀀텀 특징을 접근 합니다. 이 접근 방식은 퀀텀, 확인 및 유효성 검사 (QCVV)의 실험적 사례와 공통적으로 많이 공유 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-109">We thus approach quantum characterization by treating operations and states as black-box; this approach shares much in common with the experimental practice of quantum characterization, verification and validation (QCVV).</span></span>

<span data-ttu-id="5830f-110">용어는 앞에서 설명한 대부분의 다른 라이브러리와는 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-110">Characterization is distinct from many of the other libraries discussed previously.</span></span>
<span data-ttu-id="5830f-111">여기서는 상태 벡터에서 단일 변환을 수행 하는 대신 시스템에 대 한 기존 정보를 배우는 것이 더 낮습니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-111">The aim here is less to learn classical information about the system, rather than to perform a unitary transformation on a state vector.</span></span>
<span data-ttu-id="5830f-112">따라서 이러한 라이브러리는 기존 및 퀀텀 정보 처리를 모두 혼합 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-112">These libraries must therefore blend both classical and quantum information processing.</span></span>


## <a name="iterative-phase-estimation"></a><span data-ttu-id="5830f-113">반복 단계 예측</span><span class="sxs-lookup"><span data-stu-id="5830f-113">Iterative Phase Estimation</span></span> ##

<span data-ttu-id="5830f-114">퀀텀 용어를 기준으로 퀀텀 프로그래밍을 보면 퀀텀 단계 추정에 대 한 유용한 대안이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-114">Viewing quantum programming in terms of quantum characterization suggests a useful alternative to quantum phase estimation.</span></span>
<span data-ttu-id="5830f-115">즉, 퀀텀 단계 추정에서와 같이 단계의 이진 표현을 포함 하도록 $-hbit 레지스터 $n을 준비 하는 대신, *기존* 에이전트가 측정값을 통해 퀀텀 시스템의 속성을 학습 하는 프로세스로 단계 예측을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-115">That is, instead of preparing an $n$-qubit register to contain a binary representation of the phase as in quantum phase estimation, we can view phase estimation as the process by which a *classical* agent learns properties of a quantum system through measurements.</span></span>
<span data-ttu-id="5830f-116">Kickback 단계를 사용 하 여 블랙 박스 작업의 응용 프로그램을 알 수 없는 각도 만큼 회전으로 전환 하는 퀀텀 사례에서 작업을 진행 하면서 각 단계에서 회전 직후 회전 하는 ancilla를 측정 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-116">We proceed as in the quantum case by using phase kickback to turn applications of a black-box operation into rotations by an unknown angle, but will measure the ancilla qubit that we rotate at each step immediately following the rotation.</span></span>
<span data-ttu-id="5830f-117">이는 퀀텀 사례에 설명 된 단계를 수행 하는 데 하나의 추가 kickback 필요 하지만 반복적인 방식으로 각 단계의 측정 결과에서 단계를 알아보는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-117">This has the advantage that we only require a single additional qubit to perform the phase kickback described in the quantum case, as we then learn the phase from the measurement results at each step in an iterative fashion.</span></span>  
<span data-ttu-id="5830f-118">아래에서 제안 하는 각 방법은 실험을 설계 하 고 다양 한 데이터 처리 방법을 사용 하 여 단계를 학습할 수 있는 다른 전략을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-118">Each of the methods proposed below uses a different strategy for designing experiments and different data processing methods to learn the phase.</span></span>  <span data-ttu-id="5830f-119">각 사용자에 게는 엄격한 오류 범위를 포함 하는 것부터 이전 정보를 포함 하는 기능, 오류를 허용 하거나 메모리 limitted 클래식 컴퓨터에서 실행 하는 기능에 이르기까지 고유한 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-119">They each have unique advantage ranging from having rigorous error bounds, to the abilities to incorporate prior information, tolerate errors or run on memory limitted classical computers.</span></span>

<span data-ttu-id="5830f-120">반복 단계 예측에 대해 논의 하는 경우 블랙 박스 작업으로 제공 되는 단일 $U $을 고려 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-120">In discussing iterative phase estimation, we will consider a unitary $U$ given as a black-box operation.</span></span>
<span data-ttu-id="5830f-121">[데이터 구조](xref:microsoft.quantum.libraries.data-structures)에서 oracles에 대 한 섹션에서 설명한 것 처럼, :::no-loc(Q#)::: 사용자 정의 형식에의 한 작업 (예: <xref:Microsoft.Quantum.Oracles.DiscreteOracle> 튜플 형식으로 정의 됨)을 모델링 합니다 `((Int, Qubit[]) => Unit : Adjoint, Controlled)` .</span><span class="sxs-lookup"><span data-stu-id="5830f-121">As described in the section on oracles in [data structures](xref:microsoft.quantum.libraries.data-structures), the :::no-loc(Q#)::: canon models such operations by the <xref:Microsoft.Quantum.Oracles.DiscreteOracle> user-defined type, defined by the tuple type `((Int, Qubit[]) => Unit : Adjoint, Controlled)`.</span></span>
<span data-ttu-id="5830f-122">구체적으로 인 경우 `U : DiscreteOracle` 에는 `U(m)` 에 대해 ^ m $ $U를 구현 `m : Int` 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-122">Concretely, if `U : DiscreteOracle`, then `U(m)` implements $U^m$ for `m : Int`.</span></span>

<span data-ttu-id="5830f-123">이 정의를 사용 하 여 반복 단계 예측의 각 단계는 초기 상태 $ \ket{\phi} $와 함께 $ \ket{+} $ 상태에서 보조 비트를 준비 하 여 진행 됩니다 .이는 $U [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) (m) $, 즉 $U (m) \ket{\phi} = e ^ {im\eml\ k {\ l o} $입니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-123">With this definition in place, each step of iterative phase estimation proceeds by preparing an auxiliary qubit in the $\ket{+}$ state along with the initial state $\ket{\phi}$ that we assume is an [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) of $U(m)$, i.e. $U(m)\ket{\phi}= e^{im\phi}\ket{\phi}$.</span></span>  
<span data-ttu-id="5830f-124">그런 다음의 제어 된 응용 프로그램을 `U(m)` 사용 하 여 $ \left (R \_ 1 (m \ 화) \ket{+} \left) \ket{\phi} $ 상태를 준비 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-124">A controlled application of `U(m)` is then used which prepares the state $\left(R\_1(m \phi) \ket{+}\right)\ket{\phi}$.</span></span>
<span data-ttu-id="5830f-125">퀀텀 사례에서와 같이 oracle의 제어 된 응용 프로그램에 미치는 영향은 `U(m)` $ \ket{+} $에서 알 수 없는 단계에 대해 $R _1 $을 적용 한 결과와 정확히 동일 합니다 .이에 따라 $U $의 효과를 보다 간단한 방식으로 설명할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-125">As in the quantum case, the effect of a controlled application of the oracle `U(m)` is precisely the same as the effect of applying $R_1$ for the unknown phase on $\ket{+}$, such that we can describe the effects of $U$ in this simpler fashion.</span></span>
<span data-ttu-id="5830f-126">필요에 따라 알고리즘은 $ \ket{\psi} = \left (R \_ 1 (m [\phi-\theta]) \ket{+} \right) \ket{\phi} $ $ 상태를 가져오기 위해 $R _1 (-m\theta) $을 적용 하 여 컨트롤을 회전 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-126">Optionally, the algorithm then rotates the control qubit by applying $R_1(-m\theta)$ to obtain a state $\ket{\psi}=\left(R\_1(m [\phi-\theta]) \ket{+}\right)\ket{\phi}$$.</span></span>
<span data-ttu-id="5830f-127">의 컨트롤로 사용 되는 보조 비트는 `U(m)` $X $ 기준으로 측정 되어 단일 고전을 얻습니다 `Result` .</span><span class="sxs-lookup"><span data-stu-id="5830f-127">The auxiliary qubit used as a control for `U(m)` is then measured in the $X$ basis to obtain a single classical `Result`.</span></span>

<span data-ttu-id="5830f-128">이 시점에서 반복 단계 예측을 통해 얻은 값에서 단계를 다시 생성 하는 `Result` 것은 기존 통계 유추 문제입니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-128">At this point, reconstructing the phase from the `Result` values obtained through iterative phase estimation is a classical statistical inference problem.</span></span>
<span data-ttu-id="5830f-129">고정 유추 방법이 제공 되는 경우 얻은 정보를 최대화 하는 $m $ 값을 찾는 것은 단순히 통계의 문제입니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-129">Finding the value of $m$ that maximizes the information gained, given a fixed inference method, is simply a problem in statistics.</span></span>
<span data-ttu-id="5830f-130">이 :::no-loc(Q#)::: 기존 유추 문제를 해결 하기 위해 라고에서 제공 되는 통계 알고리즘을 설명 하기 전에 Bayesian 매개 변수 추정 정해진 이론적 수준에서 반복적 단계 예측을 간략하게 설명 하 여이를 강조 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-130">We emphasize this by briefly describing iterative phase estimation at a theoretical level in the Bayesian parameter estimation formalism before proceeding to describe the statistical algorithms provided in the :::no-loc(Q#)::: canon for solving this classical inference problem.</span></span>

### <a name="iterative-phase-estimation-without-eigenstates"></a><span data-ttu-id="5830f-131">Eigenstates 없이 반복 단계 예측</span><span class="sxs-lookup"><span data-stu-id="5830f-131">Iterative Phase Estimation Without Eigenstates</span></span> ###

<span data-ttu-id="5830f-132">Eigenstate가 아닌 입력 상태를 제공 하는 경우 ($U (m) \ket{\phi \_ j} = e ^ {im\emj} $ 인 경우) \_ 단계 추정 프로세스는 단일 에너지 eigenstate에 대 한 퀀텀 상태를 명확 하 게 표시 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-132">If an input state is provided that is not an eigenstate, which is to say that if $U(m)\ket{\phi\_j} = e^{im\phi\_j}$ then the process of phase estimation non-deterministically guides the quantum state towards a single energy eigenstate.</span></span>  <span data-ttu-id="5830f-133">궁극적으로 수렴 된 eigenstate는 관찰 된을 생성할 가능성이 가장 높은 eigenstate입니다 `Result` .</span><span class="sxs-lookup"><span data-stu-id="5830f-133">The eigenstate it ultimately converges to is the eigenstate that is most likely to produce the observed `Result`.</span></span>

<span data-ttu-id="5830f-134">특히, PE의 단일 단계는 상태 \begin{align} \ sum_j \sqrt{\Pr ( \_ \aj)} \ket{\phi \_ j} \maps\\ki\\frac \_ {\ Sqrt {\ Pr (\aj)에 대해 다음과 같은 비 단일 변환을 수행 합니다. \_ } \sqrt{\Pr (\text{Result} | \aaj \_ )} \Ket{\phi \_ j}} {\sqrt{\pr (\aj \_ ) \Sum \_ j \pr (\text{result} | \\aj \_ )}}.</span><span class="sxs-lookup"><span data-stu-id="5830f-134">Specifically, a single step of PE performs the following non-unitary transformation on a state \begin{align} \sum_j \sqrt{\Pr(\phi\_j)} \ket{\phi\_j} \mapsto \sum\_j\frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}.</span></span>
<span data-ttu-id="5830f-135">이 프로세스가 여러 값에 대해 반복 되는 \end{align} `Result` , 최대 값이 $ \ prod_k \Pr (\text{Result} \_ k | \\aj) $ 인 eigenstates는 계속 해 서 표시 되지 않습니다 \_ .</span><span class="sxs-lookup"><span data-stu-id="5830f-135">\end{align} As this process is iterated over multiple `Result` values, eigenstates that do not have maximal values of $\prod_k\Pr(\text{Result}\_k|\phi\_j)$ will be exponentially suppressed.</span></span>
<span data-ttu-id="5830f-136">따라서 실험을 제대로 선택 하면 유추 프로세스는 단일 eigenvalue를 사용 하 여 상태로 수렴 하는 경향이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-136">As a result, the inference process will tend to converge to states with a single eigenvalue if the experiments are chosen properly.</span></span>

<span data-ttu-id="5830f-137">Bayes ' 정리 \begin{align} \frac{\sqrt{\Pr ( \_ \aaj)} \sqrt{\Pr (\text{Result} | \aaj \_ )} \ket{\phi \_ j}} {\sqrts {\pr ( \_ \aj) \Phi \_ j \Phi (\text{result} | \_ \aaj)}} = \ sum_j \sqrt{\pr ( \_ \\aj | \text{result})} \ket{\phi \_ j}.</span><span class="sxs-lookup"><span data-stu-id="5830f-137">Bayes' theorem further suggests that the state that results from phase estimation be written in the form \begin{align} \frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}=\sum_j \sqrt{\Pr(\phi\_j|\text{Result})} \ket{\phi\_j}.</span></span>
<span data-ttu-id="5830f-138">\end{align} 여기 $ \Pr ( \_ \\aj | \text{Result}) $는 지정 된 eigenstates에 대 한 각 가설로 ascribe 확률을 interpretted 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-138">\end{align} Here $\Pr(\phi\_j|\text{Result})$ can be interpretted as the probability that one would ascribe to each hypothesis about the eigenstates given:</span></span>

1. <span data-ttu-id="5830f-139">측정 전의 퀀텀 상태에 대 한 지식</span><span class="sxs-lookup"><span data-stu-id="5830f-139">knowledge of the quantum state prior to measurement,</span></span>
2. <span data-ttu-id="5830f-140">$U $ 및의 eigenstates에 대 한 지식</span><span class="sxs-lookup"><span data-stu-id="5830f-140">knowledge of the eigenstates of $U$ and,</span></span>
3. <span data-ttu-id="5830f-141">$U $의 고유 값에 대 한 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-141">knowledge of the eigenvalues of $U$.</span></span>

<span data-ttu-id="5830f-142">이러한 세 가지 작업을 수행 하는 것은 일반적으로 기존 컴퓨터에서 매우 하드 디스크입니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-142">Learning these three things is often exponentially hard on a classical computer.</span></span>
<span data-ttu-id="5830f-143">단계 예측의 유틸리티는 이러한 작업을 알지 못해도 이러한 퀀텀 학습 작업을 수행할 수 있다는 사실에서 작은 익스텐트가 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-143">The utility of phase estimation arises, to no small extent, from the fact that it can perform such a quantum learning task without knowing any of them.</span></span>
<span data-ttu-id="5830f-144">이러한 이유에 대 한 단계 예측은 지 수 속도를 제공 하는 여러 퀀텀 알고리즘 내에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-144">Phase estimation for this reason appears within a number of quantum algorithms that provide exponential speedups.</span></span>

### <a name="bayesian-phase-estimation"></a><span data-ttu-id="5830f-145">Bayesian 단계 예측</span><span class="sxs-lookup"><span data-stu-id="5830f-145">Bayesian Phase Estimation</span></span> ###

> [!TIP]
> <span data-ttu-id="5830f-146">Bayesian 단계 예측에 대 한 자세한 내용은 [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation) 샘플을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="5830f-146">For more details on Bayesian phase estimation in practice, please see the [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/main/samples/characterization/phase-estimation) sample.</span></span>

<span data-ttu-id="5830f-147">Bayesian 단계 추정의 개념은 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-147">The idea of Bayesian phase estimation is simple.</span></span>
<span data-ttu-id="5830f-148">단계 추정 프로토콜에서 측정 통계를 수집한 다음 Bayesian 유추를 사용 하 여 결과를 처리 하 고 예상 된 매개 변수를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-148">You collect measurement statistics from the phase estimation protocol and then you process the results using Bayesian inference and provide an estimate of the parameter.</span></span>
<span data-ttu-id="5830f-149">이러한 처리를 통해 예상 값을 예측할 수 있을 뿐만 아니라 예상 값을 예측할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-149">This processing gives you an estimate of the eigenvalue as well as the uncertainty in that estimate.</span></span>
<span data-ttu-id="5830f-150">또한 적응 실험을 수행 하 고 이전 정보를 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-150">It also allows you to perform adaptive experiments and utilize prior information.</span></span>
<span data-ttu-id="5830f-151">메서드의 원칙에 대 한 단점은 계산을 요구 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-151">The methods' principle drawback is that it is computationally demanding.</span></span>

<span data-ttu-id="5830f-152">이 Bayesian 유추 프로세스가 작동 하는 방식을 이해 하려면 단일 결과를 처리 하는 경우를 고려 합니다 `Zero` .</span><span class="sxs-lookup"><span data-stu-id="5830f-152">To understand how this Bayesian inference process works, consider the case of processing a single `Zero` result.</span></span>
<span data-ttu-id="5830f-153">$X = \ket{+} \bra{+}-\ket {-} \bra {-} $와 같이 $ \ket{+} $는에 해당 하는 $X $의 유일한 긍정 eigenstate입니다 `Zero` .</span><span class="sxs-lookup"><span data-stu-id="5830f-153">Note that $X = \ket{+}\bra{+} - \ket{-}\bra{-}$, such that $\ket{+}$ is the only positive eigenstate of $X$ corresponding to `Zero`.</span></span>
<span data-ttu-id="5830f-154">`Zero`입력 상태 $ \ket{\psi}\ket{\phi} $가 지정 된 첫 번째 [ `PauliX` 값에서 측정값](xref:microsoft.quantum.concepts.pauli) 을 관찰 하는 확률은 그에 따라 \begin{equation} \pr (\texttt{Zero} | \psi) = \left | \braket{+ | \psi} \right | ^ 2입니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-154">The probability of observing `Zero` for a [`PauliX` measurement](xref:microsoft.quantum.concepts.pauli) on the first qubit given an input state $\ket{\psi}\ket{\phi}$ is thus \begin{equation} \Pr(\texttt{Zero} | \psi) = \left| \braket{+ | \psi} \right|^2.</span></span>
<span data-ttu-id="5830f-155">\end{equation} 반복적인 단계 예측의 경우 $ \ket{\psi} = R_1 (m [\phi-\theta]) \ket{+} $ (\begin{align} \Pr (\texttt{Zero} | \\asa; m, \테타) & = \left | \braket{+ | R_1 (m [\phi-\theta]) | +} \right | ^ 2 \\ \\ & = \right | \frac12 \right (\bra {0} + \bra {1} \right) \right (\ket {0} + e ^ {i m [\phi-\theta]} \ket {1} \right) \right | ^ 2 \\ \\ & = \right | \frac{1 + e ^ {i m [\phi-\theta]}} {2} \right | ^ 2 \\ \\ & = \right ^ 2 (m [\phi-\theta]/2) \t ag{★} \label{eq:}.</span><span class="sxs-lookup"><span data-stu-id="5830f-155">\end{equation} In the case of iterative phase estimation, we have that $\ket{\psi} = R_1(m [\phi-\theta]) \ket{+}$, such that \begin{align} \Pr(\texttt{Zero} | \phi; m,\theta) & = \left| \braket{+ | R_1(m [\phi-\theta]) | +} \right|^2 \\\\ & = \left| \frac12 \left( \bra{0} + \bra{1} \right) \left( \ket{0} + e^{i m [\phi-\theta]} \ket{1} \right) \right|^2 \\\\ & = \left| \frac{1 + e^{i m [\phi-\theta]}}{2} \right|^2 \\\\ & = \cos^2(m [\phi-\theta] / 2) \tag{★} \label{eq:phase-est-likelihood}.</span></span>
<span data-ttu-id="5830f-156">\end{align} 반복 단계 추정은 해당 sinusoid로 지정 된 바이어스로 동전을 대칭 이동 하는 기능을 제공 하 여 사인 곡선 함수의 진동 범위가 빈도를 학습 하는 것으로 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-156">\end{align} That is, iterative phase estimation consists of learning the oscillation frequency of a sinusoidal function, given the ability to flip a coin with a bias given by that sinusoid.</span></span>
<span data-ttu-id="5830f-157">기존의 기존 용어에 따라 $ \eqref{eq:} $는 반복적인 단계 예측에 대 한 *가능성 함수* 를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-157">Following traditional classical terminology, we call $\eqref{eq:phase-est-likelihood}$ the *likelihood function* for iterative phase estimation.</span></span>

<span data-ttu-id="5830f-158">`Result`반복 단계 추정 가능성에 대 한 정보를 확인 한 후에는 Bayes ' 규칙을 사용 하 여 이러한 관찰을 수행 해야 하는 단계를 규정 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-158">Having observed a `Result` from the iterative phase estimation likelihood function, we can then use Bayes' rule to prescribe what we should believe the phase to be following that observation.</span></span>
<span data-ttu-id="5830f-159">Concretely, \begin{equation} \Pr(\phi | d) = \frac{\Pr(d | \phi) \Pr(\phi)}{\int \Pr(d | \phi) \Pr(\phi){\mathrm d}\phi} \Pr(\phi), \end{equation} where $d \in \\{\texttt{Zero}, \texttt{One}\\}$ is a `Result`, and where $\Pr(\phi)$ describes our prior beliefs about $\phi$.</span><span class="sxs-lookup"><span data-stu-id="5830f-159">Concretely, \begin{equation} \Pr(\phi | d) = \frac{\Pr(d | \phi) \Pr(\phi)}{\int \Pr(d | \phi) \Pr(\phi){\mathrm d}\phi} \Pr(\phi), \end{equation} where $d \in \\{\texttt{Zero}, \texttt{One}\\}$ is a `Result`, and where $\Pr(\phi)$ describes our prior beliefs about $\phi$.</span></span>
<span data-ttu-id="5830f-160">그러면 사후 분산 $ \Pr (\\ax) $에서 다음의 관찰 바로 앞에 신념을 설명 하므로 반복적인 단계 예측의 반복적인 특성을 명시적으로 만듭니다 `Result` .</span><span class="sxs-lookup"><span data-stu-id="5830f-160">This then makes the iterative nature of iterative phase estimation explicit, as the posterior distribution $\Pr(\phi | d)$ describes our beliefs immediately preceding our observation of the next `Result`.</span></span>

<span data-ttu-id="5830f-161">이 절차를 수행 하는 동안 언제 든 지 클래식 컨트롤러에서 유추 된 $ \hat{\phi} $ 단계를 \begin{equation} \hat{\phi} \mathrel{로 보고할 수 있습니다. =} \ [\\a| \text{data}] = \int \Las\pr (\\a| \text{data}) {\mathrm d} \begin{equation} where $ \text{data} $는 가져온 모든 값의 전체 레코드를 나타냅니다 `Result` .</span><span class="sxs-lookup"><span data-stu-id="5830f-161">At any point during this procedure, we can report the phase $\hat{\phi}$ inferred by the classical controller as \begin{equation} \hat{\phi} \mathrel{:=} \expect[\phi | \text{data}] = \int \phi \Pr(\phi | \text{data}) {\mathrm d}\phi, \end{equation} where $\text{data}$ stands for the entire record of all `Result` values obtained.</span></span>

<span data-ttu-id="5830f-162">정확한 Bayesian 유추는 실제로 intractable입니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-162">Exact Bayesian inference is in practice intractable.</span></span>
<span data-ttu-id="5830f-163">이에 대 한 자세한 내용은 $ 비트 변수 $x $를 $n 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-163">To see this imagine we wish to learn an $n$-bit variable $x$.</span></span>
<span data-ttu-id="5830f-164">이전 배포 $ \Pr (x) $는 $2 ^ n $ $x $의 가상 값을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-164">The prior distribution $\Pr(x)$ has support over $2^n$ hypothetical values of $x$.</span></span>
<span data-ttu-id="5830f-165">즉, $x를 매우 정확 하 게 예측 해야 하는 경우에는 Bayesian 단계 예측에 필요한 메모리 및 처리 시간이 너무 늘어날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-165">This means that if we need a highly accurate estimate of $x$ then Bayesian phase estimation may need prohibitive memory and processing time.</span></span>
<span data-ttu-id="5830f-166">퀀텀 시뮬레이션 같은 일부 응용 프로그램의 경우에는 limitted 정확도가 Shor의 알고리즘과 같은 다른 응용 프로그램에서 해당 단계 예측 단계 내에 정확한 Bayesian 유추를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-166">While for some applications, such as quantum simulation, the limitted accuracy required does not preclude such methods other applications, such as Shor's algorithm, cannot use exact Bayesian inference within its phase estimation step.</span></span>  <span data-ttu-id="5830f-167">이러한 이유로 [RWPE (임의 워크 단계 예측)](xref:Microsoft.Quantum.Research.Characterization.RandomWalkPhaseEstimation) 와 같은 대략적인 Bayesian 메서드 및 [강력한 단계 추정치](xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation)와 같은 Bayesian 없는 방법에 대 한 구현도 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-167">For this reason, we also provide implementations for approximate Bayesian methods such as [random walk phase estimation (RWPE)](xref:Microsoft.Quantum.Research.Characterization.RandomWalkPhaseEstimation) and also non-Bayesian approaches such as [robust phase estimation](xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation).</span></span>

### <a name="robust-phase-estimation"></a><span data-ttu-id="5830f-168">강력한 단계 예측</span><span class="sxs-lookup"><span data-stu-id="5830f-168">Robust Phase Estimation</span></span> ###

<span data-ttu-id="5830f-169">측정 결과에서 단계 추정치의 최대 *posteriori* Bayesian 재구성은 최악의 경우에는 매우 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-169">A maximum *a posteriori* Bayesian reconstruction of a phase estimate from measurement results is exponentially hard in the worst-case.</span></span> <span data-ttu-id="5830f-170">따라서 대부분의 실용적인 단계 예측 알고리즘은 구성의 몇 가지 품질을 저하 시킬 수 있습니다 .이 알고리즘은 측정 횟수로 polynomially를 확장 하는 일반적인 사후 처리의 양에 대 한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-170">Thus most practical phase estimation algorithms sacrifice some quality in the reconstruction, in exchange for an amount of classical post-processing that instead scales polynomially with the number of measurements made.</span></span>

<span data-ttu-id="5830f-171">효율적인 기존 사후 처리 단계를 사용 하는 예 중 하나는 위에 언급 된 시그니처와 입력이 있는 [강력한 단계 추정 알고리즘](https://arxiv.org/abs/1502.02677)입니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-171">One such example with an efficient classical post-processing step is the [robust phase estimation algorithm](https://arxiv.org/abs/1502.02677), with its signature and inputs mentioned above.</span></span> <span data-ttu-id="5830f-172">입력 한 단일 검은색 상자 $U $가 형식으로 패키지 된 것으로 가정 `DiscreteOracle` 합니다. 따라서 정수는 제어 된 $U $로만 쿼리 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-172">It assumes that input unitary black-boxes $U$ are packaged as `DiscreteOracle` type, and therefore only queries integer powers of controlled-$U$.</span></span> <span data-ttu-id="5830f-173">레지스터의 입력 상태가 `Qubit[]` eigenstate $U \ket{\psi} = e ^ {i\em} \ k {\ psi} $ 인 경우 강력한 단계 추정 알고리즘은 $ \eml$의 예상 $ \hat{\phi}\in [-\pi, \pi) $를로 반환 합니다 `Double` .</span><span class="sxs-lookup"><span data-stu-id="5830f-173">If the input state in the `Qubit[]` register is an eigenstate $U\ket{\psi}=e^{i\phi}\ket{\psi}$, the robust phase estimation algorithm returns an estimate $\hat{\phi}\in[-\pi,\pi)$ of $\phi$ as a `Double`.</span></span>

<span data-ttu-id="5830f-174">가장 많이 사용 되는 다른 변형에서 공유 되는 강력한 단계 추정의 가장 중요 한 기능은 $ \hat{\phi} $의 재구성 품질이 Heisenberg 제한 되어 있다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-174">The most important feature of robust phase estimation, which is shared with most other useful variants, is that the reconstruction quality of $\hat{\phi}$ is in some sense Heisenberg-limited.</span></span> <span data-ttu-id="5830f-175">즉, 값이 $ \sigma $ 인 $ \hat{\phi} $의 편차가 $ \sigma $ 인 경우 $ \sigma $는 $U $ (예: $ \sigma = \mathcal{O} (1/Q) $로 만든 $Q 총 쿼리 수에 반비례 하 게 비례 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-175">This means that if the deviation of $\hat{\phi}$ from the true value is $\sigma$, then $\sigma$ scales inversely-proportional to the total number of queries $Q$ made to controlled-$U$, i.e. $\sigma=\mathcal{O}(1/Q)$.</span></span> <span data-ttu-id="5830f-176">이제 편차에 대 한 정의는 예측 알고리즘 마다 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-176">Now, the definition of deviation varies between different estimation algorithms.</span></span> <span data-ttu-id="5830f-177">경우에 따라 $ \mathcal{O} (1) $ probability를 사용 하는 경우 예상 오류 $ | \hat{\phi}-\phi | \_ 를 의미할 수 있습니다. \circ\le \sigma $ (일부 순환 측정 $ \sigma $)</span><span class="sxs-lookup"><span data-stu-id="5830f-177">In some cases, it may mean that with at least $\mathcal{O}(1)$ probability, the estimation error $|\hat{\phi}-\phi|\_\circ\le \sigma$ on some circular measure $\circ$.</span></span> <span data-ttu-id="5830f-178">강력한 단계 예측의 경우 편차는 $ \sigma ^ 2 = \mathbb{E} \_ \hat{\phi} [(\sigma \_ {2\ pi} (\hat{\phi}-\phi + \sigma)-\sigma) ^ 2] $로, 정기적으로 단계를 단일 유한 간격 $ (-\sigma, \sigma] $로 래핑 해제 한 경우에는 정확 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-178">For robust phase estimation, deviation is precisely the variance $\sigma^2 = \mathbb{E}\_\hat{\phi}[(\mod\_{2\pi}(\hat{\phi}-\phi +\pi)-\pi)^2]$ if we unwrap periodic phases onto a single finite interval $(-\pi,\pi]$.</span></span> <span data-ttu-id="5830f-179">좀 더 정확 하 게 말하자면, 강력한 단계 추정의 표준 편차는 같지 $ $ \begin{align} 2.0 \pi/Q \pi \pi \pi 2 \ pi/2 ^ {n} \pi 10.7 \ pi/Q, \end{align} $ $를 충족 합니다. 여기서 하한값은 asymptotically large $Q $로 제한 되며, 상한값은 작은 샘플 크기에 대해서도 보장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-179">More precisely, the standard deviation in robust phase estimation satisfies the inequalities $$ \begin{align} 2.0 \pi / Q \le \sigma \le 2\pi / 2^{n} \le 10.7\pi / Q, \end{align} $$ where the lower bound is reached in the limit of asymptotically large $Q$, and the upper bound is guaranteed even for small sample sizes.</span></span>  <span data-ttu-id="5830f-180">$를 `bitsPrecision` 암시적으로 $Q 정의 하는 입력으로 $ $n $가 선택 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-180">Note that $n$ selected by the `bitsPrecision` input, which implicitly defines $Q$.</span></span>

<span data-ttu-id="5830f-181">그 밖의 관련 세부 정보에는 $1 $ ancilla?의 작은 공간 오버 헤드 또는 프로시저가 비 적응 (예를 들어, 퀀텀 실험의 필수 시퀀스는 중간 측정 결과와 무관)이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-181">Other relevant details include, say, the small space overhead of just $1$ ancilla qubit, or that the procedure is non-adaptive, meaning the required sequence of quantum experiments is independent of the intermediate measurement outcomes.</span></span> <span data-ttu-id="5830f-182">단계 추정 알고리즘의 선택이 중요 한이 예제와 향후 예제에서는,와 같은 설명서를 참조 하 고 해당 구현에 대 한 참조 된 게시를 참조 해야 합니다 @"microsoft.quantum.characterization.robustphaseestimation" .</span><span class="sxs-lookup"><span data-stu-id="5830f-182">In this and forthcoming examples where the choice of phase estimation algorithm is important, one should one should refer to the documentation such as @"microsoft.quantum.characterization.robustphaseestimation" and the referenced publications therein for more information and for their the implementation.</span></span>

> [!TIP]
> <span data-ttu-id="5830f-183">강력한 단계 예측을 사용 하는 많은 샘플이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-183">There are many samples where robust phase estimation is used.</span></span> <span data-ttu-id="5830f-184">다양 한 물리적 시스템의 그라운드 상태 에너지를 추출 하는 단계를 예측 하려면 [ **H2 시뮬레이션** 샘플](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line), [ **simpleising** 샘플](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/simple)및 [ **model** 샘플](https://github.com/microsoft/Quantum/tree/main/samples/simulation/hubbard)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="5830f-184">For phase estimation in extracting the ground state energy of various physical system, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/h2/command-line), the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/ising/simple), and the [**Hubbard model** sample](https://github.com/microsoft/Quantum/tree/main/samples/simulation/hubbard).</span></span>


### <a name="continuous-oracles"></a><span data-ttu-id="5830f-185">연속 Oracles</span><span class="sxs-lookup"><span data-stu-id="5830f-185">Continuous Oracles</span></span> ###

<span data-ttu-id="5830f-186">또한 라고 형식으로 모델링 된 연속 시간 oracles을 허용 하기 위해 위에서 사용 하는 oracle 모델에서 일반화할 수 있습니다 <xref:Microsoft.Quantum.Oracles.ContinuousOracle> .</span><span class="sxs-lookup"><span data-stu-id="5830f-186">We can also generalize from the oracle model used above to allow for continuous-time oracles, modeled by the canon type <xref:Microsoft.Quantum.Oracles.ContinuousOracle>.</span></span>
<span data-ttu-id="5830f-187">단일 단일 연산자 대신 $ $U 하는 것이 아니라 (t) $ = $U (t + s) $와 $U 같은 $t \in \mathbb{R} $에 대 한 단일 연산자 $U (t) $를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-187">Consider that instead of a single unitary operator $U$, we have a family of unitary operators $U(t)$ for $t \in \mathbb{R}$ such that $U(t) U(s)$ = $U(t + s)$.</span></span>
<span data-ttu-id="5830f-188"><xref:Microsoft.Quantum.Oracles.DiscreteOracle> \, 일부 fixed $ \delta t $에 대해 $t = m \delta t $를 제한 하 여를 생성할 수 있기 때문에이는 불연속 사례에서 보다 약한 문입니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-188">This is a weaker statement than in the discrete case, since we can construct a <xref:Microsoft.Quantum.Oracles.DiscreteOracle> by restricting $t = m\,\delta t$ for some fixed $\delta t$.</span></span>
<span data-ttu-id="5830f-189">일부 $H 연산자의 경우 [석재의 정리](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups)(t) = \exp (i H t) $를 $U 합니다. 여기서 $ \exp $는 [고급 행렬](xref:microsoft.quantum.concepts.matrix-advanced)에 설명 된 대로 행렬 지 수입니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-189">By [Stone's theorem](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U(t) = \exp(i H t)$ for some operator $H$, where $\exp$ is the matrix exponential as described in [advanced matrices](xref:microsoft.quantum.concepts.matrix-advanced).</span></span>
<span data-ttu-id="5830f-190">$H $의 eigenstate $ \ket{\phi} $는 $H \ket{\phi} = \em\ket{\phi} $이 고 모든 $t $, \begin{station} U (t) \ket{\phi} = e ^ {\\emt} \ket{\phi}.에 대 한 $U (t) $의 eigenstate 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-190">An eigenstate $\ket{\phi}$ of $H$ such that $H \ket{\phi} = \phi \ket{\phi}$ is then also an eigenstate of $U(t)$ for all $t$, \begin{equation} U(t) \ket{\phi} = e^{i \phi t} \ket{\phi}.</span></span>
<span data-ttu-id="5830f-191">\end{equation}</span><span class="sxs-lookup"><span data-stu-id="5830f-191">\end{equation}</span></span>

<span data-ttu-id="5830f-192">[Bayesian 단계 예측](#bayesian-phase-estimation) 에 대해 설명 하는 것과 정확히 동일한 분석이 적용 될 수 있으며,이 함수는 보다 일반적인 oracle 모델인 $ $ \Pr (\texttt{Zero} | \\; t, \pr) = \pr ^ 2 \ left (\frac{t [\\al\테타]} \pr)와 정확히 동일 합니다 {2} .</span><span class="sxs-lookup"><span data-stu-id="5830f-192">The exact same analysis discussed for [Bayesian phase estimation](#bayesian-phase-estimation) can be applied, and the likelihood function is the precisely the same for this more general oracle model: $$ \Pr(\texttt{Zero} | \phi; t,\theta)=\cos^2\left(\frac{t[\phi -\theta]}{2}\right).</span></span>
<span data-ttu-id="5830f-193">$ $ 또한 [Hamiltonian 시뮬레이션](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation)의 경우와 마찬가지로 $ 동적 생성기의 시뮬레이션 인 $U 경우 $ \aa$를 에너지로 해석 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-193">$$ Moreover, if $U$ is a simulation of a dynamical generator, as is the case for [Hamiltonian simulation](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), we interpret $\phi$ as an energy.</span></span>
<span data-ttu-id="5830f-194">따라서 연속 쿼리를 사용 하 여 단계 예측을 사용 하면 $t $를 정수로 요구 하 여 선택한 [실험을 손상](https://arxiv.org/abs/1510.03859) [시 키 지](https://arxiv.org/abs/1111.3633v2) 않고 시뮬레이션 된 [에너지 스펙트럼의](https://arxiv.org/abs/quant-ph/0604193)시뮬레이션을 molecules 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-194">Thus, using phase estimation with continuous queries allows us to learn the simulated [energy spectrum of molecules](https://arxiv.org/abs/quant-ph/0604193), [materials](https://arxiv.org/abs/1510.03859) or [field theories](https://arxiv.org/abs/1111.3633v2) without having to compromise our choice of experiments by requiring $t$ to be an integer.</span></span>

### <a name="random-walk-phase-estimation"></a><span data-ttu-id="5830f-195">무작위 워크 단계 예측</span><span class="sxs-lookup"><span data-stu-id="5830f-195">Random Walk Phase Estimation</span></span> ###

<span data-ttu-id="5830f-196">:::no-loc(Q#)::: 반복 단계 추정에서 얻은 데이터 레코드에 대 한 임의 워크를 조절 하 여 작동 하는 퀀텀 장치에 가까운 사용을 위해 설계 된 Bayesian 단계 추정의 유용한 근사값을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-196">:::no-loc(Q#)::: provides a useful approximation of Bayesian phase estimation designed for use close to quantum devices that operates by conditioning a random walk on the data record obtained from iterative phase estimation.</span></span>
<span data-ttu-id="5830f-197">이 메서드는 적응 및 완전히 결정적 이며, 예상 되는 단계 $ \hat{\phi} $에서 메모리 오버 헤드가 매우 낮으므로 거의 최적의 오류 확장을 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-197">This method is both adaptive and entirely deterministic, allowing for near-optimal scaling of errors in the estimated phase $\hat{\phi}$ with very low memory overheads.</span></span>

<span data-ttu-id="5830f-198">프로토콜이 이전 분포를 가우스로 가정 하는 대략적인 Bayesian 유추 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-198">The protocol uses an approximate Bayesian inference method that assumes the prior distribution is Gaussian.</span></span>
<span data-ttu-id="5830f-199">이러한 가우시안 가정을 통해 사후 분산을 최소화 하는 실험에 대 한 분석 수식을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-199">This Gaussian assumption allows us to use an analytical formula for the experiment that minimizes the posterior variance.</span></span>
<span data-ttu-id="5830f-200">그런 다음 해당 실험의 결과에 따라 $ \a? $의 추정치를 미리 결정 된 양만큼 이동 하 고 미리 결정 된 양만큼 분산을 축소 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-200">The algorithm then, based on the outcome of that experiment, shifts the estimate of $\phi$ left or right by a pre-determined amount and shrinks the variance by a pre-determined amount.</span></span>
<span data-ttu-id="5830f-201">이 평균 및 가변성은 다음 실험을 위해 $ \\a$의 이전에 가우스을 지정 하는 데 필요한 모든 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-201">This mean and variance give all the information that is needed to specify a Gaussian prior on $\phi$ for the next experiment.</span></span>
<span data-ttu-id="5830f-202">예기치 않은 측정 오류 이거나 초기 이전 앞부분과 뒷부분에 대 한 실제 결과가 발생 하면이 메서드가 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-202">Unexpected measurement failures, or the true result being on the tails of the initial prior, can cause this method to fail.</span></span>
<span data-ttu-id="5830f-203">실험을 수행 하 여 현재 평균과 표준 편차가 시스템에 적합 한지 테스트 하 여 오류 로부터 복구 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-203">It recovers from failure by performing experiments to test whether the current mean and standard deviation are appropriate for the system.</span></span>
<span data-ttu-id="5830f-204">그렇지 않은 경우 알고리즘은 워크의 반대 단계를 수행 하 고 프로세스가 계속 진행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-204">If they are not, then the algorithm does an inverse step of the walk and the process continues.</span></span>
<span data-ttu-id="5830f-205">또한 뒤로 이동 하는 기능을 통해 초기 이전 표준 편차가 inapropriately 작은 경우에도 알고리즘을 배울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-205">The ability to step backwards also allows the algorithm to learn even if the initial prior standard deviation is inapropriately small.</span></span>

## <a name="calling-phase-estimation-algorithms"></a><span data-ttu-id="5830f-206">단계 추정 알고리즘 호출</span><span class="sxs-lookup"><span data-stu-id="5830f-206">Calling Phase Estimation Algorithms</span></span> ##

<span data-ttu-id="5830f-207">라고과 함께 제공 되는 각 단계 예측 작업은 :::no-loc(Q#)::: 최종 예상 $ \hat{\phi} $에서 요구 하는 품질을 매개 변수화 하는 다른 입력 집합을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-207">Each phase estimation operation provided with the :::no-loc(Q#)::: canon takes a different set of inputs parameterizing the quality that we demand out of the final estimate $\hat{\phi}$.</span></span>
<span data-ttu-id="5830f-208">그러나 이러한 다양 한 입력은 모두 공통 된 여러 입력을 공유 합니다. 예를 들어, 품질 매개 변수를 통해 부분 응용 프로그램에서 일반적인 서명이 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-208">These various inputs, however, all share several inputs in common, such that partial application over the quality parameters results in a common signature.</span></span>
<span data-ttu-id="5830f-209">예를 들어 <xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation> 다음 섹션에서 설명 하는 작업에는 다음과 같은 시그니처가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-209">For example, the <xref:Microsoft.Quantum.Characterization.RobustPhaseEstimation> operation discussed in the next section has the following signature:</span></span>

```qsharp
operation RobustPhaseEstimation(bitsPrecision : Int, oracle : DiscreteOracle, eigenstate : Qubit[])  : Double
```

<span data-ttu-id="5830f-210">`bitsPrecision`입력은에 고유 `RobustPhaseEstimation` 하며, `oracle` 및 `eigenstate` 은 공통입니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-210">The `bitsPrecision` input is unique to `RobustPhaseEstimation`, while `oracle` and `eigenstate` are in common.</span></span>
<span data-ttu-id="5830f-211">따라서 **H2Sample** 에서 볼 수 있듯이 작업은 폼의 입력을 사용 하 여 반복적인 단계 추정 알고리즘을 허용 `(DiscreteOracle, Qubit[]) => Unit` 하 여 사용자가 임의 단계 추정 알고리즘을 지정할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-211">Thus, as seen in **H2Sample** , an operation can accept an iterative phase estimation algorithm with an input of the form `(DiscreteOracle, Qubit[]) => Unit` to allow a user to specify arbitrary phase estimation algorithms:</span></span>

```qsharp
operation H2EstimateEnergy(
    idxBondLength : Int,
    trotterStepSize : Double,
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double
```

<span data-ttu-id="5830f-212">이러한 방대한 단계 추정 알고리즘은 대상 응용 프로그램에 가장 적합 한 항목을 선택 하기 위해 이해 해야 하는 다양 한 속성 및 입력 매개 변수에 대해 최적화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-212">These myriad phase estimation algorithms are optimized for different properties and input parameters, which must be understood to make the best choice for the target application.</span></span> <span data-ttu-id="5830f-213">예를 들어 일부 단계 추정 알고리즘은 적응입니다. 즉, 이후 단계는 이전 단계의 측정 결과에 의해 일반적으로 제어 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-213">For instance, some phase estimation algorithms are adaptive, meaning that future steps are classically controlled by the measurement results of previous steps.</span></span> <span data-ttu-id="5830f-214">일부 경우에는 임의 실수에 의해 블랙 박스 단일 oracle을 exponentiate 하는 기능이 필요 하 고, 다른 사용자에 게는 정수 거듭제곱이 필요 하지만 단계 추정 모듈로 $2 \ pi $를 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-214">Some require the ability to exponentiate its black-box unitary oracle by arbitrary real powers, and others only require integer powers but are only able to resolve a phase estimate modulo $2\pi$.</span></span> <span data-ttu-id="5830f-215">일부는 많은 보조 비트 비트가 필요 하며, 다른 일부는 하나만 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-215">Some require many auxiliary qubits, and others require only one.</span></span>

<span data-ttu-id="5830f-216">마찬가지로 임의의 워크 단계 예측을 사용 하는 것은 canon과 함께 제공 되는 다른 알고리즘과 거의 동일한 방식으로 진행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5830f-216">Similarly, using random walk phase estimation proceeds in much the same way as for other algorithms provided with the canon:</span></span>

```qsharp
operation ApplyExampleOracle(
    eigenphase : Double,
    time : Double,
    register : Qubit[])
: Unit is Adj + Ctl {
    Rz(2.0 * eigenphase * time, register[0]);
}

operation EstimateBayesianPhase(eigenphase : Double) : Double {
    let oracle = ContinuousOracle(ApplyExampleOracle(eigenphase, _, _));
    using (eigenstate = Qubit()) {
        X(eigenstate);
        // The additional inputs here specify the mean and variance of the prior, the number of
        // iterations to perform, how many iterations to perform as a maximum, and how many
        // steps to roll back on an approximation failure.
        let est = RandomWalkPhaseEstimation(0.0, 1.0, 61, 100000, 1, oracle, [eigenstate]);
        Reset(eigenstate);
        return est;
    }
}
```
