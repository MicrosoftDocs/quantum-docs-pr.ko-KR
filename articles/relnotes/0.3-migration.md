---
title: QDK 0.3 언어 검토 및 마이그레이션 가이드
description: 'Microsoft Quantum Development Kit 0.3의 새로운 기능과 기존 Q # 프로그램을 마이그레이션하는 방법에 대해 설명 합니다.'
author: beheim
uid: microsoft.quantum.relnotes.migration-0-3
ms.author: bettina.heim@microsoft.com
ms.date: 10/29/2018
ms.topic: article
ms.openlocfilehash: df86bf163a300c1ce55d3959bd40aea3d8b8a973
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907735"
---
# <a name="qdk-03-language-release-notes-and-migration-guide"></a><span data-ttu-id="c181b-103">QDK 0.3 언어 릴리스 정보 및 마이그레이션 가이드</span><span class="sxs-lookup"><span data-stu-id="c181b-103">QDK 0.3 language release notes and migration guide</span></span>

<span data-ttu-id="c181b-104">퀀텀 개발 키트에 대 한 최신 업데이트를 소개 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-104">We are excited to introduce the newest update to the Quantum Development Kit.</span></span>  <span data-ttu-id="c181b-105">이 페이지에서는 새로운 Q # 언어 기능에 대 한 개요를 제공 하 고 기존 Q # 프로그램을 새 구문으로 [마이그레이션하](#Migration) 는 방법에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-105">This page gives an overview of the new Q# language features and describes how to [migrate](#Migration) existing Q# programs to the new syntax.</span></span>  <span data-ttu-id="c181b-106">[여기](xref:microsoft.quantum.language.intro)에서 Q # 언어에 대 한 전체 설명은 전체 설명서를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="c181b-106">See our complete documentation for the full description of the Q# language [here](xref:microsoft.quantum.language.intro).</span></span>


## <a name="whats-new"></a><span data-ttu-id="c181b-107">What's New</span><span class="sxs-lookup"><span data-stu-id="c181b-107">What's New</span></span> 

<span data-ttu-id="c181b-108">0\.3 업데이트에는 새로운 언어와 편집기 기능이 함께 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-108">The 0.3 update comes with a range of new language and editor features.</span></span>

### <a name="overview-of-features"></a><span data-ttu-id="c181b-109">기능 개요</span><span class="sxs-lookup"><span data-stu-id="c181b-109">Overview of Features</span></span>

- <span data-ttu-id="c181b-110">다음을 포함 하 여 Visual Studio 및 Visual Studio Code에 대 한 향상 된 개발 도구 통합</span><span class="sxs-lookup"><span data-stu-id="c181b-110">Enhanced development tool integration for Visual Studio and Visual Studio Code, including:</span></span>
    - <span data-ttu-id="c181b-111">실시간 컴파일 및 입력에 대 한*피드백 (있는* 경우)</span><span class="sxs-lookup"><span data-stu-id="c181b-111">Live compilation and feedback on typing (*a.k.a.*</span></span> <span data-ttu-id="c181b-112">물결 모양의 밑줄).</span><span class="sxs-lookup"><span data-stu-id="c181b-112">squiggly underlining).</span></span>
    - <span data-ttu-id="c181b-113">설명서 요약 및 형식 서명을 포함 한 정보를 마우스로 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-113">Hover information including documentation summaries and type signatures.</span></span>
    - <span data-ttu-id="c181b-114">정의로 이동에 대 한 지원.</span><span class="sxs-lookup"><span data-stu-id="c181b-114">Support for go to definition.</span></span>
    - <span data-ttu-id="c181b-115">네임 스페이스, 작업, 함수 및 형식 선언을 쉽게 탐색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-115">Easy navigation to namespace, operation, function, and type declarations.</span></span>
    - <span data-ttu-id="c181b-116">진단 메시지를 개선 했습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-116">Improved diagnostic messages.</span></span>
- <span data-ttu-id="c181b-117">언어 개선 사항</span><span class="sxs-lookup"><span data-stu-id="c181b-117">Language improvements</span></span>
    - <span data-ttu-id="c181b-118">및 borrowing를 사용 하 여 단일의 비트 and 튜플 초기화</span><span class="sxs-lookup"><span data-stu-id="c181b-118">Single qubit and tuple initializations within using and borrowing</span></span>
    - <span data-ttu-id="c181b-119">모든 할당에 대 한 튜플 분해</span><span class="sxs-lookup"><span data-stu-id="c181b-119">Tuple deconstruction on all assignments</span></span>
    - <span data-ttu-id="c181b-120">배열 반복</span><span class="sxs-lookup"><span data-stu-id="c181b-120">Iteration over arrays</span></span>
    - <span data-ttu-id="c181b-121">조건부 식</span><span class="sxs-lookup"><span data-stu-id="c181b-121">Conditional expressions</span></span>
    - <span data-ttu-id="c181b-122">작업에 대 한 기본 특수화 약어</span><span class="sxs-lookup"><span data-stu-id="c181b-122">Default-specialization abbreviation for operations</span></span>
    - <span data-ttu-id="c181b-123">자동 생성 된 형식 생성자</span><span class="sxs-lookup"><span data-stu-id="c181b-123">Auto-generated type constructors</span></span>
    - <span data-ttu-id="c181b-124">식 한정자</span><span class="sxs-lookup"><span data-stu-id="c181b-124">Expression modifiers</span></span>


## <a name="editor-features"></a><span data-ttu-id="c181b-125">편집기 기능</span><span class="sxs-lookup"><span data-stu-id="c181b-125">Editor Features</span></span>

<span data-ttu-id="c181b-126">이제 퀀텀 개발 키트에는 Visual Studio 및 Visual Studio Code에 대 한 클라이언트 통합 뿐만 아니라 Q # 용 언어 서버가 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-126">The Quantum Development Kit now includes a language server for Q#, as well as the client integrations for Visual Studio and Visual Studio Code.</span></span>
<span data-ttu-id="c181b-127">이렇게 하면 입력 시 오류 및 경고에 구불구불한 밑줄이 쳐지는 형태로 실시간 피드백을 포함하는 새 IntelliSense 기능 집합을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-127">This enables a new set of IntelliSense features along with live feedback on typing in form of squiggly underlinings of errors and warnings.</span></span>
<span data-ttu-id="c181b-128">특히, 정의로 이동이 지원 되며 유형 정보 뿐만 아니라 정보를 포함 하는 정보를 표시 하 고 문서화 된 주석의 정보를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-128">In particular, go to definition is now supported and hover information is displayed containing type information as well as information from documenting comments.</span></span> <span data-ttu-id="c181b-129">또한 정의 된 네임 스페이스, 작업, 함수 및 형식에 대 한 기호 정보를 사용할 수 있으며이를 통해 선언으로 빠르게 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-129">Additionally, symbol information about defined namespaces, operations, functions, and types is available and allows to quickly navigate to declarations.</span></span>    
<span data-ttu-id="c181b-130">이 업데이트는 진단 메시지를 전반적으로 크게 개선합니다. 탐색이 쉬워지고 진단 범위가 정확해지며 가리켜서 표시된 정보에서 추가 정보를 쉽게 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-130">This update greatly improves diagnostic messages in general, with easy navigation to and precise ranges for diagnostics and additional details in the displayed hover information.</span></span> 

<span data-ttu-id="c181b-131">이 0.3 릴리스의 경우 퀀텀 개발 키트에 포함 된 언어 서버는 여러 작업 영역을 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-131">For this 0.3 release, the language server included with the Quantum Development Kit does not support multiple workspaces.</span></span>
<span data-ttu-id="c181b-132">VS Code에서 프로젝트를 사용 하려면 프로젝트 자체와 참조 된 모든 프로젝트가 포함 된 루트 폴더를 엽니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-132">In order to work with a project in VS Code, open the root folder containing the project itself and all referenced projects.</span></span>
<span data-ttu-id="c181b-133">Visual Studio에서 솔루션을 사용하려면 솔루션에 포함된 모든 프로젝트가 솔루션이 있는 폴더나 그 하위 폴더 중 하나에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-133">In order to work with a solution in Visual Studio, all projects contained in the solution need to be in the same folder as the solution or in one of its subfolders.</span></span>

## <a name="language-features"></a><span data-ttu-id="c181b-134">언어 기능</span><span class="sxs-lookup"><span data-stu-id="c181b-134">Language Features</span></span>

<span data-ttu-id="c181b-135">언어 기능을 기준으로이 업데이트는 다양 한 언어 패턴의 처리를 통합 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-135">In terms of language features, this update unifies the treatment of a range of language patterns.</span></span>
<span data-ttu-id="c181b-136">예를 들어 형식 생성자는 각 사용자 정의 형식에 대해 생성 되 고 다른 함수와 마찬가지로 부분적으로 적용 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-136">Type constructors, as an example, are generated for each user defined type and can be partially applied much like any other function.</span></span>
<span data-ttu-id="c181b-137">또 다른 예로는 모든 할당 내에서 완전히 지원 되는 튜플 분해 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-137">Another example is tuple deconstruction, which is now fully supported within all assignments.</span></span> <span data-ttu-id="c181b-138">여기에는 let, mutable 및 set 문 뿐만 아니라 for 루프의 반복 변수와-및 borrowing 할당을 사용 하는 것도 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-138">This includes not only let-, mutable-, and set-statements, but also the iteration variable in for-loops as well as using- and borrowing-allocations.</span></span> <span data-ttu-id="c181b-139">또한 부분 분해는 0.3 업데이트에서 새로 지원 됩니다. 분해의 밑줄은 무시 될 값의 일부를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-139">Additionally, partial deconstructions are newly supported with the 0.3 update; underscores in deconstructions indicate parts of the value that are to be ignored.</span></span> 

<span data-ttu-id="c181b-140">다음 코드에서는 몇 가지 새로운 기능을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-140">The following code illustrates some of the new features:</span></span>
```qsharp
    let tuples = [(1, 0), (0, 1)];
    mutable res = (0, 0, 0);

    // For-loops can iterate over arrays, and can destructure tuples.
    for ((i1, i2) in tuples) {

        // Mutable assignments can now destructure and ignore parts of tuples,
        // using the same syntax as let-bindings.
        mutable (r1, r2, _) = res;
        set (r1, r2) = (r1 ||| i1, r2 &&& i2);

        let (_, _, s) = res;
        // The new conditional operator can be used inside expressions, avoiding
        // the need for extraneous if-statements.
        set res = (r1, r2, r1 == r2 ? s | s + 1);
    }
```
<span data-ttu-id="c181b-141">마지막 set 문은 0.3 업데이트에 도입 된 새 삼항 연산자를 사용 하 여 조건식을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-141">The last set statement uses a new ternary operator that is introduced with the 0.3 update to support conditional expressions.</span></span>
<span data-ttu-id="c181b-142">조건식은 `condition ? caseTrue | caseFalse`폼의 식입니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-142">A conditional expression is an expression of the form `condition ? caseTrue | caseFalse`.</span></span>
<span data-ttu-id="c181b-143">위의 예제에서 볼 수 있듯이 이제 배열 반복도 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-143">As can be seen from the example above, iteration over arrays is now also supported.</span></span>

<span data-ttu-id="c181b-144">`using` 및 `borrowing` 내의 할당은 다음과 같은 단일의 비트, 고 비트 배열 및 중첩 튜플을 새로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-144">Allocations within `using` and `borrowing` are newly possible for single qubits, qubit arrays, and nested tuples thereof:</span></span>
```qsharp
    using (qubit = Qubit()) {
        // qubit contains a single qubit
    }

    borrowing ((qubits, qubit) = (Qubit[3], Qubit())) {
        // qubits contains an array of three qubits, and qubit contains a single qubit
    }
```

<span data-ttu-id="c181b-145">함수 특수화가 생성 되는 방식에 대 한 제어를 향상 시키기 위해 `auto` 외에도 두 개의 새로운 특수화 생성기 지시문 `invert` 및 `distribute`가 도입 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-145">Two new specialization generator directives `invert` and `distribute` in addition to `auto` are introduced to increase control over how functor specializations are generated.</span></span>
<span data-ttu-id="c181b-146">작업 내에서 기본 `body` 특수화를 명시적으로 선언 하는 것은 더 이상 필수가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-146">An explicit declaration of the default `body` specialization within operations is no longer mandatory.</span></span>
<span data-ttu-id="c181b-147">함수와 마찬가지로 작업 내에 다른 특수화가 선언 되지 않은 경우 문은 작업 선언 자체에 직접 추가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-147">Similar to functions, statements may be directly added to the operation declaration itself if no other specialization is declared within the operation.</span></span>
<span data-ttu-id="c181b-148">마이그레이션 스크립트는 기존 코드를 마이그레이션하고 새로운 언어 기능을 활용 하는 데 도움이 되는 릴리스에 포함 되어 있습니다 ( [마이그레이션 스크립트의 섹션](#MigrationScript)참조).</span><span class="sxs-lookup"><span data-stu-id="c181b-148">A migration script is included in the release to help migrating existing code and taking advantage of new language features (see the [section on the migration script](#MigrationScript)).</span></span>

<span data-ttu-id="c181b-149">사용자 정의 형식을 처리 하는 방법의 주요 변경 내용에는 0.3 업데이트가 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-149">A major change in how user-defined types are treated comes with the 0.3 update.</span></span> <span data-ttu-id="c181b-150">이전 릴리스에서는 사용자 정의 형식을 기본 형식의 하위 형식으로 처리 했지만 앞으로는 그렇지 않습니다 ( [주요 변경 내용에 대 한 섹션](#BreakingChanges)참조).</span><span class="sxs-lookup"><span data-stu-id="c181b-150">While prior releases treated user defined types as subtypes of their underlying type, this is no longer the case going forward (see also the [section on breaking changes](#BreakingChanges)).</span></span>  
<span data-ttu-id="c181b-151">이 변경의 일부로 특정 식에 적용 될 수 있는 식 한정자를 소개 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-151">As part of this change we introduce expression modifiers that can be applied to certain expressions.</span></span> <span data-ttu-id="c181b-152">한정자를 적용할 수 있는 "atomic" 식은 식별자, 배열 항목 식 및 인자 1 튜플입니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-152">The "atomic" expressions that modifiers can be applied to are identifiers, array item expressions, and arity-1 tuples.</span></span>
<span data-ttu-id="c181b-153">한정자는 다른 식 조합 기 보다 긴밀 하 게 바인딩되고 특히 호출 식 조합 기 `(` `)`보다 더 강력 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-153">Modifiers bind tighter than any other expression combinator, and in particular tighter than the call-expression combinator `(` `)`.</span></span> 
<span data-ttu-id="c181b-154">`Adjoint`, `Controlled`및 새로운 "래핑 해제" 후 위 연산자 `!` 식 한정자로 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-154">`Adjoint`, `Controlled`, and a new "unwrap" postfix operator `!` are treated as expression modifiers.</span></span> <span data-ttu-id="c181b-155">`Adjoint` 및 `Controlled`를 식 한정자로 처리 하면 많은 사례에서 괄호가 필요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-155">Treating `Adjoint` and `Controlled` as expression modifiers eliminates the need for parenthesis for a lot of cases.</span></span> <span data-ttu-id="c181b-156">예를 들어 아래 식은 `Op`, 단일 작업, 단일 작업 배열을 `opArr` 하 고, 적절 한 인수를 `arg` 하는 데 유효 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-156">The expressions below for example are valid going forward for `Op`, a unitary operation, `opArr` an array of unitary operations, and `arg` a suitable argument:</span></span> 
```qsharp
    Adjoint Op (arg);
    Controlled opArr[i] (arg);
```
<span data-ttu-id="c181b-157">마이그레이션 스크립트는 대부분의 불필요 한 괄호를 삭제 하 고 새로운 기능을 최대한 활용 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-157">The migration script will drop most of the unnecessary parenthesis and take full advantage of the new features.</span></span> <span data-ttu-id="c181b-158">그러나 스크립트는 코드를 해석 하지 않으며 드문 경우에 `Controlled` 함수를 다르게 해석 하는 것을 고려 하지 않습니다 (부분 응용 프로그램과만 관련 됨).</span><span class="sxs-lookup"><span data-stu-id="c181b-158">However, be advised that the script does not interpret the code, and will not account for the different interpretation of the `Controlled` functor in rare cases (only relevant in combination with partial applications).</span></span>

<span data-ttu-id="c181b-159">새 한정자 `!` 사용자 정의 형식을 기본 형식으로 캐스팅 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-159">The new modifier `!` casts a user-defined type to its underlying type.</span></span> <span data-ttu-id="c181b-160">이 캐스트는 이전 릴리스에서 업 캐스트 고려 되었으며 자동으로 실행 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-160">This cast has been considered an upcast in previous releases and was executed automatically.</span></span> <span data-ttu-id="c181b-161">사용자 정의 형식에 대 한 새로운 해석을 사용 하면 더 이상 그렇지 않으며 캐스트를 명시적으로 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-161">With the new interpretation of user defined types this is no longer the case and the cast needs to be made explicit.</span></span>    
<span data-ttu-id="c181b-162">다음 예제에서는 new 한정자를 사용 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-162">The following example illustrates how to use the new modifier:</span></span> 
```qsharp
    newtype Unitary = (Qubit => Unit: Adjoint, Controlled);

    operation Foo (unitaries : Unitary[], qubit : Qubit) : Unit {

        for (unitary in unitaries[1 .. Length(unitaries)-1]) {
            // Each element of unitaries is an instance of the user-defined
            // type Unitary, so unitary! unwraps each element to an operation
            // type that we can call.
            unitary! (qubit);
            // The unwrap operator can also be used as a part of functor
            // expressions and when indexing into arrays.
            Adjoint unitary! (qubit);
            Adjoint unitaries[0]! (qubit);
        }
    }
```
<span data-ttu-id="c181b-163">예제에서 볼 수 있듯이 `!`은 `Controlled` 및 `Adjoint`와 같이 접두사 한정자 보다 더 엄격 하 게 바인딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-163">As can be seen from the example, `!` binds tighter than prefix modifiers, like `Controlled` and `Adjoint`.</span></span>

## <a name="BreakingChanges"></a><span data-ttu-id="c181b-164">주요 변경 내용</span><span class="sxs-lookup"><span data-stu-id="c181b-164">Breaking Changes</span></span> 

<span data-ttu-id="c181b-165">0\.3 업데이트는 새 컴파일러와 함께 제공 되며 몇 가지 주요 변경 사항이 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-165">The 0.3 update comes with a new compiler and contains a handful of breaking changes.</span></span>
<span data-ttu-id="c181b-166">기존 코드 업데이트를 용이 하 게 하기 위해 컴파일러는 유효 하거나 잘못 된 코드를 컴파일하고 빌드된 컴파일에 따라 서식이 지정 된 Q # 코드를 내보내는 서식 지정 옵션도 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-166">To facilitate updating existing code, the compiler also provides a formatting option that compiles valid or invalid code and emits formatted Q# code based on the built compilation.</span></span>
<span data-ttu-id="c181b-167">모든 구문 변경 내용은 제공 된 도구에서 자동으로 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-167">All syntax changes will be processed automatically by the provided tool.</span></span> <span data-ttu-id="c181b-168">그러나 유효한 코드를 해석 하는 방법에 대 한 변경 (의미 변경)은 수동으로 수행 해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-168">However, changes in how valid code is interpreted (semantic changes) may need to be made manually.</span></span> 

<span data-ttu-id="c181b-169">아래에 나열 된 변경 내용 외에도 패턴은 `__*__` 합니다. 여기서 \*는 공백이 아닌 문자 시퀀스는 내부용으로 예약 되어 있으며 기호 이름으로 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-169">In addition to the changes listed below, the pattern `__*__` where \* is any sequence of non-whitespace characters is reserved for internal use and cannot be used as a symbol name.</span></span>  

## <a name="syntax-changes"></a><span data-ttu-id="c181b-170">구문 변경</span><span class="sxs-lookup"><span data-stu-id="c181b-170">Syntax Changes</span></span> 

- <span data-ttu-id="c181b-171">버전 0.3부터 배열 항목은 더 이상 세미콜론으로 구분 되지 않지만 대신 쉼표로 구분 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-171">Starting with the version 0.3, array items are no longer separated by semicolons, but are separated by commas instead.</span></span>
- <span data-ttu-id="c181b-172">반면, 특수화 선언에 대 한 자동 생성 지시문 뒤에는 세미콜론이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-172">A semicolon on the other hand is required after an auto-generation directive for specialization declarations.</span></span>
- <span data-ttu-id="c181b-173">-, Elif 및 until 절의 조건은 괄호 안에 캡슐화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-173">Conditions in if-, elif-, and until-clauses need to be encapsulated in parenthesis.</span></span> 

<span data-ttu-id="c181b-174">다른 모든 구문 변경의 경우 컴파일러는 이전 구문이 사용 되는 경우에만 경고를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-174">For all other syntax changes the compiler will simply generate a warning if the old syntax is used.</span></span>     
<span data-ttu-id="c181b-175">이러한 변경에 대 한 한 가지 예는 사용자 정의 특수화의 기호 튜플입니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-175">One example for such a change is the symbol tuple in user-defined specializations.</span></span> <span data-ttu-id="c181b-176">이전 릴리스에서는 제어 되거나 제어 된 adjoint 특수화 선언이 단일 기호 인수를 지정 했지만 0.3부터 시작 하 여 컴파일러에서 필요한 경우 호출 가능한 선언에서 기호를 마이그레이션해야 함을 나타내는 `...`를 사용 하 여 모든 특수화에 대해 이러한 기호 튜플을 제공 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-176">While in previous releases a controlled or controlled-adjoint specialization declaration specified a single symbol argument, starting in 0.3 it is encouraged to provide such a symbol tuple for all specialization with `...` indicating that the compiler should migrate the symbols from the callable declaration if needed.</span></span> 

## <a name="semantic-changes"></a><span data-ttu-id="c181b-177">의미 체계 변경</span><span class="sxs-lookup"><span data-stu-id="c181b-177">Semantic Changes</span></span> 

<span data-ttu-id="c181b-178">0\.3 릴리스의 가장 중요 한 기능은 사용자 정의 형식이 형식 시스템에 통합 되는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-178">The most impactful breaking for the 0.3 release is how user-defined types are integrated into the type system.</span></span> <span data-ttu-id="c181b-179">이전 릴리스에서는 사용자 정의 형식이 기본 형식의 하위 형식으로 간주 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-179">In prior releases user defined types were considered to be a subtype of their underlying type.</span></span> <span data-ttu-id="c181b-180">이 릴리스와 앞으로 진행 되는 경우에는 더 이상 그렇지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-180">With this release and going forward this is no longer the case.</span></span> <span data-ttu-id="c181b-181">이제 사용자 정의 형식은 고유 형식으로 간주 되며 사용자 정의 형식과 해당 기본 형식 간에 자동 캐스트가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-181">User defined types are now considered to be their own distinct type, and no automatic cast between a user defined type and its underlying type exists.</span></span> <span data-ttu-id="c181b-182">모든 캐스트는 `!`"래핑 해제" 연산자를 통해 명시적으로 설정 해야 하며, 특히 사용자 정의 형식 개체의 콘텐츠에 액세스 하는 데 캐스트가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-182">All casts need to be made explicit via an "unwrap" operator `!`, and a cast is needed in particular to access the content of a object of user defined type.</span></span>  

<span data-ttu-id="c181b-183">형식 시스템에 대 한 수정에는 배열의 가변성 동작 및 형식의 매개 변수가 있는 개체의 처리도 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-183">The modifications to the type system also include the variance behavior of arrays, and the treatment of type parameterized objects.</span></span> <span data-ttu-id="c181b-184">0\.3부터 변경 가능 하 고 변경할 수 없는 배열은 모두 고정입니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-184">Starting in 0.3, both mutable and immutable arrays are invariant.</span></span> <span data-ttu-id="c181b-185">또한 호출 가능으로 전달 된 인수는 매개 변수가 있는 형식일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-185">Additionally, arguments passed to a callable cannot be type parameterized.</span></span> <span data-ttu-id="c181b-186">이러한 경우에는 식별자와 함께 형식 인수를 전달 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-186">In these cases, type arguments must be passed along with the identifer.</span></span>

<span data-ttu-id="c181b-187">이전 버전의 Q # 컴파일러에서는 함수 값에 올바른 입력 및 출력 형식이 있는 경우 작업 값이 예상 되는 위치에 함수 값을 제공할 수 있었습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-187">Previous releases of the Q# compiler allowed a function value to be provided where an operation value was expected, as long as the function value had the correct input and output types.</span></span> <span data-ttu-id="c181b-188">이는 Q # 언어 사양에 지정 되지 않은 의도 하지 않은 동작 이었습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-188">This was unintended behavior that is not specified in the Q# language specification.</span></span>
<span data-ttu-id="c181b-189">0\.3 컴파일러에서는 함수 값이 더 이상 작업 값으로 간주 되지 않도록이 동작을 제거 했습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-189">In the 0.3 compiler, we have removed this behavior so that function values are no longer considered operation values.</span></span>
<span data-ttu-id="c181b-190">이 버그에 의존 하는 기존 코드의 중단을 최소화 하기 위해 함수를 동일한 입력 및 출력 형식의 작업으로 명시적으로 변환 하는 Microsoft의 양자 네임 스페이스에 ToOperation 함수를 추가 했습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-190">To minimize the disruption to existing code that relied on this bug, we have added the ToOperation function in the Microsoft.Quantum.Canon namespace that will explicitly convert a function into an operation with the same input and output types.</span></span>

<span data-ttu-id="c181b-191">다음 예에서는 `ToOperation` 함수를 사용 하 여 함수 `Square`를 작업 `op`으로 변경 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-191">The following example illustrates how to use the `ToOperation` function to change a function `Square` to an operation `op`:</span></span> 
```qsharp
namespace Microsoft.Quantum.Tests {
    open Microsoft.Quantum.Primitive;
    open Microsoft.Quantum.Canon;

    function Square(x : Int) : Int {
        return x * x;
    }

    operation ApplyOp<'T, 'U>(op : ('T => 'U), input : 'T) : 'U {
        return op(input);
    }

    operation ToOperationTest() : Unit {
        let op = ToOperation(Square);
        AssertIntEqual(ApplyOp(op, 3), 9, "ToOperation failed with Square.");
    }
}
```

## <a name="requirements"></a><span data-ttu-id="c181b-192">요구 사항</span><span class="sxs-lookup"><span data-stu-id="c181b-192">Requirements</span></span> 

<span data-ttu-id="c181b-193">릴리스는 Windows 10 용 Visual Studio 2017 버전 15.8 이상 및 Windows 10, macOS 및 Linux 용 Visual Studio Code 버전 1.27.2 이상에서 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-193">The release is supported on Visual Studio 2017 version 15.8 or later for Windows 10, and on Visual Studio Code version 1.27.2 or later for Windows 10, macOS, and Linux.</span></span>

<span data-ttu-id="c181b-194">퀀텀 개발 키트는 .NET Core SDK (2.0 이상)를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-194">The Quantum Development Kit uses the .NET Core SDK (2.0 or later).</span></span>

## <a name="installation"></a><span data-ttu-id="c181b-195">설치</span><span class="sxs-lookup"><span data-stu-id="c181b-195">Installation</span></span>  

<span data-ttu-id="c181b-196">[여기](../install-guide/index.md)에서 설치 지침을 따르세요.</span><span class="sxs-lookup"><span data-stu-id="c181b-196">Follow the installation instructions [here](../install-guide/index.md).</span></span>

<span data-ttu-id="c181b-197">확인할 수 없는 "System.object"의 서로 다른 버전 사이에 충돌이 발생 했습니다. 현재 버전의 .NET Core SDK 최신 버전이 아닌 경우 "입니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-197">You may see warnings ("Found conflicts between different versions of "System.Reflection.Metadata" that could not be resolved.") if your current version of .NET Core SDK is not up to date.</span></span>  <span data-ttu-id="c181b-198">그러나 .NET Core SDK (2.0 이상)를 사용 하는 경우 이러한 경고가 무시 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-198">However, if you are using .NET Core SDK (2.0 or later), these warnings may be ignored.</span></span>


- <span data-ttu-id="c181b-199">이 릴리스는 퀀텀 개발 키트의 기존 기능과이 릴리스에서 사용할 수 있는 새로운 기능을 모두 사용 하는 방법을 보여 주는 다양 한 샘플과 함께 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-199">The release is provided along with a number of different samples showing how to use both existing features of the Quantum Development Kit, and the new features available with this release.</span></span> <span data-ttu-id="c181b-200">이러한 샘플은 [Microsoft/퀀텀](https://github.com/Microsoft/Quantum) 리포지토리의 GitHub에서 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-200">These samples can be can be found on GitHub at the [Microsoft/Quantum](https://github.com/Microsoft/Quantum) repository.</span></span>


## <a name="Migration"></a><span data-ttu-id="c181b-201">기존 프로젝트를 Q # 0.3로 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="c181b-201">Migrating Existing Projects to Q# 0.3</span></span> 

<span data-ttu-id="c181b-202">퀀텀 Development Kit 버전 0.2의 기존 Q # 프로젝트가 있는 경우 해당 프로젝트를 최신 버전으로 마이그레이션하는 단계는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-202">If you have existing Q# projects from version 0.2 of the Quantum Development Kit, the following are the steps to migrate those projects to the newest version.</span></span> <span data-ttu-id="c181b-203">또한 프로세스에 도움이 되는 [마이그레이션 스크립트도](#MigrationScript) 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-203">We also provide a [migration script](#MigrationScript) to help you with the process.</span></span>

> [!NOTE]
> <span data-ttu-id="c181b-204">프로젝트는 순서대로 업그레이드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-204">Projects need to be upgraded in order.</span></span> <span data-ttu-id="c181b-205">여러 프로젝트가 포함 된 솔루션이 있는 경우 각 프로젝트를 참조 하는 순서 대로 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-205">If you have a solution with multiple projects update each project in the order they are referenced.</span></span>


1. <span data-ttu-id="c181b-206">명령줄에서 `dotnet clean`을 실행하여 기존의 모든 이진 파일과 중간 파일을 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-206">From a command line, Run `dotnet clean` to remove all existing binaries and intermediate files.</span></span>
2. <span data-ttu-id="c181b-207">텍스트 편집기에서 .csproj 파일을 편집 하 여 모든 "0.3.1811.2802 `PackageReference`"의 버전을 버전-preview로 변경 합니다. 예를 들면 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-207">In a text editor, edit the .csproj file to change the version of all the "Microsoft.Quantum" `PackageReference` to version 0.3.1811.2802-preview, for example:</span></span>
```xml
    <PackageReference Include="Microsoft.Quantum.Canon" Version="0.3.1811.2802" />
    <PackageReference Include="Microsoft.Quantum.Development.Kit" Version="0.3.1811.2802" />
```
4. <span data-ttu-id="c181b-208">명령줄에서 명령줄 컴파일러에 통합 된 서식 도구를 사용 하 여 다음 명령을 실행 하 여 모든 구문 변경을 처리 합니다. `dotnet msbuild /t:qsharpformat`</span><span class="sxs-lookup"><span data-stu-id="c181b-208">From the command line, use the formatting tool integrated into the command line compiler to address all syntax changes by running this command: `dotnet msbuild /t:qsharpformat`</span></span>  
    - <span data-ttu-id="c181b-209">파일이 원위치에서 마이그레이션됩니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-209">Your files will be migrated in-place.</span></span> <span data-ttu-id="c181b-210">모든 원본 파일의 백업이 `obj\qsharp\.backup` 복사 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-210">A backup of all the original files will be copied to `obj\qsharp\.backup`</span></span>
    - <span data-ttu-id="c181b-211">서식 지정 도구는 모든 컴파일 오류를 무시 하 고 빌드 컴파일에 따라 형식이 지정 된 Q # 코드를 생성 하는 프로젝트를 컴파일합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-211">The formatting tool will compile the project ignoring all compilation errors and generate formatted Q# code based on the build compilation.</span></span> 
       <span data-ttu-id="c181b-212">인식할 수 없는 기호 (예: 정의 되지 않은 변수 이름)는 서식 지정 후 수동으로 바꾸어야 하는 자리 표시자 텍스트로 바뀝니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-212">Any unrecognized symbol (e.g. an undefined variable name) will be replaced by a placeholder text that needs to be replaced manually after formatting.</span></span> <span data-ttu-id="c181b-213">이 경우 영향을 받는 파일에 대 한 경고를 생성 하는 동안 서식 지정이 성공 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-213">In this case, the formatting succeeds while generating a warning for the affected file.</span></span>     
    - <span data-ttu-id="c181b-214">파일의 서식 지정 및 특히 파일의 공백은 내보낸 코드에서 변경 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-214">The formatting and in particular any white space in the file will be changed in the emitted code.</span></span> <span data-ttu-id="c181b-215">주석은 그대로 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-215">Comments will be preserved.</span></span>   
5. <span data-ttu-id="c181b-216">이를 실행 한 후에는 코드의 의미 체계가 변경 된 경우에도 의미 체계 변경을 수동으로 해결 해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-216">After running this, you might still need to manually address semantic changes in cases where the semantic interpretation of the code has changed.</span></span> <span data-ttu-id="c181b-217">이러한 모든 오류는 Visual Studio 또는 Visual Studio Code에서 IntelliSense에 의해 보고 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-217">All these errors will be reported by IntelliSense in Visual Studio or Visual Studio Code.</span></span>
    - <span data-ttu-id="c181b-218">Visual Studio 2017 또는 Visual Studio Code에서 프로젝트의 루트 폴더 또는 포함 하는 솔루션을 엽니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-218">Open the root folder of the project or the containing solution in Visual Studio 2017 or Visual Studio Code.</span></span>
    - <span data-ttu-id="c181b-219">편집기에서 .qs 파일을 열면 출력 창에 Q# 언어 확장의 출력이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-219">After opening a .qs file in the editor, you should see the output of the Q# language extension in the output window.</span></span>
    - <span data-ttu-id="c181b-220">프로젝트를 로드한 후(출력 창에 표시됨), 각 파일을 열어 남은 모든 문제를 수동으로 해결합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-220">After the project has loaded successfully (indicated in the output window) open each file and manually to address all remaining issues.</span></span>


> [!NOTE]
> * <span data-ttu-id="c181b-221">0\.3 릴리스의 경우 퀀텀 개발 키트에 포함 된 언어 서버는 여러 작업 영역을 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-221">For the 0.3 release, the language server included with the Quantum Development Kit does not support multiple workspaces.</span></span>
> * <span data-ttu-id="c181b-222">Visual Studio Code에서 프로젝트 작업을 하려면 해당 프로젝트 자체와 참조된 모든 프로젝트가 포함된 루트 폴더를 엽니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-222">In order to work with a project in Visual Studio Code, open the root folder containing the project itself and all referenced projects.</span></span>   
> * <span data-ttu-id="c181b-223">Visual Studio에서 솔루션을 사용하려면 솔루션에 포함된 모든 프로젝트가 솔루션이 있는 폴더나 그 하위 폴더 중 하나에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-223">In order to work with a solution in Visual Studio, all projects contained in the solution need to be in the same folder as the solution or in one of its subfolders.</span></span>  
> * <span data-ttu-id="c181b-224">0\.3 이상으로 마이그레이션된 프로젝트와 이전 패키지 버전을 사용 하는 프로젝트 간 참조는 지원 **되지 않습니다** .</span><span class="sxs-lookup"><span data-stu-id="c181b-224">References between projects migrated to 0.3 and higher and projects using older package versions are **not** supported.</span></span>




## <a name="MigrationScript"></a><span data-ttu-id="c181b-225">마이그레이션 스크립트</span><span class="sxs-lookup"><span data-stu-id="c181b-225">Migration script</span></span> 

<span data-ttu-id="c181b-226">프로젝트 마이그레이션을 용이 하 게 하기 위해 [여기](https://raw.githubusercontent.com/Microsoft/Quantum/release/v0.3.1810/utilities/qdk-migrate.ps1)에서 다운로드할 수 있는 PowerShell 스크립트가 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-226">In order to facilitate project migration, a PowerShell script is provided that can be downloaded [here](https://raw.githubusercontent.com/Microsoft/Quantum/release/v0.3.1810/utilities/qdk-migrate.ps1).</span></span>
<span data-ttu-id="c181b-227">이 스크립트는 퀀텀 개발 키트 버전 0.2에서 버전 0.3을 사용 하도록 프로젝트를 마이그레이션하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-227">This script helps migrate projects from version 0.2 of the Quantum Development Kit to use version 0.3.</span></span>

> [!NOTE]
> <span data-ttu-id="c181b-228">마이그레이션 스크립트를 실행 하려면 Windows PowerShell 또는 PowerShell Core가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-228">The migration script requires Windows PowerShell or PowerShell Core to run.</span></span>
> <span data-ttu-id="c181b-229">Windows PowerShell은 Windows 10과 함께 미리 설치 되어 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-229">Windows PowerShell comes pre-installed with Windows 10.</span></span>
> <span data-ttu-id="c181b-230">https://github.com/PowerShell/PowerShell에서 Windows, macOS 또는 Linux 용 PowerShell Core를 다운로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-230">Download PowerShell Core for Windows, macOS, or Linux at https://github.com/PowerShell/PowerShell.</span></span>

<span data-ttu-id="c181b-231">이 스크립트는 다음 네 단계를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-231">The script executes the following four steps:</span></span>

- <span data-ttu-id="c181b-232">이 프로젝트는 마이그레이션이 성공할 가능성이 있는지 확인 하기 위해 이전 버전의 퀀텀 개발 키트를 사용 하 여 빌드됩니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-232">The project is built with the previous version of the Quantum Development Kit to ensure that migration is likely to succeed.</span></span> <span data-ttu-id="c181b-233">스크립트에 대 한 `-Force` 매개 변수를 사용 하 여이 단계를 건너뛸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-233">This step can be skipped by using the `-Force` parameter to the script.</span></span>
- <span data-ttu-id="c181b-234">새 프로젝트 템플릿이 설치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-234">New project templates are installed.</span></span>
- <span data-ttu-id="c181b-235">최신 버전의 퀀텀 개발 키트를 사용 하도록 프로젝트가 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-235">The project is updated to use the current version of the Quantum Development Kit.</span></span>
- <span data-ttu-id="c181b-236">퀀텀 개발 키트 버전 0.3과 함께 제공 되는 서식 지정 도구는 위에 설명 된 주요 변경 내용 대부분을 자동으로 해결 하는 데 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-236">The formatting tool provided with version 0.3 of the Quantum Development Kit is applied to automatically address most of the breaking changes documented above.</span></span>

<span data-ttu-id="c181b-237">이러한 네 단계가 완료 된 후에는 수동으로 처리 해야 하는 몇 가지 마이그레이션 문제가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-237">After these four steps complete, there may be some remaining migration issues which must be handled manually.</span></span>
<span data-ttu-id="c181b-238">최신 버전의 Visual Studio 2017 및 Visual Studio Code 용 퀀텀 개발 키트 확장을 사용 하면 이러한 문제를 쉽게 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-238">Using the latest version of the Quantum Development Kit extensions for Visual Studio 2017 and Visual Studio Code can help find these issues easily.</span></span>

<span data-ttu-id="c181b-239">스크립트에 대 한 설명서는 스크립트가 있는 폴더에서 다음 명령 중 하나를 실행 하 여 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-239">The documentation for the script can be obtained by running one of the following commands in the folder where the script is located:</span></span>

```powershell
Get-Help ./qdk-migrate.ps1
Get-Help -Online ./qdk-migrate.ps1
```

> [!NOTE]
> <span data-ttu-id="c181b-240">기본적으로 Windows는 보안 조치로 스크립트를 실행 하는 것을 방지 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-240">By default, Windows prevents the execution of any scripts as a security measure.</span></span>
> <span data-ttu-id="c181b-241">`qdk-migrate.ps1`와 같은 스크립트가 Windows에서 실행 되도록 허용 하려면 실행 정책을 변경 해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-241">To allow scripts such as `qdk-migrate.ps1` to run on Windows, you may need to change the execution policy.</span></span>
> <span data-ttu-id="c181b-242">이렇게 하려면 `Set-ExecutionPolicy` 명령을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-242">To do so, run the `Set-ExecutionPolicy` command:</span></span>
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope Process
> ```
> <span data-ttu-id="c181b-243">그런 다음 PowerShell을 종료 하면 실행 정책이 되돌려집니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-243">The execution policy will then be reverted when you exit PowerShell.</span></span>
> <span data-ttu-id="c181b-244">실행 정책을 저장 하려는 경우 `-Scope`에 대해 다른 값을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="c181b-244">If you would like to save the execution policy, use a different value for `-Scope`:</span></span>
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
> ```

