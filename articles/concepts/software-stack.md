---
title: 소프트웨어 스택 | Microsoft Docs
description: 소프트웨어 스택
author: QuantumWriter
uid: microsoft.quantum.concepts.software-stack
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: f97dfacf6cde5fa92e1f368efaae36554a5c944d
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/28/2019
ms.locfileid: "73184732"
---
# <a name="software-stack-for-quantum-computing"></a><span data-ttu-id="62959-103">퀀텀 컴퓨팅을 위한 소프트웨어 스택</span><span class="sxs-lookup"><span data-stu-id="62959-103">Software stack for quantum computing</span></span>
<span data-ttu-id="62959-104">일반적으로 컴퓨터를 생각할 때 응용 프로그램을 실행 하는 단일 장치를 구상 하지만 최신 컴퓨팅 환경은 훨씬 더 복잡 하 고 고급입니다.</span><span class="sxs-lookup"><span data-stu-id="62959-104">Normally when we think of a computer we envision a single device running an application, but modern computing environments are much more complex and advanced.</span></span> <span data-ttu-id="62959-105">상호 작용 하는 응용 프로그램은 일반적으로 응용 프로그램의 실행을 하드웨어 수준까지 제공 하는 소프트웨어의 여러 계층에 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="62959-105">The application we interact with typically rests on multiple layers of software that provide for the application's execution down to the hardware level.</span></span> <span data-ttu-id="62959-106">이러한 소프트웨어 계층은 전체 컴퓨팅 시스템의 기본 복잡성에서 응용 프로그램 솔루션의 개발을 추상화 하는 데 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="62959-106">These software layers are necessary to abstract the development of an application solution from the underlying complexity of the complete computing system.</span></span> <span data-ttu-id="62959-107">간단한 스마트폰 앱을 작성 하는 동안 개발자가 버스, 캐시 아키텍처, 통신 프로토콜 등에 대해 생각해 보아야 하는 경우 작업은 훨씬 더 복잡 해질 것입니다.</span><span class="sxs-lookup"><span data-stu-id="62959-107">If a developer had to think about bus, cache architectures, communication protocols, and more while writing a simple smartphone app, the task would become much more complex.</span></span>  <span data-ttu-id="62959-108">*소프트웨어 스택의* 개념은 이러한 문제를 해결 하기 위해 기존 컴퓨팅에서 개발 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="62959-108">The concept of a *software stack* was developed in classical computing to address these issues.</span></span>  <span data-ttu-id="62959-109">기존 개념에서 Borrowing 소프트웨어 스택은 Q #을 사용 하는 퀀텀 컴퓨팅 뒤의 핵심 부분입니다.</span><span class="sxs-lookup"><span data-stu-id="62959-109">Borrowing from the classical concept, a software stack is also a key part of the vision behind quantum computing with Q#.</span></span>

## <a name="conventional-stack"></a><span data-ttu-id="62959-110">기본 스택</span><span class="sxs-lookup"><span data-stu-id="62959-110">Conventional stack</span></span>
<span data-ttu-id="62959-111">소프트웨어 스택 뒤의 주요 개념은 재귀입니다.</span><span class="sxs-lookup"><span data-stu-id="62959-111">The key idea behind a software stack is recursion.</span></span>  <span data-ttu-id="62959-112">개발자 로부터 더 낮은 수준의 장치 세부 정보를 추상화 하는 여러 개의 중첩 된 인터페이스 계층으로 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="62959-112">It consists of several nested layers of interfaces that abstract the details of the lower levels of the device away from the developer.</span></span>  <span data-ttu-id="62959-113">예를 들어, 일반적으로 사용 되는 소프트웨어 스택은 ASP.NET (프로그래밍 언어)를 기반으로 실행 되는 SQL server (관계형 데이터베이스 관리 인터넷 정보 서비스 시스템)를 기반으로 실행 됩니다 .이는 Windows server ( 운영 체제)를 설치 합니다.</span><span class="sxs-lookup"><span data-stu-id="62959-113">For example, a commonly used software stack involves running ASP.NET (a programming language), on top of SQL server (a relational database management system), which runs on top of Internet Information Services (a web server), which runs on top of Windows server (an operating system), which drives the computer hardware.</span></span>  <span data-ttu-id="62959-114">소프트웨어를 계층 구조로 살펴보면, 아래의 모든 소프트웨어에 대 한 하위 수준 세부 정보를 이해 하지 않고도 ASP.NET에서 소프트웨어를 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62959-114">By looking at software as a hierarchy, one can write software in ASP.NET without needing to understand the low-level details of all the software below it.</span></span>

## <a name="quantum-stack"></a><span data-ttu-id="62959-115">퀀텀 스택</span><span class="sxs-lookup"><span data-stu-id="62959-115">Quantum stack</span></span>

<span data-ttu-id="62959-116">퀀텀 컴퓨팅의 소프트웨어 스택은 원칙이 다르며 실제로는 기존 스택 보다 낮은 수준에서 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="62959-116">The software stack in quantum computing is no different in principle, and in practice operates at a lower level than traditional stacks.</span></span>  <span data-ttu-id="62959-117">퀀텀 스택은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="62959-117">What does a quantum stack look like?</span></span>  <span data-ttu-id="62959-118">퀀텀 컴퓨터는 기존 (보통 기존) 컴퓨터를 대체 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="62959-118">A quantum computer is not a replacement for traditional (often called classical) computers.</span></span>  <span data-ttu-id="62959-119">사실, 사실 퀀텀 컴퓨터는 기존 컴퓨터와 함께 작동 하 여 계산 문제를 해결 합니다.</span><span class="sxs-lookup"><span data-stu-id="62959-119">In fact, quantum computers will almost certainly work in tandem with classical computers to solve computational problems.</span></span>  <span data-ttu-id="62959-120">일부는 퀀텀 데이터의 취약 때문에 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="62959-120">In part, this arises because of the fragility of quantum data.</span></span>  <span data-ttu-id="62959-121">퀀텀 데이터는 쉽게 확인할 수 있으므로 관찰 되는 정보를 거의 손상 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62959-121">Quantum data is so fragile that if you even look at it you almost certainly damage the information being observed.</span></span>  <span data-ttu-id="62959-122">따라서 실제 환경에서 발생 하는 예기치 않은 상호 작용이 실수로 정보와 계산을 손상 시 키 지 않도록 퀀텀 오류 수정 사항을 염두에 두면 퀀텀 컴퓨터를 디자인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="62959-122">Quantum computers will thus need to be designed with quantum error correction in mind so that stray interactions from its physical environment do not inadvertently damage the information and computation.</span></span> <span data-ttu-id="62959-123">이러한 이유로 Q #의 자연 목표는 퀀텀 명령 (게이트 또는 게이트 작업 이라고 함)의 목록을 수락 하 고 이러한 명령을 퀀텀에 적용 하는 오류 수정 퀀텀 컴퓨터 (종종 *내결함성* 퀀텀 컴퓨터 라고도 함)입니다. 내에 저장 된 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="62959-123">For this reason, a natural target for Q# is an error-corrected quantum computer (often called a *fault-tolerant* quantum computer) that accepts a list of quantum instructions (called gates or gate operations) and applies those instructions to the quantum data stored within it.</span></span>  <span data-ttu-id="62959-124">퀀텀 알고리즘 또는 프로그램의 기능 수가 적으면 서 오류 수정이 반드시 필요한 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="62959-124">Note that if the number of qubits and gate operations in a quantum algorithm or program is small enough, error correction may not be absolutely necessary.</span></span>  <span data-ttu-id="62959-125">그러나이 경우에는 다양 한 기능을 제공 하는 것이 더 나을 수 있습니다. 따라서 소프트웨어 스택과 Q #을 무엇 하 여 오류 수정 사항을 효과적으로 처리 하 고 확장 가능 하 고 내결함성 있는 퀀텀 컴퓨팅을 사용 하도록 설계 합니다.</span><span class="sxs-lookup"><span data-stu-id="62959-125">However as the number of qubits and gate operations grow, it will more certainly be a requirement, thus we architect our software stack and Q# to aptly and efficiently handle error correction and enable scalable, fault-tolerant quantum computing.</span></span>

### <a name="error-correction"></a><span data-ttu-id="62959-126">오류 수정</span><span class="sxs-lookup"><span data-stu-id="62959-126">Error correction</span></span>
<span data-ttu-id="62959-127">오류를 수정 하려면 퀀텀 계산에 표시 되는 오류를 수정 하기 위해 퀀텀 컴퓨터와 함께 신속 하 고 안정적인 기존 컴퓨터를 실행 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="62959-127">Error correction requires a fast and reliable classical computer to be run in concert with the quantum computer to correct errors as they appear in the quantum computation.</span></span>  <span data-ttu-id="62959-128">실제로는 퀀텀 컴퓨터에서 자연스럽 게 누적 된 것 보다 빠르게 오류를 식별 하 고 수정 하기 위해 FPGAs (필드 프로그래밍 가능 게이트 배열) 또는 fast cryogenic 프로세서와 같은 구성 요소가 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62959-128">In practice, components such as field-programmable gate arrays (FPGAs) or fast cryogenic processors may be needed to identify and correct the errors faster than they naturally accumulate in the quantum computer.</span></span>  <span data-ttu-id="62959-129">결과적으로 퀀텀 컴퓨터는 다양 한 온도에 대해 작동 하는 여러 계산 장치로 구성 된 하이브리드 컴퓨터입니다.</span><span class="sxs-lookup"><span data-stu-id="62959-129">As a result, a quantum computer is a hybrid machine comprised of several different computational devices that operate over a wide range of temperatures.</span></span>  <span data-ttu-id="62959-130">이러한 이유로, 궁극적으로 퀀텀 구현을 구현 하는 데 필요한 여러 계층의 하드웨어 및 소프트웨어 (기존 및 퀀텀)가 있으므로 소프트웨어 스택의 렌즈를 통해 퀀텀 컴퓨터를 프로그래밍 하는 것에 대해 생각 하는 것이 훨씬 더 유용 합니다. 퀀텀 컴퓨터의 알고리즘입니다.</span><span class="sxs-lookup"><span data-stu-id="62959-130">For this reason, it is much more helpful to think about programming a quantum computer through the lens of a software stack, as there are many layers of hardware and software (classical and quantum) required to ultimately achieve the implementation of a quantum algorithm on a quantum computer.</span></span>

### <a name="quantum-conceptual-stack"></a><span data-ttu-id="62959-131">퀀텀 개념 스택</span><span class="sxs-lookup"><span data-stu-id="62959-131">Quantum conceptual stack</span></span>
<span data-ttu-id="62959-132">퀀텀 컴퓨팅 환경에서 8704143553785700723 팩터링의 기능 흐름을 보여 주는 개념 스택은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="62959-132">A conceptual stack that illustrates the functional flow of factoring 8704143553785700723 in a quantum computing environment is shown below:</span></span>

![소프트웨어 스택](~/media/concepts_stack.png)

### <a name="specification-and-algorithm"></a><span data-ttu-id="62959-134">사양 및 알고리즘</span><span class="sxs-lookup"><span data-stu-id="62959-134">Specification and algorithm</span></span>
<span data-ttu-id="62959-135">이러한 퀀텀 계산에 대 한 다양 한 프로그래밍 단계가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62959-135">There are several broad stages of programming such a quantum computation.</span></span>  <span data-ttu-id="62959-136">가장 까다로운 첫 번째 단계는 해결 하고자 하는 문제를 지정 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="62959-136">The first, and arguably most challenging phase, is specifying the problem that one wishes to solve.</span></span>  <span data-ttu-id="62959-137">이 경우 문제는 숫자 8704143553785700723을 두 소수의 곱으로 구분 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="62959-137">In this case, the problem is to factor the number 8704143553785700723  into a product of two prime numbers.</span></span>  <span data-ttu-id="62959-138">다음 단계에서는이 계산 문제를 해결 하기 위한 알고리즘을 디자인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="62959-138">The next step involves designing an algorithm for solving this computational problem.</span></span>  <span data-ttu-id="62959-139">이 경우 Shor의 유명한 퀀텀 팩터링 알고리즘을 사용 하 여 요소를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62959-139">In this case, Shor's famous quantum factoring algorithm can be used to find the factors.</span></span>  <span data-ttu-id="62959-140">이 알고리즘은 Q #으로 표현 된 다음 퀀텀 작업의 시퀀스는 이상적인 오류가 없는 퀀텀 컴퓨터에서 실행할 수 있는 출력입니다.</span><span class="sxs-lookup"><span data-stu-id="62959-140">This algorithm is expressed in Q# and then a sequence of quantum operations is output that could be run on an idealized error-free quantum computer.</span></span>  

### <a name="physical-gates"></a><span data-ttu-id="62959-141">물리적 게이트</span><span class="sxs-lookup"><span data-stu-id="62959-141">Physical gates</span></span>
<span data-ttu-id="62959-142">이 예제에서는 오류가 없는 퀀텀 컴퓨터를 제공 하는 것 처럼 특성을 사용 하지 않는 것으로 가정 합니다. 그러면 후속 단계에서 Q #에서 내보낸 작업을 가져와 실제 게이트에서 선택한 퀀텀 오류 수정 방법으로 지정 된 템플릿을 사용 하 여 변환 합니다. 기본 하드웨어를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62959-142">In this example, assume nature is not so kind as to provide an error-free quantum computer so the subsequent step takes the operations emitted by Q# and translates them using templates specified by the quantum error correction method chosen into physical gates that the basic hardware can execute.</span></span>  <span data-ttu-id="62959-143">이 프로세스에서는 이전 모델에 설명 된 모든 논리 요소를 물리적의 호스트로 대체 하는 것을 포함 하며,이를 통해 물리적 구성 요소에 대 한 로컬 오류를 방지할 수 있는 단일 요소 내에 정보를 저장 하 고 보호 하는 데 사용 됩니다. 이러한 오류를 검색 하 고 수정할 수 있을 정도로 충분 한 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="62959-143">This process involves replacing every logical qubit described in the previous model with a host of physical qubits that are used to store and protect the information within a single qubit in a redundant fashion that can resist local errors on the constituent physical qubits long enough for such errors to be detected and corrected.</span></span>  <span data-ttu-id="62959-144">Q # 코드에서 설명 하는 논리의 논리를 여러 물리적 기능으로 교체 해야 하는 것과 마찬가지로 출력에 설명 된 각 퀀텀 게이트는 물리적 기능을 수행 하는 실제 게이트의 시퀀스로 변환 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="62959-144">Just as the logical qubits described by the Q# code need to be replaced with many physical qubits, similarly each quantum gate described in the output needs to be translated into a sequence of physical gates that act upon the physical qubits.</span></span>  <span data-ttu-id="62959-145">이러한 이유로, Q #의 출력은 명확한 방식으로 하드웨어에서 코드를 실행 하는 데 필요한 퀀텀 컴퓨팅의 최종 목표와 더 많은 추상화 수준이 거의 필요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="62959-145">For this reason, the output of Q# is seldom the final target for quantum computing and further levels of abstraction are needed to execute the code on hardware in an oblivious fashion.</span></span>

### <a name="control-computer"></a><span data-ttu-id="62959-146">제어 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="62959-146">Control computer</span></span>
<span data-ttu-id="62959-147">그런 다음 실제 게이트 시퀀스가 퀀텀 컴퓨터와 직접 상호 작용 하는 제어 컴퓨터에 이러한 지침을 전송 하는 일반 컴퓨터에 로드 됩니다.</span><span class="sxs-lookup"><span data-stu-id="62959-147">The physical gate sequence is then loaded into an ordinary computer that sends these instructions down to a control computer that interfaces directly with the quantum computer.</span></span>  <span data-ttu-id="62959-148">소프트웨어 스택 내의이 계층은 일반적으로 [qcodes](http://qcodes.github.io/Qcodes/)와 같은 실험적 컨트롤 소프트웨어에서 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="62959-148">This layer within the software stack is often handled by experimental control software such as [QCoDeS](http://qcodes.github.io/Qcodes/).</span></span>

### <a name="interface-computer"></a><span data-ttu-id="62959-149">인터페이스 컴퓨터</span><span class="sxs-lookup"><span data-stu-id="62959-149">Interface computer</span></span>
<span data-ttu-id="62959-150">이 프로세스의 마지막 단계에서는 먼저 빠른 제어 컴퓨터에 필요한 대로 게이트를 스트리밍하는 인터페이스 컴퓨터를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="62959-150">The final step in this process involves the interface computer first streaming the gates as needed to a fast control computer.</span></span> <span data-ttu-id="62959-151">그런 다음 빠른 제어 컴퓨터는 필요한 전압 (일반적으로 펄스 라고 함)을 적용 하 여 필요한 게이트 비트를 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="62959-151">Then the fast control computer applies the voltages needed (commonly called pulses) to implement the required gates on qubits.</span></span> <span data-ttu-id="62959-152">이 작업은 퀀텀 오류 수정을 통해 관찰 되는 오류를 수정 하는 동안 수행 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="62959-152">This has to be done while correcting any errors that are observed through quantum error correction.</span></span>  <span data-ttu-id="62959-153">Cryogenic FPGAs 또는 기타 exotic 하드웨어는 퀀텀 컴퓨터에 오류가 표시 되는 속도에 따라 엄격한 시간 요구 사항 내에서 이러한 단계를 수행 하는 데 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62959-153">Cryogenic FPGAs or other exotic hardware may be needed to perform these steps within the stringent time requirements imposed by the rate at which errors appear in the quantum computer.</span></span>  <span data-ttu-id="62959-154">이 수준의 대상 언어는 종종 [VHDL](https://en.wikipedia.org/wiki/VHDL)이며,이는 스택의 위쪽 끝에 사용 되는 것으로 간주 하 여 퀀텀 알고리즘의 설명을 구문 분석 하는 고유한 방법이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="62959-154">The target language on this level is often [VHDL](https://en.wikipedia.org/wiki/VHDL), which requires a distinct way of thinking from that which is used at the top end of the stack to parse a description of a quantum algorithm.</span></span>

### <a name="the-q-quantum-programming-language"></a><span data-ttu-id="62959-155">Q # 퀀텀 프로그래밍 언어</span><span class="sxs-lookup"><span data-stu-id="62959-155">The Q# quantum programming language</span></span>
<span data-ttu-id="62959-156">Q #의 목표는 개발자가 사용자와 퀀텀 장치를 사용 하는 중간 수준의 소프트웨어를 사용 하 여 다양 한 퀀텀 컴퓨팅 플랫폼 및 인터페이스를 대상으로 하는 코드를 작성할 수 있도록 하는 간단한 언어를 제공 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="62959-156">The aim of Q# is to provide a simple language that allows developers to write code that targets a wealth of quantum computing platforms and interface with the intervening layers of software that stand between the user and the quantum device.</span></span>  <span data-ttu-id="62959-157">이 언어는 소프트웨어 스택의 개념을 수용 하 고 기본 퀀텀 컴퓨터의 많은 세부 정보를 추상화 하는 동시에,와 C#같은 언어를 통해 노출 되는 스택의 다른 수준을 허용 하 여이를 용이 하 게 합니다. Q # 코드에서 기본 작업으로의 번역</span><span class="sxs-lookup"><span data-stu-id="62959-157">The language facilitates this by embracing the notion of a software stack and abstracting many of the details of the underlying quantum computer while allowing other levels of the stack, exposed through a language such as C#, to perform the necessary translations from Q# code to fundamental operations.</span></span>  <span data-ttu-id="62959-158">이를 통해 개발자는 알고리즘 디자인 및 문제 해결에 가장 적합 한 작업에 집중할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62959-158">This allows the developer to focus on what they do best: designing algorithms and solving problems.</span></span>
