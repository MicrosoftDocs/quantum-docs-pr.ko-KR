---
<span data-ttu-id="608e0-101">제목: 여러 기능에 대 한 설명: 둘 이상의 이상에서 작업을 수행 하는 방법을 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-101">title: Multiple qubits description: Learn how to perform operations on two or more qubits.</span></span>
<span data-ttu-id="608e0-102">만든이: QuantumWriter uid:: nawiebe@microsoft.com 12/11/2017: 밀리초. 토픽: 문서 번호-다음이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-102">author: QuantumWriter uid: microsoft.quantum.concepts.multiple-qubits ms.author: nawiebe@microsoft.com ms.date: 12/11/2017 ms.topic: article no-loc:</span></span>
- <span data-ttu-id="608e0-103">"Q#"</span><span class="sxs-lookup"><span data-stu-id="608e0-103">"Q#"</span></span>
- <span data-ttu-id="608e0-104">"$$v"</span><span class="sxs-lookup"><span data-stu-id="608e0-104">"$$v"</span></span>
- <span data-ttu-id="608e0-105">"$$"</span><span class="sxs-lookup"><span data-stu-id="608e0-105">"$$"</span></span>
- <span data-ttu-id="608e0-106">"$$"</span><span class="sxs-lookup"><span data-stu-id="608e0-106">"$$"</span></span>
- <span data-ttu-id="608e0-107">"$"</span><span class="sxs-lookup"><span data-stu-id="608e0-107">"$"</span></span>
- <span data-ttu-id="608e0-108">"$"</span><span class="sxs-lookup"><span data-stu-id="608e0-108">"$"</span></span>
- <span data-ttu-id="608e0-109">"$"</span><span class="sxs-lookup"><span data-stu-id="608e0-109">"$"</span></span>
- <span data-ttu-id="608e0-110">"$$"</span><span class="sxs-lookup"><span data-stu-id="608e0-110">"$$"</span></span>
- <span data-ttu-id="608e0-111">"\cdots"</span><span class="sxs-lookup"><span data-stu-id="608e0-111">"\cdots"</span></span>
- <span data-ttu-id="608e0-112">"bmatrix"</span><span class="sxs-lookup"><span data-stu-id="608e0-112">"bmatrix"</span></span>
- <span data-ttu-id="608e0-113">"\ddots"</span><span class="sxs-lookup"><span data-stu-id="608e0-113">"\ddots"</span></span>
- <span data-ttu-id="608e0-114">"\equiv"</span><span class="sxs-lookup"><span data-stu-id="608e0-114">"\equiv"</span></span>
- <span data-ttu-id="608e0-115">"\sum"</span><span class="sxs-lookup"><span data-stu-id="608e0-115">"\sum"</span></span>
- <span data-ttu-id="608e0-116">"\begin"</span><span class="sxs-lookup"><span data-stu-id="608e0-116">"\begin"</span></span>
- <span data-ttu-id="608e0-117">"\end"</span><span class="sxs-lookup"><span data-stu-id="608e0-117">"\end"</span></span>
- <span data-ttu-id="608e0-118">"\sqrt"</span><span class="sxs-lookup"><span data-stu-id="608e0-118">"\sqrt"</span></span>
- <span data-ttu-id="608e0-119">"\otimes"</span><span class="sxs-lookup"><span data-stu-id="608e0-119">"\otimes"</span></span>
- <span data-ttu-id="608e0-120">"{"</span><span class="sxs-lookup"><span data-stu-id="608e0-120">"{"</span></span>
- <span data-ttu-id="608e0-121">"}"</span><span class="sxs-lookup"><span data-stu-id="608e0-121">"}"</span></span>
- <span data-ttu-id="608e0-122">"\text"</span><span class="sxs-lookup"><span data-stu-id="608e0-122">"\text"</span></span>
- <span data-ttu-id="608e0-123">"\phi"</span><span class="sxs-lookup"><span data-stu-id="608e0-123">"\phi"</span></span>
- <span data-ttu-id="608e0-124">"\kappa"</span><span class="sxs-lookup"><span data-stu-id="608e0-124">"\kappa"</span></span>
- <span data-ttu-id="608e0-125">"\psi"</span><span class="sxs-lookup"><span data-stu-id="608e0-125">"\psi"</span></span>
- <span data-ttu-id="608e0-126">"\alpha"</span><span class="sxs-lookup"><span data-stu-id="608e0-126">"\alpha"</span></span>
- <span data-ttu-id="608e0-127">"\beta"</span><span class="sxs-lookup"><span data-stu-id="608e0-127">"\beta"</span></span>
- <span data-ttu-id="608e0-128">"\gamma"</span><span class="sxs-lookup"><span data-stu-id="608e0-128">"\gamma"</span></span>
- <span data-ttu-id="608e0-129">"\delta"</span><span class="sxs-lookup"><span data-stu-id="608e0-129">"\delta"</span></span>
- <span data-ttu-id="608e0-130">"\omega"</span><span class="sxs-lookup"><span data-stu-id="608e0-130">"\omega"</span></span>
- <span data-ttu-id="608e0-131">"\bra"</span><span class="sxs-lookup"><span data-stu-id="608e0-131">"\bra"</span></span>
- <span data-ttu-id="608e0-132">"\ket"</span><span class="sxs-lookup"><span data-stu-id="608e0-132">"\ket"</span></span>
- <span data-ttu-id="608e0-133">"\boldone"</span><span class="sxs-lookup"><span data-stu-id="608e0-133">"\boldone"</span></span>
- <span data-ttu-id="608e0-134">"\\\\"</span><span class="sxs-lookup"><span data-stu-id="608e0-134">"\\\\"</span></span>
- <span data-ttu-id="608e0-135">"\\"</span><span class="sxs-lookup"><span data-stu-id="608e0-135">"\\"</span></span>
- <span data-ttu-id="608e0-136">"="</span><span class="sxs-lookup"><span data-stu-id="608e0-136">"="</span></span>
- <span data-ttu-id="608e0-137">"\frac"</span><span class="sxs-lookup"><span data-stu-id="608e0-137">"\frac"</span></span>
- <span data-ttu-id="608e0-138">"\text"</span><span class="sxs-lookup"><span data-stu-id="608e0-138">"\text"</span></span>
- <span data-ttu-id="608e0-139">"\mapsto"</span><span class="sxs-lookup"><span data-stu-id="608e0-139">"\mapsto"</span></span>
- <span data-ttu-id="608e0-140">"\dagger"</span><span class="sxs-lookup"><span data-stu-id="608e0-140">"\dagger"</span></span>
- <span data-ttu-id="608e0-141">"\to"</span><span class="sxs-lookup"><span data-stu-id="608e0-141">"\to"</span></span>
- <span data-ttu-id="608e0-142">"\begin{cases}"</span><span class="sxs-lookup"><span data-stu-id="608e0-142">"\begin{cases}"</span></span>
- <span data-ttu-id="608e0-143">"\end{cases}"</span><span class="sxs-lookup"><span data-stu-id="608e0-143">"\end{cases}"</span></span>
- <span data-ttu-id="608e0-144">"\operatorname"</span><span class="sxs-lookup"><span data-stu-id="608e0-144">"\operatorname"</span></span>
- <span data-ttu-id="608e0-145">"\braket"</span><span class="sxs-lookup"><span data-stu-id="608e0-145">"\braket"</span></span>
- <span data-ttu-id="608e0-146">"\id"</span><span class="sxs-lookup"><span data-stu-id="608e0-146">"\id"</span></span>
- <span data-ttu-id="608e0-147">"\expect"</span><span class="sxs-lookup"><span data-stu-id="608e0-147">"\expect"</span></span>
- <span data-ttu-id="608e0-148">"\defeq"</span><span class="sxs-lookup"><span data-stu-id="608e0-148">"\defeq"</span></span>
- <span data-ttu-id="608e0-149">"\variance"</span><span class="sxs-lookup"><span data-stu-id="608e0-149">"\variance"</span></span>
- <span data-ttu-id="608e0-150">"\dd"</span><span class="sxs-lookup"><span data-stu-id="608e0-150">"\dd"</span></span>
- <span data-ttu-id="608e0-151">"&"</span><span class="sxs-lookup"><span data-stu-id="608e0-151">"&"</span></span>
- <span data-ttu-id="608e0-152">"\begin{align}"</span><span class="sxs-lookup"><span data-stu-id="608e0-152">"\begin{align}"</span></span>
- <span data-ttu-id="608e0-153">"\end{align}"</span><span class="sxs-lookup"><span data-stu-id="608e0-153">"\end{align}"</span></span>
- <span data-ttu-id="608e0-154">"\Lambda"</span><span class="sxs-lookup"><span data-stu-id="608e0-154">"\Lambda"</span></span>
- <span data-ttu-id="608e0-155">"\lambda"</span><span class="sxs-lookup"><span data-stu-id="608e0-155">"\lambda"</span></span>
- <span data-ttu-id="608e0-156">"\Omega"</span><span class="sxs-lookup"><span data-stu-id="608e0-156">"\Omega"</span></span>
- <span data-ttu-id="608e0-157">"\mathrm"</span><span class="sxs-lookup"><span data-stu-id="608e0-157">"\mathrm"</span></span>
- <span data-ttu-id="608e0-158">"\left"</span><span class="sxs-lookup"><span data-stu-id="608e0-158">"\left"</span></span>
- <span data-ttu-id="608e0-159">"\right"</span><span class="sxs-lookup"><span data-stu-id="608e0-159">"\right"</span></span>
- <span data-ttu-id="608e0-160">"\qquad"</span><span class="sxs-lookup"><span data-stu-id="608e0-160">"\qquad"</span></span>
- <span data-ttu-id="608e0-161">"\times"</span><span class="sxs-lookup"><span data-stu-id="608e0-161">"\times"</span></span>
- <span data-ttu-id="608e0-162">"\big"</span><span class="sxs-lookup"><span data-stu-id="608e0-162">"\big"</span></span>
- <span data-ttu-id="608e0-163">"\langle"</span><span class="sxs-lookup"><span data-stu-id="608e0-163">"\langle"</span></span>
- <span data-ttu-id="608e0-164">"\rangle"</span><span class="sxs-lookup"><span data-stu-id="608e0-164">"\rangle"</span></span>
- <span data-ttu-id="608e0-165">"\bigg"</span><span class="sxs-lookup"><span data-stu-id="608e0-165">"\bigg"</span></span>
- <span data-ttu-id="608e0-166">"\Big"</span><span class="sxs-lookup"><span data-stu-id="608e0-166">"\Big"</span></span>
- <span data-ttu-id="608e0-167">"|"</span><span class="sxs-lookup"><span data-stu-id="608e0-167">"|"</span></span>
- <span data-ttu-id="608e0-168">"\mathbb"</span><span class="sxs-lookup"><span data-stu-id="608e0-168">"\mathbb"</span></span>
- <span data-ttu-id="608e0-169">"\vec"</span><span class="sxs-lookup"><span data-stu-id="608e0-169">"\vec"</span></span>
- <span data-ttu-id="608e0-170">"\in"</span><span class="sxs-lookup"><span data-stu-id="608e0-170">"\in"</span></span>
- <span data-ttu-id="608e0-171">"\texttt"</span><span class="sxs-lookup"><span data-stu-id="608e0-171">"\texttt"</span></span>
- <span data-ttu-id="608e0-172">"\ne"</span><span class="sxs-lookup"><span data-stu-id="608e0-172">"\ne"</span></span>
- <span data-ttu-id="608e0-173">"<"</span><span class="sxs-lookup"><span data-stu-id="608e0-173">"<"</span></span>
- <span data-ttu-id="608e0-174">">"</span><span class="sxs-lookup"><span data-stu-id="608e0-174">">"</span></span>
- <span data-ttu-id="608e0-175">"\leq"</span><span class="sxs-lookup"><span data-stu-id="608e0-175">"\leq"</span></span>
- <span data-ttu-id="608e0-176">"\geq"</span><span class="sxs-lookup"><span data-stu-id="608e0-176">"\geq"</span></span>
- <span data-ttu-id="608e0-177">"~~"</span><span class="sxs-lookup"><span data-stu-id="608e0-177">"~~"</span></span>
- <span data-ttu-id="608e0-178">"~"</span><span class="sxs-lookup"><span data-stu-id="608e0-178">"~"</span></span>
- <span data-ttu-id="608e0-179">"\begin{bmatrix}"</span><span class="sxs-lookup"><span data-stu-id="608e0-179">"\begin{bmatrix}"</span></span>
- <span data-ttu-id="608e0-180">"\end{bmatrix}"</span><span class="sxs-lookup"><span data-stu-id="608e0-180">"\end{bmatrix}"</span></span>
- <span data-ttu-id="608e0-181">"\_"</span><span class="sxs-lookup"><span data-stu-id="608e0-181">"\_"</span></span>

---

# <a name="multiple-qubits"></a><span data-ttu-id="608e0-182">여러 비트</span><span class="sxs-lookup"><span data-stu-id="608e0-182">Multiple Qubits</span></span>

<span data-ttu-id="608e0-183">단일 기능 비트 게이트는 지정 된 시간에 둘 이상의 상태에 있을 수 있는 기능과 같은 몇 가지 카운터 직관적인 기능을 보유 하 고 있지만, 퀀텀 컴퓨터에 있는 모든 것이 단일 기능 비트 게이트가 었으 면 계산기로만 고전 고성능 컴퓨터을 dwarfed 계산 능력을 갖춘 장치를 갖게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-183">While single-qubit gates possess some counter-intuitive features, such as the ability to be in more than one state at a given time, if all we had in a quantum computer were single-qubit gates then we would have a device with computational power that would be dwarfed by even a calculator let alone a classical supercomputer.</span></span>
<span data-ttu-id="608e0-184">퀀텀 계산의 진정한 힘은 성능 수가 증가 하는 것 처럼 분명 하 게 드러납니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-184">The true power of quantum computing only becomes evident as we increase the number of qubits.</span></span>
<span data-ttu-id="608e0-185">이는 일부 경우에는 퀀텀 상태 벡터의 벡터 공간 차원이 지 수의 수를 사용 하 여 급격 하 게 증가 하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-185">This power arises, in part, because the dimension of the vector space of quantum state vectors grows exponentially with the number of qubits.</span></span>
<span data-ttu-id="608e0-186">즉, 단일 기능을 모델링 하는 것이 일반적으로 수 있지만, 50-슈퍼 컴퓨터 퀀텀 계산을 시뮬레이션 하는 것은 기존의 제한을 거의 푸시하는 것을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-186">This means that while a single qubit can be trivially modeled, simulating a fifty-qubit quantum computation would arguably push the limits of existing supercomputers.</span></span>
<span data-ttu-id="608e0-187">하나 이상의 추가 비트를 기준으로 계산 크기를 늘리면 상태를 저장 하는 데 필요한 메모리가 *두 배가* 되며 약 *두* 배가 계산 시간이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-187">Increasing the size of the computation by only one additional qubit *doubles* the memory required to store the state and roughly *doubles* the computational time.</span></span>
<span data-ttu-id="608e0-188">계산 능력의 급속 한 배가 되는 이유는 상대적으로 적은 수의 초과할를 가진 퀀텀 컴퓨터가 일부 계산 작업에 대해 미래의 슈퍼 컴퓨터 가장 강력한 기능을 사용할 수 있는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-188">This rapid doubling of computational power is why a quantum computer with a relatively small number of qubits can far surpass the most powerful supercomputers of today, tomorrow and beyond for some computational tasks.</span></span>

<span data-ttu-id="608e0-189">퀀텀 상태 벡터에 대해 지 수 증가가 있는 이유는 무엇 인가요?</span><span class="sxs-lookup"><span data-stu-id="608e0-189">Why do we have exponential growth for quantum state vectors?</span></span>  <span data-ttu-id="608e0-190">이 섹션의 목표는 단일가 나 비트 상태에서 다 수의 비트 상태를 빌드하는 데 사용 되는 규칙을 검토 하는 것이 고, 전 세계의 뛰어난 비트 퀀텀 컴퓨터를 형성 하기 위해 게이트 집합에 포함 해야 하는 게이트 작업에 대해 설명 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-190">Our goal in this section is to review the rules used to build multi-qubit states out of single-qubit states as well as discuss the gate operations that we need to include in our gate set to form a universal many-qubit quantum computer.</span></span>
<span data-ttu-id="608e0-191">이러한 도구는 일반적으로 코드에 사용 되는 게이트 집합을 이해 하는 데 필요 Q# 하며, 되거나 얽 히 또는 간섭 같은 퀀텀 효과가 기존 컴퓨팅 보다 더 강력한 성능을 intuition 수 있는 이유에 대 한 정보를 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-191">These tools are absolutely necessary to understand the gate sets that are commonly used in Q# code and also to gain intuition about why quantum effects such as entanglement or interference render quantum computing more powerful than classical computing.</span></span>

## <a name="representing-two-qubits"></a><span data-ttu-id="608e0-192">두 개의 비트를 나타내는</span><span class="sxs-lookup"><span data-stu-id="608e0-192">Representing Two Qubits</span></span>
<span data-ttu-id="608e0-193">1 ~ 2의 비트 상태 간의 주요 차이점은 두 번째 비트 상태는 2 차원이 아닌 4 차원 이라는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-193">The main difference between one- and two-qubit states is that two-qubit states are four dimensional rather than two dimensional.</span></span>
<span data-ttu-id="608e0-194">이는 두 번째 비트 상태에 대 한 계산 기준이 한 수준 비트 상태의 텐서 products로 구성 되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-194">This is because the computational basis for two-qubit states is formed by the tensor products of one-qubit states.</span></span>  <span data-ttu-id="608e0-195">예를 들어\begin{align}</span><span class="sxs-lookup"><span data-stu-id="608e0-195">For example, we have \begin{align}</span></span>
<span data-ttu-id="608e0-196">00 \equiv \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} \otimes \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} & = \begin{bmatrix} 1 \\\\ 0 0 0 \\\\ \\\\ \end{bmatrix} , \qquad 01 \equiv \begin{bmatrix} 1 \\\\ 0 0 \end{bmatrix} \otimes \begin{bmatrix} \\\\ 1 \end{bmatrix} = \begin{bmatrix} 0 \\\\ 1 \\\\ \\\\ \end{bmatrix} 0 0,\\\\</span><span class="sxs-lookup"><span data-stu-id="608e0-196">00 \equiv \begin{bmatrix}1 \\\\ 0 \end{bmatrix}\otimes \begin{bmatrix}1 \\\\ 0 \end{bmatrix} &= \begin{bmatrix}1 \\\\ 0\\\\ 0\\\\ 0 \end{bmatrix},\qquad 01 \equiv \begin{bmatrix}1 \\\\ 0 \end{bmatrix}\otimes \begin{bmatrix}0 \\\\ 1 \end{bmatrix} = \begin{bmatrix}0 \\\\ 1\\\\ 0\\\\ 0 \end{bmatrix},\\\\</span></span>
<span data-ttu-id="608e0-197">10 \equiv \begin{bmatrix} 0 \\\\ 1 1 0 0 0 0 \end{bmatrix} \otimes \begin{bmatrix} \\\\ \end{bmatrix} & = \begin{bmatrix} \\\\ \\\\ 1 \\\\ \end{bmatrix} , \qquad 11 \equiv \begin{bmatrix} 0 \\\\ 1 \end{bmatrix} \otimes \begin{bmatrix} 0 \\\\ 1 \end{bmatrix} = \begin{bmatrix} 0 \\\\ \\\\ \\\\ \end{bmatrix} 0 0 1.</span><span class="sxs-lookup"><span data-stu-id="608e0-197">10 \equiv \begin{bmatrix}0 \\\\ 1 \end{bmatrix}\otimes \begin{bmatrix}1 \\\\ 0 \end{bmatrix} &= \begin{bmatrix}0 \\\\ 0\\\\ 1\\\\ 0 \end{bmatrix},\qquad 11 \equiv \begin{bmatrix}0 \\\\ 1 \end{bmatrix}\otimes \begin{bmatrix}0 \\\\ 1 \end{bmatrix} = \begin{bmatrix}0 \\\\ 0\\\\ 0\\\\ 1 \end{bmatrix}.</span></span>
\end{align}

<span data-ttu-id="608e0-198">$이 구성을 사용 하 여 보다 일반적으로 n 비트의 퀀텀 상태를 $ 차원 2 ^ n의 단위 벡터로 표시 한다는 것을 쉽게 확인할 수 $ $ 있습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-198">It is easy to see that more generally the quantum state of $n$ qubits is represented by a unit vector of dimension $2^n$ using this construction.</span></span>  <span data-ttu-id="608e0-199">벡터입니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-199">The vector</span></span>

$$
<span data-ttu-id="608e0-200">\begin{bmatrix}\alpha _ { 00 } 01 \\\\ 10 \alpha   _ { } \\\\ \alpha _ { 11 } \\\\ \alpha   _ { }  \end{bmatrix}</span><span class="sxs-lookup"><span data-stu-id="608e0-200">\begin{bmatrix} \alpha_{00} \\\\  \alpha_{01} \\\\  \alpha_{10} \\\\  \alpha_{11} \end{bmatrix}</span></span>
$$

<span data-ttu-id="608e0-201">$ | \alpha _ { 00 } | ^ 2 | + \alpha _ { 01 } | ^ 2 + | \alpha _ { 10 } | ^ 2 | + \alpha _ { 11 } | ^ 2 = 1 $ 인 경우 두 가지 비트의 퀀텀 상태를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-201">represents a quantum state on two qubits if $|\alpha_{00}|^2+|\alpha_{01}|^2+|\alpha_{10}|^2+|\alpha_{11}|^2=1$.</span></span> <span data-ttu-id="608e0-202">단일 기능을 사용 하는 것과 마찬가지로, 여러 기능에 대 한 퀀텀 상태 벡터는 시스템의 동작을 설명 하는 데 필요한 모든 정보를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-202">Just as with single qubits, the quantum state vector of multiple qubits holds all the information needed to describe the system's behavior.</span></span>

<span data-ttu-id="608e0-203">상태에서 두 개의 별도 비트가 지정 된 경우, 상태에서 두 $ \begin{bmatrix} \alpha \\\\ \beta \end{bmatrix} $ 번째 고 비트는 해당 하는 $ \begin{bmatrix} \gamma \\\\ \delta \end{bmatrix} $ 두 번째 비트 상태입니다.    </span><span class="sxs-lookup"><span data-stu-id="608e0-203">If we are given two separate qubits, one in the state $\begin{bmatrix} \alpha \\\\  \beta \end{bmatrix}$ and a second qubit in the state  $\begin{bmatrix} \gamma \\\\  \delta \end{bmatrix}$, the corresponding two-qubit state is</span></span>

$$
<span data-ttu-id="608e0-204">\begin{bmatrix} \alpha \\\\  \beta \end{bmatrix} \otimes \begin{bmatrix} \gamma \\\\  \delta \end{bmatrix}</span><span class="sxs-lookup"><span data-stu-id="608e0-204">\begin{bmatrix} \alpha \\\\  \beta \end{bmatrix} \otimes \begin{bmatrix} \gamma \\\\  \delta \end{bmatrix}</span></span> 
<span data-ttu-id="608e0-205">=\begin{bmatrix} \alpha \begin{bmatrix} \gamma \\\\  \delta \end{bmatrix} \\\\ \beta \begin{bmatrix}\gamma \\\\  \delta \end{bmatrix} \end{bmatrix}</span><span class="sxs-lookup"><span data-stu-id="608e0-205">=\begin{bmatrix} \alpha \begin{bmatrix} \gamma \\\\  \delta \end{bmatrix} \\\\ \beta \begin{bmatrix}\gamma \\\\  \delta \end{bmatrix} \end{bmatrix}</span></span>
<span data-ttu-id="608e0-206">= \begin{bmatrix} \alpha\gamma \\\\  \alpha\delta \\\\  \beta\gamma \\\\  \beta\delta \end{bmatrix}, $$</span><span class="sxs-lookup"><span data-stu-id="608e0-206">= \begin{bmatrix} \alpha\gamma \\\\  \alpha\delta \\\\  \beta\gamma \\\\  \beta\delta \end{bmatrix}, $$</span></span>

<span data-ttu-id="608e0-207">여기서 작업을 $ \otimes $ 벡터의 텐서 product (또는 Kronecker product) 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-207">where the operation $\otimes$ is called the tensor product (or Kronecker product) of vectors.</span></span> <span data-ttu-id="608e0-208">항상 두 개의 단일 수준 비트 상태를 텐서 제품을 사용 하 여 두 개의 단일 비트 상태를 텐서 곱으로 작성할 수 있는 것은 아니지만 두 개의 단일 비트 양자 상태를 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-208">Note that while we can always take the tensor product of two single-qubit states to form a two-qubit state, not all two-qubit quantum states can be written as the tensor product of two single-qubit states.</span></span>
<span data-ttu-id="608e0-209">예를 들어 상태는 없으며 $ \psi = \begin{bmatrix} \alpha \\\\ \beta \end{bmatrix} $ $ \phi = \begin{bmatrix} \gamma \\\\ \delta \end{bmatrix} $ 해당 텐서 제품이 상태입니다.    </span><span class="sxs-lookup"><span data-stu-id="608e0-209">For example, there are no states $\psi=\begin{bmatrix} \alpha \\\\  \beta \end{bmatrix}$ and $\phi=\begin{bmatrix} \gamma \\\\  \delta \end{bmatrix}$ such that their tensor product is the state</span></span> 

<span data-ttu-id="608e0-210">$$\psi\otimes\phi = \begin{bmatrix} 1/ \sqrt { 2 } \\\\ 0 \\\\ 0 \\\\ 1/ \sqrt { 2 } \end{bmatrix} .$$</span><span class="sxs-lookup"><span data-stu-id="608e0-210">$$\psi\otimes \phi = \begin{bmatrix} 1/\sqrt{2} \\\\  0 \\\\  0 \\\\  1/\sqrt{2} \end{bmatrix}.$$</span></span> 

<span data-ttu-id="608e0-211">단일 수준 비트 상태의 텐서 곱으로 작성할 수 없는 두 번째 비트 상태를 "entangled 상태" 라고 합니다. 두 개의이 두 비트는 [*entangled*](https://en.wikipedia.org/wiki/Quantum_entanglement)이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-211">Such a two-qubit state, which cannot be written as the tensor product of single-qubit states, is called an "entangled state"; the two qubits are said to be [*entangled*](https://en.wikipedia.org/wiki/Quantum_entanglement).</span></span>  <span data-ttu-id="608e0-212">느슨하게 말하면 퀀텀 상태를 단일 텐서의 곱으로 간주할 수 없기 때문에 상태가 보유 한 정보는 개별적 비트 중 하나로 제한 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-212">Loosely speaking, because the quantum state cannot be thought of as a tensor product of single qubit states, the information that the state holds is not confined to either of the qubits individually.</span></span>  <span data-ttu-id="608e0-213">대신이 정보는 두 상태 간의 상관 관계에서 로컬로 저장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-213">Rather, the information is stored non-locally in the correlations between the two states.</span></span>  <span data-ttu-id="608e0-214">이러한 정보가 아닌 이러한 정보는 기존 컴퓨팅에 대 한 퀀텀 컴퓨팅의 주요 기능 중 하나 이며, [퀀텀 teleportation](https://github.com/microsoft/Quantum/tree/master/samples/getting-started/teleportation) 및 [퀀텀 오류 수정](xref:microsoft.quantum.libraries.error-correction)사항을 비롯 한 다양 한 퀀텀 프로토콜에 필수적입니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-214">This non-locality of information is one of the major distinguishing features of quantum computing over classical computing and is essential for a number of quantum protocols including [quantum teleportation](https://github.com/microsoft/Quantum/tree/master/samples/getting-started/teleportation) and [quantum error correction](xref:microsoft.quantum.libraries.error-correction).</span></span>

## <a name="measuring-two-qubit-states"></a><span data-ttu-id="608e0-215">두 수준 비트 상태 측정</span><span class="sxs-lookup"><span data-stu-id="608e0-215">Measuring Two-Qubit States</span></span> ##
<span data-ttu-id="608e0-216">두 번째 비트 상태 측정은 단일 수준 비트 측정과 매우 유사 합니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-216">Measuring two-qubit states is very similar to single-qubit measurements.</span></span> <span data-ttu-id="608e0-217">상태 측정</span><span class="sxs-lookup"><span data-stu-id="608e0-217">Measuring the state</span></span>

$$
    \begin{bmatrix}
        <span data-ttu-id="608e0-218">\alpha_ { 00 } 01 \\\\ \alpha _ { }\\\\</span><span class="sxs-lookup"><span data-stu-id="608e0-218">\alpha_{00} \\\\ \alpha_{01} \\\\</span></span> 
        <span data-ttu-id="608e0-219">\alpha_ { 10 } 11 \\\\ \alpha _ {}</span><span class="sxs-lookup"><span data-stu-id="608e0-219">\alpha_{10} \\\\ \alpha_{11}</span></span>
    \end{bmatrix}
$$

<span data-ttu-id="608e0-220">확률은 00 $ $ $ | \alpha _ { } | ^ 2 $ , $ 01 $ 은 확률 01 ^ 2, 10은 확률 10 ^ 2, 10은 확률 11 ^ 2 인 00을 산출 합니다. $ | \alpha _ { } | $ $ $ $ | \alpha _ { } | $ $ $ $ | \alpha _ { } | $</span><span class="sxs-lookup"><span data-stu-id="608e0-220">yields $00$ with probability $|\alpha_{00}|^2$, $01$ with probability $|\alpha_{01}|^2$, $10$ with probability $|\alpha_{10}|^2$, and $11$ with probability $|\alpha_{11}|^2$.</span></span> <span data-ttu-id="608e0-221">변수 $ \alpha _ { 00 } , \alpha _ { 01 } , \alpha _ { 10 } $ 및 $ 11은이 연결을 명확 하 게 하기 위해 의도적으로 이름이 지정 되었습니다 \alpha _ { } $ .</span><span class="sxs-lookup"><span data-stu-id="608e0-221">The variables $\alpha_{00}, \alpha_{01}, \alpha_{10},$ and $\alpha_{11}$ were deliberately named to make this connection clear.</span></span> <span data-ttu-id="608e0-222">측정 후 결과가 00 인 경우 두 번째 $ $ 비트 시스템의 퀀텀 상태는 축소 되어 이제</span><span class="sxs-lookup"><span data-stu-id="608e0-222">After the measurement, if the outcome is $00$ then the quantum state of the two-qubit system has collapsed and is now</span></span>

$$
    <span data-ttu-id="608e0-223">00\equiv</span><span class="sxs-lookup"><span data-stu-id="608e0-223">00 \equiv</span></span>
    \begin{bmatrix}
        <span data-ttu-id="608e0-224">1(sp1)\\\\</span><span class="sxs-lookup"><span data-stu-id="608e0-224">1 \\\\</span></span> 
        <span data-ttu-id="608e0-225">0 \\\\</span><span class="sxs-lookup"><span data-stu-id="608e0-225">0 \\\\</span></span> 
        <span data-ttu-id="608e0-226">0 \\\\</span><span class="sxs-lookup"><span data-stu-id="608e0-226">0 \\\\</span></span> 
        <span data-ttu-id="608e0-227">0 \end{bmatrix} .</span><span class="sxs-lookup"><span data-stu-id="608e0-227">0 \end{bmatrix}.</span></span>
$$

<span data-ttu-id="608e0-228">또한 두 번째 비트율의 퀀텀 상태를 한 번만 측정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-228">It is also possible to measure just one qubit of a two-qubit quantum state.</span></span> <span data-ttu-id="608e0-229">원하는 비트 중 하나만 측정 하는 경우 전체 상태가 계산 기준 상태로 축소 되지 않고 하나의 하위 시스템 으로만 축소 되므로 측정의 영향은 약간 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-229">In cases where you measure only one of the qubits, the impact of measurement is subtly different because the entire state is not collapsed to a computational basis state, rather it is collapsed to only one sub-system.</span></span>  <span data-ttu-id="608e0-230">즉, 이러한 경우에는 하나의 요소를 측정 하는 경우에만 하위 시스템 중 하나만 축소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-230">In other words, in such cases measuring only one qubit only collapses one of the subsystems but not all of them.</span></span>  

<span data-ttu-id="608e0-231">이를 확인 하려면 $ $ 처음에 "0" 상태로 설정 된 두 개의 Hadamard transform H를 적용 하 여 형성 된 다음 상태의 첫 번째 비트를 측정 합니다.$$</span><span class="sxs-lookup"><span data-stu-id="608e0-231">To see this consider measuring the first qubit of the following state, which is formed by applying the Hadamard transform $H$ on two qubits initially set to the "0" state: $$</span></span>
<span data-ttu-id="608e0-232">H ^ { \otimes 2 } \left ( \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} \otimes \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} \right ) = \frac { 1 2 1 1 1 1 } { } \begin{bmatrix} & & & \\\\ & -1 1 & & -1 \\\\ 1 & & - & \\\\ & & & \end{bmatrix} \begin{bmatrix} \\\\ \\\\ \\\\ \end{bmatrix} = \frac { } { } \begin{bmatrix} \\\\ \\\\ \\\\ \end{bmatrix} \mapsto \begin{cases} \text { } = & \frac { } { \sqrt { } } \begin{bmatrix} \\\\ \\\\ \\\\ \end{bmatrix} \\\\ \text { } = & \frac { } { \sqrt { } } \begin{bmatrix} \\\\ \\\\ \\\\ \end{bmatrix} \\\\ \end{cases} 1-1 1-1-1-1-1-1-1-1-1-1-1 1 1 1 0 0 0 1 2 1 1 1  </span><span class="sxs-lookup"><span data-stu-id="608e0-232">H^{\otimes 2} \left( \begin{bmatrix}1 \\\\ 0 \end{bmatrix}\otimes \begin{bmatrix}1 \\\\ 0 \end{bmatrix} \right) = \frac{1}{2}\begin{bmatrix}1 & 1 & 1 & 1 \\\\ 1 & -1 & 1 & -1 \\\\ 1 & 1 & -1 & -1 \\\\ 1 & -1 & -1 & 1 \end{bmatrix}\begin{bmatrix}1\\\\ 0\\\\ 0\\\\ 0\end{bmatrix} = \frac{1}{2}\begin{bmatrix}1\\\\ 1\\\\ 1\\\\ 1\end{bmatrix} \mapsto \begin{cases}\text{outcome }=0 & \frac{1}{\sqrt{2}}\begin{bmatrix}1\\\\ 1\\\\ 0\\\\ 0 \end{bmatrix}\\\\ \text{outcome }=1 & \frac{1}{\sqrt{2}}\begin{bmatrix}0\\\\ 0\\\\ 1\\\\ 1 \end{bmatrix}\\\\  \end{cases}.</span></span>
$$
<span data-ttu-id="608e0-233">두 결과 모두 50% 발생 확률이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-233">Both outcomes have 50% probability of occurring.</span></span>  <span data-ttu-id="608e0-234">50% 확률에 대 한 결과는 초기 퀀텀 상태 벡터가 고정 임을 intuited 수 있습니다 $ $ $ $ . 첫 번째 비트의 0을 1로 바꾸면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-234">The outcome being 50% probability for both can be intuited from the fact that the initial quantum state vector is invariant under swapping $0$ with $1$ on the first qubit.</span></span>

<span data-ttu-id="608e0-235">첫 번째 또는 두 번째 비트를 측정 하는 수학적 규칙은 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-235">The mathematical rule for measuring the first or second qubit is simple.</span></span>  <span data-ttu-id="608e0-236">E_k 수 있는 $ 경우 $ $ k ^ { \rm의 계산 기준 벡터를 사용 하 여 } $ $ $ $ $ $ $ 해당 값에 대해 값 1을 사용 하 $ $ 는 모든 e_k 집합을 사용할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-236">If we let $e_k$ be the $k^{\rm th}$ computational basis vector and let $S$ be the set of all $e_k$ such that the qubit in question takes the value $1$ for that value of $k$.</span></span>  <span data-ttu-id="608e0-237">예를 들어 첫 번째 비트를 측정 하는 데 관심이 있는 경우 $ 는 $ $ e_1 \equiv 10 $ 및 $ e_3 \equiv 11 $ 로 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-237">For example, if we are interested in measuring the first qubit then $S$ would consist of $e_1\equiv 10$ and $e_3\equiv 11$.</span></span>  <span data-ttu-id="608e0-238">마찬가지로 두 번째는 $ $ $ e_2 \equiv 01 $ 및 $ e_3 \equiv 11 $ 로 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-238">Similarly, if we are interested in the second qubit $S$ would consist of $e_2\equiv 01$ and $e_3 \equiv 11$.</span></span>  <span data-ttu-id="608e0-239">그런 다음 선택한의 비트를 1로 측정할 확률은 $ $ 상태 벡터에 대해입니다.$\psi$</span><span class="sxs-lookup"><span data-stu-id="608e0-239">Then the probability of measuring the chosen qubit to be $1$ is for state vector $\psi$</span></span>

$$
<span data-ttu-id="608e0-240">P ( \text { 결과 } = 1) = \sum _ { e_k \text { 집합 } S } \psi ^ \dagger e_k e_k ^에 \dagger \psi 있습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-240">P(\text{outcome}=1)= \sum_{e_k \text{ in the set } S}\psi^\dagger e_k e_k^\dagger \psi.</span></span>
$$

> [!NOTE]
<span data-ttu-id="608e0-241">>이 문서에서는 작은 endian 형식을 사용 하 여 계산 기준에 레이블을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-241">> In this document we are using the little-endian format to label the computational basis.</span></span> <span data-ttu-id="608e0-242">Little endian 형식에서 최하위 비트가 먼저 나옵니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-242">In little endian format, the least significant bits come first.</span></span> <span data-ttu-id="608e0-243">예를 들어, 작은 endian 형식의 숫자 4는 비트 001의 문자열로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-243">For example, the number four in little-endian format is represented by the string of bits 001.</span></span>

<span data-ttu-id="608e0-244">각의 비트 측정은 $ 0 또는 1만 생성할 수 있으므로 $ 0으로 $ $ 측정 되는 $ 확률 $ 은 단순히 $ 1-P ( \text { 결과 } = 1)입니다 $ .</span><span class="sxs-lookup"><span data-stu-id="608e0-244">Since each qubit measurement can only yield $0$ or $1$, the probability of measuring $0$ is simply $1-P(\text{outcome}=1)$.</span></span>  <span data-ttu-id="608e0-245">이것은 측정의 확률에 대 한 수식을 명시적으로 제공 하는 이유입니다 $ $ .</span><span class="sxs-lookup"><span data-stu-id="608e0-245">This is why we only explicitly give a formula for the probability of measuring $1$.</span></span>

<span data-ttu-id="608e0-246">이러한 측정이 상태에 주는 동작은 수학적으로로 표현 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-246">The action that such a measurement has on the state can be expressed mathematically as</span></span>

$$
<span data-ttu-id="608e0-247">\psi\mapsto \frac{\sum _ { e_k \text { 집합 } S } e_k e_k ^ \dagger \psi } { \sqrt { P ( \text { 결과 } = 1) } } .</span><span class="sxs-lookup"><span data-stu-id="608e0-247">\psi \mapsto \frac{\sum_{e_k \text{ in the set } S} e_k e_k^\dagger \psi}{\sqrt{P(\text{outcome}=1)}}.</span></span>
$$

<span data-ttu-id="608e0-248">주의 대상 독자는 측정 확률이 0 인 경우 발생 하는 상황에 대해 걱정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-248">The cautious reader may worry about what happens when the probability of the measurement is zero.</span></span>  <span data-ttu-id="608e0-249">이 경우 결과 상태는 기술적으로 정의 되지 않지만 확률은 0 이기 때문에 이러한 eventualities에 대해 걱정 하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-249">While the resultant state is technically undefined in this case, we never need to worry about such eventualities because the probability is zero!</span></span>


<span data-ttu-id="608e0-250">$ \psi $ 위에서 제공 된 균일 한 상태 벡터로 사용 되며, 첫 번째 비트를 측정 하는 데 관심이 있는 경우</span><span class="sxs-lookup"><span data-stu-id="608e0-250">If we take $\psi$ to be the uniform state vector given above and are interested in measuring the first qubit then</span></span> 

$$
<span data-ttu-id="608e0-251">P ( \text { 첫 번째 비트 1의 측정 } = ) = ( \psi ^ \dagger e_1) (e_1 ^ \dagger \psi ) + ( \psi ^ \dagger e_3) (e_3 ^ \dagger \psi ) = | e_1 ^ \dagger \psi | ^ 2 + | e_3 ^ \dagger \psi | ^ 2.</span><span class="sxs-lookup"><span data-stu-id="608e0-251">P(\text{measurement of first qubit}=1) = (\psi^\dagger e_1)(e_1^\dagger \psi)+(\psi^\dagger e_3)(e_3^\dagger \psi)=|e_1^\dagger \psi|^2+|e_3^\dagger \psi|^2.</span></span>
$$

<span data-ttu-id="608e0-252">이는 결과를 측정 하는 데 예상 되는 두 확률의 합계입니다 $ $ . 10과 11은 $ $ 모두 측정할 비트입니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-252">Note that this is just the sum of the two probabilities that would be expected for measuring the results $10$ and $11$ were all the qubits to be measured.</span></span>
<span data-ttu-id="608e0-253">이 예에서는 다음으로 평가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-253">For our example, this evaluates to</span></span>

$$
<span data-ttu-id="608e0-254">\frac{1 } { 4 } \left | \begin{bmatrix} 0 & 0 1 0 1 1 1 1 & & \end{bmatrix} \begin{bmatrix} \\\\ \\\\ \\\\ \end{bmatrix} \right | ^ 2 + 1 4 0 0 0 0 1 1 1 1 \frac { } { } \left | \begin{bmatrix} & & & \end{bmatrix} \begin{bmatrix} \\\\ \\\\ \\\\ 1 \end{bmatrix} \right | ^ 2 = \frac { 1 } { 2 } .</span><span class="sxs-lookup"><span data-stu-id="608e0-254">\frac{1}{4}\left|\begin{bmatrix}0&0&1&0\end{bmatrix}\begin{bmatrix}1\\\\ 1\\\\ 1\\\\ 1\end{bmatrix} \right|^2+\frac{1}{4}\left|\begin{bmatrix}0&0&0&1\end{bmatrix}\begin{bmatrix}1\\\\ 1\\\\ 1\\\\ 1\end{bmatrix} \right|^2=\frac{1}{2}.</span></span>
$$

<span data-ttu-id="608e0-255">intuition가 확률을 나타내는 것과 정확히 일치 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-255">which perfectly matches what our intuition tells us the probability should be.</span></span>  <span data-ttu-id="608e0-256">마찬가지로 상태를로 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-256">Similarly, the state can be written as</span></span>

$$
<span data-ttu-id="608e0-257">\frac{\frac{e_1 } { 2 } + \frac { e_3 } { 2 } } { \sqrt { \frac { 1 } { 2 } } } = \frac { 1 } { \sqrt { 2 } } \begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 1\end{bmatrix}</span><span class="sxs-lookup"><span data-stu-id="608e0-257">\frac{\frac{e_1}{2}+\frac{e_3}{2}}{\sqrt{\frac{1}{2}}}=\frac{1}{\sqrt{2}}\begin{bmatrix} 0\\\\ 0\\\\ 1\\\\ 1\end{bmatrix}</span></span>
$$

<span data-ttu-id="608e0-258">intuition에 따라 다시 합니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-258">again in accordance with our intuition.</span></span>

## <a name="two-qubit-operations"></a><span data-ttu-id="608e0-259">두 가지 비트 작업</span><span class="sxs-lookup"><span data-stu-id="608e0-259">Two-Qubit Operations</span></span>
<span data-ttu-id="608e0-260">단일 비트의 경우 처럼 모든 단일 변환은 원하는 비트의 유효한 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-260">As in the single-qubit case, any unitary transformation is a valid operation on qubits.</span></span> <span data-ttu-id="608e0-261">일반적으로 n의 단일 변환은 $ 크기 2 $ ^ n $ $ 2 ^ n의 행렬 u로 $ \times $ $ $ , $ U ^ { -1 } = u ^ \dagger $ 와 같이 크기 2 ^ n의 벡터에서 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-261">In general, a unitary transformation on $n$ qubits is a matrix $U$ of size $2^n \times 2^n$ (so that it acts on vectors of size $2^n$), such that $U^{-1} = U^\dagger$.</span></span>
<span data-ttu-id="608e0-262">예를 들어 CNOT (제어 되지 않음) 게이트는 일반적으로 사용 되는 두 번째 비트 게이트 이며 다음과 같은 단일 행렬로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-262">For example, the CNOT (controlled-NOT) gate is a commonly used two-qubit gate and is represented by the following unitary matrix:</span></span>

$$
<span data-ttu-id="608e0-263">\operatorname{CNOT } = \begin{bmatrix} 1 \ 0 \ 0 \ 0 \\\\ 0 \ 1 \ 0 \ 0 \\\\ 0 \ 0 \ 0 \ 1 \\\\ 0 \ 0 \ 1 \ 0\end{bmatrix}</span><span class="sxs-lookup"><span data-stu-id="608e0-263">\operatorname{CNOT} = \begin{bmatrix} 1\ 0\ 0\ 0  \\\\  0\ 1\ 0\ 0 \\\\  0\ 0\ 0\ 1 \\\\  0\ 0\ 1\ 0 \end{bmatrix}</span></span>
$$

<span data-ttu-id="608e0-264">또한 두 가지 기능에 단일 고 비트 게이트를 적용 하 여 두 가지 비트 게이트를 형성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-264">We can also form two-qubit gates by applying single-qubit gates on both qubits.</span></span> <span data-ttu-id="608e0-265">예를 들어 게이트를 적용 하는 경우</span><span class="sxs-lookup"><span data-stu-id="608e0-265">For example, if we apply the gates</span></span> 

$$
\begin{bmatrix}
<span data-ttu-id="608e0-266">a \ b \\\\ c \ d\end{bmatrix}</span><span class="sxs-lookup"><span data-stu-id="608e0-266">a\ b\\\\ c\ d \end{bmatrix}</span></span>
$$

<span data-ttu-id="608e0-267">and</span><span class="sxs-lookup"><span data-stu-id="608e0-267">and</span></span>

$$\begin{bmatrix}
<span data-ttu-id="608e0-268">e \ f \\\\ g \ h\end{bmatrix}</span><span class="sxs-lookup"><span data-stu-id="608e0-268">e\ f\\\\ g\ h \end{bmatrix}</span></span>
$$

<span data-ttu-id="608e0-269">첫 번째 및 두 번째 비트의 경우 각각 텐서 제품에서 제공 하는 두 번째 비트를 적용 하는 것과 같습니다.$$\begin{bmatrix}</span><span class="sxs-lookup"><span data-stu-id="608e0-269">to the first and second qubits, respectively, this is equivalent to applying the two-qubit unitary given by their tensor product: $$\begin{bmatrix}</span></span>
<span data-ttu-id="608e0-270">a \ b \\\\ c \ d\end{bmatrix}</span><span class="sxs-lookup"><span data-stu-id="608e0-270">a\ b\\\\ c\ d \end{bmatrix}</span></span>
\otimes 
\begin{bmatrix}
<span data-ttu-id="608e0-271">e \ f \\\\ g \ h\end{bmatrix}=</span><span class="sxs-lookup"><span data-stu-id="608e0-271">e\ f\\\\ g\ h \end{bmatrix}=</span></span>
    \begin{bmatrix}
    <span data-ttu-id="608e0-272">ns\\\\\</span><span class="sxs-lookup"><span data-stu-id="608e0-272">ae\ af\ be\ bf \\\\</span></span>
    <span data-ttu-id="608e0-273">ag \ ah \ bg \ bh\\\\</span><span class="sxs-lookup"><span data-stu-id="608e0-273">ag\ ah\ bg\ bh \\\\</span></span>
    <span data-ttu-id="608e0-274">ce \ cf \ de \ df\\\\</span><span class="sxs-lookup"><span data-stu-id="608e0-274">ce\ cf\ de\ df \\\\</span></span>
    <span data-ttu-id="608e0-275">cg \ ch \ dg \ dh \end{bmatrix} .$$</span><span class="sxs-lookup"><span data-stu-id="608e0-275">cg\ ch\ dg\ dh \end{bmatrix}.$$</span></span>
<span data-ttu-id="608e0-276">따라서 몇 가지 알려진 단일 고 비트 게이트의 텐서 제품을 활용 하 여 두 가지 비트 게이트를 형성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-276">Thus we can form two-qubit gates by taking the tensor product of some known single-qubit gates.</span></span> <span data-ttu-id="608e0-277">2 배 비트 게이트의 몇 가지 예에는 $ h \otimes h $ , $ x \otimes \boldone $ 및 $ x \otimes Z가 $ 있습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-277">Some examples of two-qubit gates include $H \otimes H$, $X \otimes \boldone$, and $X \otimes Z$.</span></span>

<span data-ttu-id="608e0-278">두 개의 단일 기능 비트 게이트가 텐서 제품을 가져와 두 번째 비트 게이트를 정의 하지만 반대의 경우는 그렇지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-278">Note that while any two single-qubit gates define a two-qubit gate by taking their tensor product, the converse is not true.</span></span> <span data-ttu-id="608e0-279">두 가지 모든 비트 게이트는 단일 고 비트 게이트의 텐서 곱으로 작성할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-279">Not all two-qubit gates can be written as the tensor product of single-qubit gates.</span></span>  <span data-ttu-id="608e0-280">이러한 게이트를 *entangling* 게이트 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-280">Such a gate is called an *entangling* gate.</span></span> <span data-ttu-id="608e0-281">Entangling gate의 한 가지 예로 CNOT gate가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-281">One example of an entangling gate is the CNOT gate.</span></span>

<span data-ttu-id="608e0-282">제어 되지 않는 게이트 intuition 뒤에 있는 경우 임의 게이트로 일반화 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-282">The intuition behind a controlled-not gate can be generalized to arbitrary gates.</span></span>  <span data-ttu-id="608e0-283">일반적으로 제어 되는 게이트는 특정 비트 비트가 1 인 경우를 제외 하 고 id 역할을 하는 게이트 (작업 없음)입니다 $ $ .</span><span class="sxs-lookup"><span data-stu-id="608e0-283">A controlled gate in general is a gate that acts as identity (ie it has no action) unless a specific qubit is $1$.</span></span>  <span data-ttu-id="608e0-284">이 경우 x $ $ $ \Lambda \_ (U)를 사용 하 여 $ 레이블이 지정 된 x에 대 한 제어 된 단일를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-284">We denote a controlled unitary, controlled in this case on the qubit labeled $x$, with a $\Lambda\_x(U)$.</span></span>  <span data-ttu-id="608e0-285">예를 들어 $ \Lambda _0 (u) e \_ { 1 } \otimes { \psi } = e 1 \_ { } \otimes U { \psi } $ 및 $ \Lambda \_ 0 (u) e \_ { 0 } \otimes { \psi } = e \_ { 0 } \otimes { \psi } $ $ \_ 입니다. 여기서 e 0 $ 과 $ e \_ 1 $ 은 값 $ 0 $ 및 1에 해당 하는 단일 값에 대 한 계산 기준 벡터입니다 $ $ .</span><span class="sxs-lookup"><span data-stu-id="608e0-285">As an example $\Lambda_0(U) e\_{1}\otimes {\psi}=e\_{1}\otimes U{\psi}$ and $\Lambda\_0(U) e\_{0}\otimes {\psi}=e\_{0}\otimes{\psi}$, where $e\_0$ and $e\_1$ are the computational basis vectors for a single qubit corresponding to the values $0$ and $1$.</span></span>  <span data-ttu-id="608e0-286">예를 들어 다음과 같은 제어-Z 게이트를 고려 하 여 $ $ 이를 표현할 수 있습니다.$$</span><span class="sxs-lookup"><span data-stu-id="608e0-286">For example, consider the following controlled-$Z$ gate then we can express this as $$</span></span>
<span data-ttu-id="608e0-287">\Lambda\_0 (Z) 1 0 0 0 0 0 0 0 0 0 = \begin{bmatrix} & 1 0 0 0 & & \\\\ & & & \\\\ & & & \\\\ & & & -1 \end{bmatrix} = ( \boldone \otimes h) \operatorname { cnot } ( \boldone \otimes h).</span><span class="sxs-lookup"><span data-stu-id="608e0-287">\Lambda\_0(Z)= \begin{bmatrix}1&0&0&0\\\\0&1&0&0\\\\0&0&1&0\\\\0&0&0&-1 \end{bmatrix}=(\boldone\otimes H)\operatorname{CNOT}(\boldone\otimes H).</span></span>
$$

<span data-ttu-id="608e0-288">효율적인 방식으로 제어 되는 unitaries을 빌드하는 것은 중요 한 문제입니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-288">Building controlled unitaries in an efficient manner is a major challenge.</span></span>  <span data-ttu-id="608e0-289">이를 구현 하는 가장 간단한 방법은 제어 되는 기본 게이트 버전의 데이터베이스를 형성 하 고 원래 단일 작업의 모든 기본 게이트를 제어 된 해당 작업으로 바꾸는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-289">The simplest way to implement this requires forming a database of controlled versions of fundamental gates and replacing every fundamental gate in the original unitary operation with its controlled counterpart.</span></span>  <span data-ttu-id="608e0-290">이는 종종 매우 불필요 한 정보를 사용 하 여 동일한 영향을 얻기 위해 몇 가지 게이트를 제어 된 버전으로 바꾸는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-290">This is often quite wasteful and clever insight often can be used to just replace a few gates with controlled versions to achieve the same impact.</span></span>  <span data-ttu-id="608e0-291">이러한 이유로, 최적화 된 손으로 조정 된 버전이 알려진 경우 사용자가 제어 하는 naive 메서드를 수행 하거나 제어 되는 버전의 사용자를 정의할 수 있도록 하는 기능을 프레임 워크에 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-291">For this reason, we provide in our framework the ability to perform either the naive method of controlling or allow the user to define a controlled version of the unitary if an optimized hand-tuned version is known.</span></span>

<span data-ttu-id="608e0-292">클래식 정보를 사용 하 여 게이트를 제어할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-292">Gates can also be controlled using classical information.</span></span>  <span data-ttu-id="608e0-293">예를 들어 일반적으로 제어 되는 게이트는 일반적인 비 게이트 이지만, 기존 비트가 $ 퀀텀 비트가 아닌 1 인 경우에만 적용 됩니다 $ .</span><span class="sxs-lookup"><span data-stu-id="608e0-293">A classically controlled not-gate, for example, is just an ordinary not-gate but it is only applied if a classical bit is $1$ as opposed to a quantum bit.</span></span>  <span data-ttu-id="608e0-294">이러한 점에서 일반적으로 제어 되는 게이트는 코드의 한 분기에만 게이트가 적용 되는 퀀텀 코드의 if 문으로 간주할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-294">In this sense, a classically controlled gate can be thought of as an if statement in the quantum code wherein the gate is applied only in one branch of the code.</span></span>


<span data-ttu-id="608e0-295">단일 수준 비트의 경우 처럼 $ \times $ 이 집합에서 임의 전체 자릿수로 4 개의 단일 행렬의 게이트를 대략적으로 비교할 수 있는 경우 2 ~ 5 비트 게이트 집합이 유니버설입니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-295">As in the single-qubit case, a two-qubit gate set is universal if any $4\times 4$ unitary matrix can be approximated by a product of gates from this set to arbitrary precision.</span></span>
<span data-ttu-id="608e0-296">범용 게이트 집합의 한 가지 예는 Hadamard 게이트, T 게이트 및 CNOT 게이트입니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-296">One example of a universal gate set is the Hadamard gate, the T gate, and the CNOT gate.</span></span> <span data-ttu-id="608e0-297">이러한 게이트의 제품을 활용 하 여 두 개의 모든 단일 행렬을 대략적으로 살펴볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-297">By taking products of these gates, we can approximate any unitary matrix on two qubits.</span></span>

## <a name="many-qubit-systems"></a><span data-ttu-id="608e0-298">수많은 비트 시스템</span><span class="sxs-lookup"><span data-stu-id="608e0-298">Many-Qubit Systems</span></span>
<span data-ttu-id="608e0-299">두 번째 수준에서 살펴본 것과 동일한 패턴을 따라 작은 시스템에서 다양 한 수준의 퀀텀 상태를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-299">We follow exactly the same patterns explored in the two-qubit case to build many-qubit quantum states from smaller systems.</span></span>  <span data-ttu-id="608e0-300">이러한 상태는 더 작은 상태의 텐서 제품을 형성 하 여 구축 됩니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-300">Such states are built by forming tensor products of smaller states.</span></span>  <span data-ttu-id="608e0-301">예를 들어, $ 퀀텀 컴퓨터에서 1011001 비트 문자열을 인코딩합니다 $ .</span><span class="sxs-lookup"><span data-stu-id="608e0-301">For example, consider encoding the bit string $1011001$ in a quantum computer.</span></span>  <span data-ttu-id="608e0-302">이를 다음과 같이 인코딩할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-302">We can encode this as</span></span>

$$
<span data-ttu-id="608e0-303">1011001 \equiv \begin{bmatrix} 0 1 1 0 0 1 0 1 1 0 1 0 0 \\\\ \end{bmatrix} \otimes \begin{bmatrix} \\\\ \end{bmatrix} \otimes \begin{bmatrix} \\\\ \end{bmatrix} \otimes \begin{bmatrix} \\\\ \end{bmatrix} \otimes \begin{bmatrix} \\\\ \end{bmatrix} \otimes \begin{bmatrix} \\\\ \end{bmatrix} \otimes \begin{bmatrix} \\\\ 1 \end{bmatrix} .</span><span class="sxs-lookup"><span data-stu-id="608e0-303">1011001 \equiv \begin{bmatrix} 0 \\\\  1 \end{bmatrix}\otimes \begin{bmatrix} 1 \\\\  0 \end{bmatrix}\otimes \begin{bmatrix} 0 \\\\  1 \end{bmatrix}\otimes \begin{bmatrix} 0 \\\\  1 \end{bmatrix} \otimes \begin{bmatrix} 1 \\\\  0 \end{bmatrix}\otimes \begin{bmatrix} 1 \\\\  0 \end{bmatrix}\otimes \begin{bmatrix} 0 \\\\  1 \end{bmatrix}.</span></span>
$$

<span data-ttu-id="608e0-304">퀀텀 게이트는 정확히 동일한 방식으로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-304">Quantum gates work in exactly the same way.</span></span>  <span data-ttu-id="608e0-305">예를 들어, $ $ 첫 번째 비트에 X 게이트를 적용 한 다음 두 번째와 세 번째 비트 간에 cnot을 수행 하려는 경우이 변환을 표현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-305">For example, if we wish to apply the $X$ gate to the first qubit and then perform a CNOT between the second and third qubits we may express this transformation as</span></span>

\begin{align}
<span data-ttu-id="608e0-306">&(X \otimes \operatorname { cnot } _ { 12 } \otimes \boldone \otimes \boldone \otimes \boldone \otimes \boldone ) \begin{bmatrix} 0 \\\\ 1 \end{bmatrix} \otimes \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} \otimes \begin{bmatrix} 0 \\\\ 1 \end{bmatrix} \otimes \begin{bmatrix} 0 \\\\ 1 \end{bmatrix} \otimes \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} \otimes \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} \otimes \begin{bmatrix} \\\\ 0 1\end{bmatrix}\\\\</span><span class="sxs-lookup"><span data-stu-id="608e0-306">&(X \otimes \operatorname{CNOT}_{12}\otimes \boldone\otimes \boldone \otimes \boldone \otimes \boldone) \begin{bmatrix} 0 \\\\  1 \end{bmatrix}\otimes \begin{bmatrix} 1 \\\\  0 \end{bmatrix}\otimes \begin{bmatrix} 0 \\\\  1 \end{bmatrix}\otimes \begin{bmatrix} 0 \\\\  1 \end{bmatrix} \otimes \begin{bmatrix} 1 \\\\  0 \end{bmatrix}\otimes \begin{bmatrix} 1 \\\\  0 \end{bmatrix}\otimes \begin{bmatrix} 0 \\\\  1 \end{bmatrix}\\\\</span></span>
<span data-ttu-id="608e0-307">&\qquad\qquad\equiv0011001.\end{align}</span><span class="sxs-lookup"><span data-stu-id="608e0-307">&\qquad\qquad\equiv 0011001. \end{align}</span></span>

<span data-ttu-id="608e0-308">많은 수의 시스템에서 퀀텀 컴퓨터의 임시 메모리 역할을 하는 원하는 비트를 할당 하 고 할당을 취소 해야 하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-308">In many qubit systems, there is often a need to allocate and deallocate qubits that serve as temporary memory for the quantum computer.</span></span>  <span data-ttu-id="608e0-309">이러한 비트를 ancilla 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-309">Such a qubit is called an ancilla.</span></span>  <span data-ttu-id="608e0-310">기본적으로이 경우에는 $ 할당 될 때 e_0로 초기화 되는 것으로 가정 합니다 $ .</span><span class="sxs-lookup"><span data-stu-id="608e0-310">By default we assume the qubit state is initialized to $e_0$ upon allocation.</span></span>  <span data-ttu-id="608e0-311">할당 취소 전에 e_0 하기 위해 다시 반환 되는 것으로 가정 $ $ 합니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-311">We further assume that it is returned again to $e_0$ before deallocation.</span></span>  <span data-ttu-id="608e0-312">이 가정은 ancilla가 할당 취소 될 때 다른의 비트 레지스터를 사용 하 여 점점 증가 하 게 되 면 할당 취소 프로세스에서 ancilla을 손상 시키기 때문에 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-312">This assumption is important because if an ancilla qubit becomes entangled with another qubit register when it becomes deallocated then the process of deallocation will damage the ancilla.</span></span>  <span data-ttu-id="608e0-313">이러한 이유로 항상 이러한 비트를 출시 되기 전의 초기 상태로 되돌리는 것으로 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-313">For this reason, we always assume that such qubits are reverted to their initial state before being released.</span></span>

<span data-ttu-id="608e0-314">마지막으로, 새 게이트를 게이트 집합에 추가 하 여 두 개의 엔터프라이즈급 비트 퀀텀 컴퓨터에 대 한 범용 퀀텀 컴퓨팅을 구현 하는 경우에도 새 게이트를 여러 기능에서 도입 해야 하는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-314">Finally, although new gates needed to be added to our gate set to achieve universal quantum computing for two qubit quantum computers, no new gates need to be introduced in the multi-qubit case.</span></span>  <span data-ttu-id="608e0-315">$ $ $ $ 일반적인 단일 변환은 두 개의 다양 한 비트 회전으로 분리 될 수 있기 때문에 게이트 H, T 및 cnot은 다양 한 세계에서 범용 게이트 집합을 형성 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-315">The gates $H$, $T$ and CNOT form a universal gate set on many qubits because any general unitary transformation can be broken into a series of two qubit rotations.</span></span>  <span data-ttu-id="608e0-316">그런 다음 두 번째 비트 사례에 대해 개발한 이론을 활용 하 고 다양 한 기능을 제공 하는 경우 여기에서 다시 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-316">We then can leverage the theory developed for the two-qubit case and use it again here when we have many qubits.</span></span>

<span data-ttu-id="608e0-317">지금까지 사용 하 던 선형 대 수 표기법은 매우 다양 한 비트 상태를 설명 하는 데 사용 될 수 있지만 상태 크기를 늘리면 점점 복잡해 집니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-317">While the linear algebraic notation that we have been using thus far can certainly be used to describe multi-qubit states, it becomes increasingly cumbersome as we increase the size of the states.</span></span>  <span data-ttu-id="608e0-318">예를 들어 길이 7 비트 문자열에 대 한 결과 벡터는 $ 128 $ 차원입니다 .이를 통해 앞에서 설명한 표기법을 사용 하 여이를 표현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-318">The resulting column-vector for a length 7 bit string, for example, is $128$ dimensional, which makes expressing it using the notation described previously very cumbersome.</span></span>  <span data-ttu-id="608e0-319">이러한 이유로, 다음은 이러한 높은 차원 벡터를 간결 하 게 설명할 수 있도록 하는 퀀텀 컴퓨팅에 일반적인 표기법을 제시 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="608e0-319">For this reason, we next present a common notation in quantum computing that allows us to concisely describe these high-dimensional vectors.</span></span>
