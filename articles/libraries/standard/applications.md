---
title: 'Q # 표준 라이브러리-응용 프로그램 | Microsoft Docs'
description: 'Q # 표준 라이브러리'
author: QuantumWriter
uid: microsoft.quantum.libraries.applications
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: e6eca45dd67b3566340c2a2a4fded0f6e7c3c5c3
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/29/2019
ms.locfileid: "73185174"
---
# <a name="applications"></a><span data-ttu-id="50e79-103">애플리케이션</span><span class="sxs-lookup"><span data-stu-id="50e79-103">Applications</span></span> #

## <a name="hamiltonian-simulation"></a><span data-ttu-id="50e79-104">Hamiltonian 시뮬레이션</span><span class="sxs-lookup"><span data-stu-id="50e79-104">Hamiltonian Simulation</span></span> ##

<span data-ttu-id="50e79-105">퀀텀 시스템의 시뮬레이션은 퀀텀 계산의 가장 흥미로운 응용 프로그램 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-105">The simulation of quantum systems is one of the most exciting applications of quantum computation.</span></span>
<span data-ttu-id="50e79-106">기존 컴퓨터에서 퀀텀 메커니즘을 시뮬레이션 하는 어려움은 일반적으로 상태-벡터 표현의 차원 $N로 확장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-106">On a classical computer, the difficulty of simulating quantum mechanics, in general, scales with the dimension $N$ of its state-vector representation.</span></span>
<span data-ttu-id="50e79-107">이 표현은 $n $ wbits $N = 2 ^ n $의 수를 사용 하 여 급격 하 게 증가 하 고, 차원의 [저주](xref:microsoft.quantum.concepts.multiple-qubits)라고도 알려진 특성은 클래식 하드웨어의 퀀텀 시뮬레이션 intractable입니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-107">As this representation grows exponentially with the number of $n$ qubits $N=2^n$, a trait known also known as the [curse of dimensionality](xref:microsoft.quantum.concepts.multiple-qubits), quantum simulation on classical hardware is intractable.</span></span>

<span data-ttu-id="50e79-108">그러나이 상황은 퀀텀 하드웨어에서 매우 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-108">However, the situation can be very different on quantum hardware.</span></span> <span data-ttu-id="50e79-109">퀀텀 시뮬레이션의 가장 일반적인 변형은 시간 독립적 Hamiltonian 시뮬레이션 문제 라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-109">The most common variation of quantum simulation is called the time-independent Hamiltonian simulation problem.</span></span> <span data-ttu-id="50e79-110">여기에는 시스템 Hamiltonian $H $ (Hermitian 행렬) 및 일부 초기 퀀텀 상태 $ \ket{\psi (0)} $에 대 한 설명이 제공 됩니다 .이에 대해서는 퀀텀 컴퓨터에서 $를 사용 하 여 일부 $n 기준으로 인코딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-110">There, one is provided with a description of the system Hamiltonian $H$, which is a Hermitian matrix, and some initial quantum state $\ket{\psi(0)}$ that is encoded in some basis on $n$ qubits on a quantum computer.</span></span> <span data-ttu-id="50e79-111">폐쇄 된 시스템의 퀀텀 상태는 Schrödinger 수식 $ $ \begin{align} i\frac {d \ket{\psi (t)}} {d t} & = H \ket{\psi (t)}, \end{align} $ $으로 발전 하 고 있습니다 .이 목표는 단일 시간 진화 연산자 $U (t) = e ^ {-iHt} $를 고정 된 시간에 구현 하는 것입니다 $t $ , 여기서 $ \ket{\psi (t)} = U (t) \ket{\psi (0)} $은 Schrödinger 방정식을 해결 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-111">As quantum states in closed systems evolve under the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ the goal is to implement the unitary time-evolution operator $U(t)=e^{-iHt}$ at some fixed time $t$, where $\ket{\psi(t)}=U(t)\ket{\psi(0)}$ solves the Schrödinger equation.</span></span>
<span data-ttu-id="50e79-112">와 유사 시간 종속 Hamiltonian 시뮬레이션 문제는 동일한 수식을 해결 하지만 이제는 $H (t) $를 사용 하 여 시간을 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-112">Analogously, the time-dependent Hamiltonian simulation problem solves the same equation, but with $H(t)$ now a function of time.</span></span>

<span data-ttu-id="50e79-113">Hamiltonian 시뮬레이션은 다른 여러 퀀텀 시뮬레이션 문제의 주요 구성 요소 이며 Hamiltonian 시뮬레이션 문제에 대 한 해결 방법은 synthesizing에 대 한 기본 퀀텀 게이트 시퀀스를 설명 하는 알고리즘입니다. 오류 $\\| \tilde{U}-U (t)\\| [spectral](xref:microsoft.quantum.concepts.matrix-advanced)의 \le \le $입니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-113">Hamiltonian simulation is a major component of many other quantum simulation problems, and solutions to Hamiltonian simulation problem are algorithms that describes a sequence of primitive quantum gates for synthesizing an approximating unitary $\tilde{U}$ with error $\\|\tilde{U} - U(t)\\| \le \epsilon$ in the [spectral norm](xref:microsoft.quantum.concepts.matrix-advanced).</span></span> <span data-ttu-id="50e79-114">이러한 알고리즘의 복잡성은 퀀텀 컴퓨터에서 관심 있는 Hamiltonian에 대 한 설명을 액세스 하는 방법에 매우 강력한 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-114">The complexity of these algorithms depend very strongly on how a description of the Hamiltonian of interest is made accessible by a quantum computer.</span></span> <span data-ttu-id="50e79-115">예를 들어 최악의 경우, $n $ ombits에 대해 작동 하는 $H $은 각 matrix 요소에 대해 하나씩 $2 ^ n \times 2 ^ n $ 숫자의 목록으로 제공 되어야 합니다. 즉, 데이터를 읽기만 하면 지 수 시간이 이미 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-115">For instance, in the worst-case, if $H$ acting on $n$ qubits were to be provided as a list of $2^n \times 2^n$ numbers, one for each matrix element, simply reading the data would already require exponential time.</span></span> <span data-ttu-id="50e79-116">최상의 경우에는 $O \ket{t}\ket{\psi (0)} = \ket{t}U (t) \ket{\psi (0)} $ 일반적으로에서 문제를 해결 하는 검정 상자에 대 한 액세스를 가정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-116">In the best case, one could assume access to a black-box unitary that $O\ket{t}\ket{\psi(0)}=\ket{t}U(t)\ket{\psi(0)}$ trivially solves the problem.</span></span> <span data-ttu-id="50e79-117">이러한 입력 모델은 특히 유용 하지 않습니다. 즉, 기존의 접근 방식 보다는 더 이상 유용 하지 않으며, 검은색 상자는 구현에 대 한 기본 게이트 복잡성을 숨깁니다 .이는 다양 한 기능을 지 원하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-117">Neither of these input models are particularly interesting -- the former as it is no better than classical approaches, and the latter as the black-box hides the primitive gate complexity of its implementation, which could be exponential in the number of qubits.</span></span>

### <a name="descriptions-of-hamiltonians"></a><span data-ttu-id="50e79-118">Hamiltonians에 대 한 설명</span><span class="sxs-lookup"><span data-stu-id="50e79-118">Descriptions of Hamiltonians</span></span> ###

<span data-ttu-id="50e79-119">따라서 입력 형식에 대 한 추가 가정이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-119">Additional assumptions of the format of the input are therefore required.</span></span> <span data-ttu-id="50e79-120">현실적인 물리적 시스템이 나 흥미로운 계산 문제에 대 한 설명 및 충분히 제한적인 입력 모델 등 흥미로운 Hamiltonians을 포함 하는 데 충분 한 설명이 포함 된 입력 모델 간에 미세한 균형을 맞추어야 합니다. 퀀텀 컴퓨터에서 효율적으로 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-120">A fine balance must be struck between input models that are sufficiently descriptive to encompass interesting Hamiltonians, such as those for realistic physical systems or interesting computational problems, and input models that are sufficiently restrictive to be efficiently implementable on a quantum computer.</span></span> <span data-ttu-id="50e79-121">이 문서의 다양 한 특수 입력 모델을 찾을 수 있으며,이는 퀀텀에서 클래식으로 범위가 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-121">A variety of non-trivial input model may be found in the literature, and they range from quantum to classical.</span></span> 

<span data-ttu-id="50e79-122">퀀텀 입력 모델의 예로 [샘플 기반 Hamiltonian 시뮬레이션](http://www.nature.com/articles/s41534-017-0013-7) 에서는 Hamiltonian $H $로 사용 되는 밀도 행렬 $ \rho $의 복사본을 생성 하는 퀀텀 작업에 대 한 블랙 박스 액세스를 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-122">As examples of quantum input models, [sample-based Hamiltonian simulation](http://www.nature.com/articles/s41534-017-0013-7) assumes black-box access to quantum operations that produce copies of a density matrix $\rho$, which are taken to be the Hamiltonian $H$.</span></span> <span data-ttu-id="50e79-123">[단일 액세스 모델](https://arxiv.org/abs/1202.5822) 에서 Hamiltonian는 대신 unitaries $ $ \begin{align} H & = \sum ^ {d-1}\_{j = 0} a\_j \hat{U}\_j, \end{align} $ $ (여기서 $a\_j > 0 $)의 합계로 분해 됩니다. 및 $ \hat{U}\_j $는 unitaries입니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-123">In the [unitary access model](https://arxiv.org/abs/1202.5822) one supposes that the Hamiltonian instead decomposes into a sum of unitaries $$ \begin{align} H & = \sum^{d-1}\_{j=0} a\_j \hat{U}\_j, \end{align} $$ where $a\_j>0$ are coefficients, and $\hat{U}\_j$ are unitaries.</span></span> <span data-ttu-id="50e79-124">그런 다음 원하는 $ \hat{U}\_j $ 및 oracle $A \ket{0}= \sum ^ {d-1}\_를 선택 하는 단일 oracle $V = \sum ^ {d-1}\_{j = 0} \ket{j}\bra{j}\otimes \hat{U}\_j $에 대 한 블랙 박스 액세스 권한이 있다고 가정 합니다. j = 0} \sqrt{a\_j/\ sum ^ {d-1}\_{k = 0} \alpha\_j} \ket{j} $는 이러한 계수를 인코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-124">It is then assumed that one has black-box access to the unitary oracle $V=\sum^{d-1}\_{j=0}\ket{j}\bra{j}\otimes \hat{U}\_j$ that selects the desired $\hat{U}\_j$, and the oracle $A\ket{0}=\sum^{d-1}\_{j=0}\sqrt{a\_j/\sum^{d-1}\_{k=0}\alpha\_j}\ket{j}$ that create a quantum state encoding these coefficients.</span></span> <span data-ttu-id="50e79-125">[스파스 Hamiltonian 시뮬레이션](https://arxiv.org/abs/quant-ph/0301023)의 경우 Hamiltonian는 모든 행에서 0이 아닌 $d = \mathcal{O} (\Text{polylog} (N)) $0 요소만 포함 된 스파스 행렬 이라고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-125">In the case of [sparse Hamiltonian simulation](https://arxiv.org/abs/quant-ph/0301023), one assumes that the Hamiltonian is a sparse matrix with only $d=\mathcal{O}(\text{polylog}(N))$ non-zero element in every row.</span></span> <span data-ttu-id="50e79-126">또한 이러한 0이 아닌 요소의 위치와 해당 값을 출력 하는 효율적인 퀀텀 회로의 존재를 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-126">Moreover, one assumes the existence of efficient quantum circuits that output the location of these non-zero elements, as well as the their values.</span></span> <span data-ttu-id="50e79-127">[Hamiltonian 시뮬레이션 알고리즘](xref:microsoft.quantum.more-information) 의 복잡성은 이러한 검은색 상자에 대 한 쿼리 수 측면에서 평가 되며, 기본 게이트 복잡성은 이러한 검은색 상자를 구현 하는 데 어려움이 매우 높습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-127">The complexity of [Hamiltonian simulation algorithms](xref:microsoft.quantum.more-information) is evaluated in terms of number of queries to these black-boxes, and the primitive gate complexity then depends very much on the difficulty of implementing these black-boxes.</span></span>

> [!NOTE]
> <span data-ttu-id="50e79-128">큰 O 표기법은 알고리즘의 복잡성 확장을 설명 하는 데 주로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-128">The big-O notation is commonly used to describe the complexity scaling of algorithms.</span></span> <span data-ttu-id="50e79-129">G $ 라는 두 개의 실제 함수 $f g $ $g (x) = \mathcal{O} (f (x)) $는 모든 > \le x $g $0에 대 한 $x (x) \le c f (x) $와 같은 절대 양의 상수가\_0, c\_0 $ $x 있음을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-129">Given two real functions $f,g$, the expression $g(x)=\mathcal{O}(f(x))$ means that there exists an absolute positive constant $x\_0, c>0$ such that $g(x) \le c f(x)$ for all $x\ge x\_0$.</span></span> 

<span data-ttu-id="50e79-130">퀀텀 컴퓨터에서 구현 되는 대부분의 실용적인 응용 프로그램에서는 이러한 검은색 상자를 효율적으로 구현 해야 합니다. 즉, $ \mathcal{O} (\text{polylog} (N)) $ primitive 퀀텀 게이트를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-130">In most practical applications to be implemented on a quantum computer, these black-boxes must be efficiently implementable, that is with $\mathcal{O}(\text{polylog}(N))$ primitive quantum gates.</span></span> <span data-ttu-id="50e79-131">더 강력 하 고 효율적으로 simulable Hamiltonians에는 충분 한 스파스 기존 설명이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-131">More strongly, efficiently simulable Hamiltonians must have some sufficiently sparse classical description.</span></span> <span data-ttu-id="50e79-132">이러한 공식화 중 하나에서 Hamiltonian 분해는 Hermitian parts $ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} H_j의 합계로 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-132">In one such formulation, it is assumed that the Hamiltonian decomposes into a sum of Hermitian parts $$ \begin{align} H & = \sum^{d-1}_{j=0} H_j.</span></span>
<span data-ttu-id="50e79-133">\end{align} $ $ 뿐만 아니라 각 Hamiltonian $H\_j $를 시뮬레이션 하는 것으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-133">\end{align} $$ Moreover, it is assumed that each part, a Hamiltonian $H\_j$, is easy to simulate.</span></span> <span data-ttu-id="50e79-134">즉, 모든 $t 시간에 대 한 단일 $e ^ {-iH\_j t} $는 $ \mathcal{O} (1) $ primitive 퀀텀 게이트를 사용 하 여 정확 하 게 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-134">This means that the unitary $e^{-iH\_j t}$ for any time $t$ may be implemented exactly using $\mathcal{O}(1)$ primitive quantum gates.</span></span> <span data-ttu-id="50e79-135">예를 들어, 각 $H\_j $가 로컬 Pauli 연산자 인 특수 한 경우에는 이러한 경우가 있습니다. 즉,이는 공간적으로 닫힌 \mathcal{O}에 적용 되는 $ (1) $ 비 id Pauli 연산자의 텐서 제품입니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-135">For instance, this is true in the special case where each $H\_j$ are local Pauli operators, meaning that they are of tensor products of $\mathcal{O}(1)$ non-identity Pauli operators that act on spatially close qubits.</span></span> <span data-ttu-id="50e79-136">이 모델은 용어 수가 $d = \mathcal{O} (\text{polylog} (N)) $ 이기 때문에 경계 및 로컬 상호 작용을 사용 하는 물리적 시스템에 특히 적용할 수 있으며,이는 다항식 시간에 설명 된 일반적으로를 명확 하 게 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-136">This model is particularly applicable to physical systems with bounded and local interaction, as the number of terms is $d=\mathcal{O}(\text{polylog}(N))$, and may clearly be written down, i.e. classically described, in polynomial time.</span></span>

> [!TIP]
> <span data-ttu-id="50e79-137">Hamiltonians 부품의 합계로 분리 하는 경우 동적 생성기 표현 라이브러리를 사용 하 여 설명할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-137">Hamiltonians that decompose into a sum of parts may be described using the Dynamical Generator Representation library.</span></span> <span data-ttu-id="50e79-138">자세한 내용은 [데이터 구조의](xref:microsoft.quantum.libraries.data-structures)동적 생성기 표현 섹션을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="50e79-138">For more information, see the Dynamical Generator Representation section in [data structures](xref:microsoft.quantum.libraries.data-structures).</span></span>

### <a name="simulation-algorithms"></a><span data-ttu-id="50e79-139">시뮬레이션 알고리즘</span><span class="sxs-lookup"><span data-stu-id="50e79-139">Simulation Algorithms</span></span> ###

<span data-ttu-id="50e79-140">퀀텀 시뮬레이션 알고리즘은 Hamiltonian의 지정 된 설명을 기본 퀀텀 게이트 시퀀스로 변환 합니다. 즉, Hamiltonian에 의해 전체적으로 대략적인 시간이 진화 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-140">A quantum simulation algorithm converts a given description of a Hamiltonian into a sequence of primitive quantum gates that, as a whole, approximate time-evolution by said Hamiltonian.</span></span>

<span data-ttu-id="50e79-141">Hamiltonian 분해 Hermitian 부분을 합산 하는 특별 한 경우 Trotter Suzuki 분해는 Hamiltonians 구성 요소 합계를 분리 하는 Hermitian를 시뮬레이션 하는 데 특히 간단 하 고 직관적인 알고리즘입니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-141">In the special case where the Hamiltonian decomposes into a sum of Hermitian parts, the Trotter-Suzuki decomposition is a particularly simple and intuitive algorithm for simulating Hamiltonians that decompose into a sum of Hermitian components.</span></span> <span data-ttu-id="50e79-142">예를 들면이 패밀리의 첫 번째 주문 통합자는 $ $ \begin{align} U (t) & = \left (e ^ {-iH\_0 t/r} e ^ {-iH\_1 t)와 비슷합니다./r} \cume ^ {-iH\_{d-1} t/r} \left) ^ {r} + \mathcal{O} (d ^ 2 \max_j\\| H\_j\\| ^ 2 t ^ 2/r), \end{align} $ $ $r d $ 약관의 제품을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-142">For instance, a first-order integrator of this family approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j\\|H\_j\\|^2 t^2/r), \end{align} $$ using a product of $r d$ terms.</span></span> 

> [!TIP]
> <span data-ttu-id="50e79-143">Trotter-Suzuki 시뮬레이션 알고리즘의 응용 프로그램은 샘플에서 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-143">Applications of the Trotter-Suzuki simulation algorithm are covered in the samples.</span></span>
> <span data-ttu-id="50e79-144">각 대상 컴퓨터에서 제공 되는 내장 작업만 사용 하는 Ising 모델의 경우 [ **simpleising** 샘플](https://github.com/Microsoft/Quantum/tree/master/Samples/src/SimpleIsing)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="50e79-144">For the Ising model using only the intrinsic operations provided by each target machine, please see the [**SimpleIsing** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/SimpleIsing).</span></span>
> <span data-ttu-id="50e79-145">Trotter-Suzuki library 컨트롤 구조를 사용 하는 Ising 모델의 경우 [ **IsingTrotter** 샘플](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingTrotterEvolution)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="50e79-145">For the Ising model using the Trotter-Suzuki library control structure, please see the [**IsingTrotter** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingTrotterEvolution).</span></span>
> <span data-ttu-id="50e79-146">Trotter-Suzuki library 컨트롤 구조를 사용 하는 분자 Hydrogen의 경우 [ **H2 시뮬레이션** 샘플](https://github.com/Microsoft/Quantum/tree/master/Samples/src/H2SimulationCmdLine)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="50e79-146">For molecular Hydrogen using the Trotter-Suzuki library control structure, please see the [**H2 simulation** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/H2SimulationCmdLine).</span></span>

<span data-ttu-id="50e79-147">대부분의 경우 시뮬레이션 알고리즘을 구현 하지만 해당 구현에 대 한 세부 정보에 관심이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-147">In many cases, we would like to implement the simulation algorithm, but are not interested in the details of its implementation.</span></span> <span data-ttu-id="50e79-148">예를 들면 두 번째 주문 통합자는 $ $ \begin{align} U (t) & = \left (e ^ {-iH\_0 t/2r} e ^ {-iH\_1 t/2r} \c도트 e ^ {-) 근사치를 계산 합니다. iH\_{d-1} t/2r} e ^ {-iH\_{d-1} t/2r} \c도트 e ^ {-iH\_1 t/2r} e ^ {- iH\_0 t/2r} \right) ^ {r} + \mathcal{O} (d ^ 3 \max_j\\| H\_j\\| ^ 3 t ^ 3/r ^ 2), $2rd $ 약관의 제품을 사용 하 여 $ $ \end{align}.</span><span class="sxs-lookup"><span data-stu-id="50e79-148">For instance, the second-order integrator approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / 2r} e^{-iH\_1 t / 2r} \cdots e^{-iH\_{d-1} t / 2r} e^{-iH\_{d-1} t / 2r}  \cdots e^{-iH\_1 t / 2r} e^{-iH\_0 t / 2r} \right)^{r} + \mathcal{O}(d^3 \max_j\\|H\_j\\|^3 t^3/r^2), \end{align} $$ using a product of $2rd$ terms.</span></span> <span data-ttu-id="50e79-149">더 큰 주문에는 더 많은 용어가 포함 되 고, 최적화 된 변형에는 지 수에 대 한 매우 특수 한 순서 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-149">Larger orders will involve even more terms and optimized variants may require highly non-trivial orderings on the exponentials.</span></span> <span data-ttu-id="50e79-150">다른 고급 알고리즘은 중간 단계에서 ancilla의 사용을 포함할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-150">Other advanced algorithms may also involve the use of ancilla qubits in intermediate steps.</span></span> <span data-ttu-id="50e79-151">따라서 라고의 시뮬레이션 알고리즘을 사용자 정의 형식으로 패키지 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-151">Thus we package simulation algorithms in the canon as the user-defined type</span></span>

```qsharp
newtype SimulationAlgorithm = ((Double, EvolutionGenerator, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="50e79-152">첫 번째 매개 변수 `Double` 시뮬레이션의 시간입니다. [데이터 구조의](xref:microsoft.quantum.libraries.data-structures)동적 생성기 표현 섹션에서 설명 하는 두 번째 매개 변수 `EvolutionGenerator`는와 함께 제공 되는 시간 독립적 Hamiltonian의 기존 설명입니다. Hamiltonian의 각 용어를 퀀텀 회로에서 시뮬레이션할 수 있는 방법에 대 한 지침입니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-152">The first parameter `Double` is the time of simulation, the second parameter `EvolutionGenerator`, covered in the Dynamical Generator Representation section of [data-structures](xref:microsoft.quantum.libraries.data-structures), is a classical description of a time-independent Hamiltonian packaged with instructions on how each term in the Hamiltonian may be simulated by a quantum circuit.</span></span> <span data-ttu-id="50e79-153">이러한 형식의 형식에는 두 번째 매개 변수 `Qubit[]`(시뮬레이션 된 시스템의 퀀텀 상태를 저장 하는 레지스터)에 $e ^ {-iHt} $가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-153">Types of this form approximate the unitary operation $e^{-iHt}$ on the third parameter `Qubit[]`, which is the register storing the quantum state of the simulated system.</span></span> <span data-ttu-id="50e79-154">시간에 따라 달라 지는 경우에도 `EvolutionSchedule` 형식으로 사용자 정의 형식을 정의 합니다 .이 형식은 시간이 종속 된 Hamiltonian에 대 한 기존 설명입니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-154">Similarly for the time-dependent case, we define a user-defined type with an `EvolutionSchedule` type instead, which is a classical description of a time-dependent Hamiltonian.</span></span>

```qsharp
newtype TimeDependentSimulationAlgorithm = ((Double, EvolutionSchedule, Qubit[]) => Unit : Adjoint, Controlled);
```

<span data-ttu-id="50e79-155">예를 들어, 각 지 수에서 시뮬레이션 기간을 수정 하 `trotterStepSize` 매개 변수를 사용 하 여 Trotter-Suzuki 분해를 호출 하 고 원하는 통합자의 주문에 대 한 `trotterOrder` 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-155">As an example, the Trotter-Suzuki decomposition may be called using the following canon functions, with parameters `trotterStepSize` modifying the duration of simulation in each exponential, and `trotterOrder` for the order of the desired integrator.</span></span>

```qsharp
function TrotterSimulationAlgorithm(
    trotterStepSize: Double, 
    trotterOrder: Int) 
    : SimulationAlgorithm {
    ...
}
function TimeDependentTrotterSimulationAlgorithm(
    trotterStepSize: Double, 
    trotterOrder: Int) 
    : TimeDependentSimulationAlgorithm {
    ...
}
```

> [!TIP]
> <span data-ttu-id="50e79-156">시뮬레이션 라이브러리의 응용 프로그램은 샘플에서 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-156">Applications of the simulation library are covered in the samples.</span></span> <span data-ttu-id="50e79-157">`SimulationAlgorithm`를 사용 하는 Ising 모델의 단계 예측에 대해서는 [ **IsingPhaseEstimation** 샘플](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingPhaseEstimation)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="50e79-157">For phase estimation in the Ising model using `SimulationAlgorithm`, please see the [**IsingPhaseEstimation** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingPhaseEstimation).</span></span>
> <span data-ttu-id="50e79-158">`TimeDependentSimulationAlgorithm`를 사용 하는 Ising 모델의 adiabatic 상태 준비는 [ **AdiabaticIsing** 샘플](https://github.com/Microsoft/Quantum/tree/master/Samples/src/AdiabaticIsing)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="50e79-158">For adiabatic state preparation in the Ising model using `TimeDependentSimulationAlgorithm`, please see the [**AdiabaticIsing** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/AdiabaticIsing).</span></span>


### <a name="adiabatic-state-preparation--phase-estimation"></a><span data-ttu-id="50e79-159">Adiabatic 상태 준비 & 단계 예측</span><span class="sxs-lookup"><span data-stu-id="50e79-159">Adiabatic State Preparation & Phase Estimation</span></span> ###

<span data-ttu-id="50e79-160">Hamiltonian 시뮬레이션의 한 가지 일반적인 응용 프로그램은 adiabatic 상태 준비입니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-160">One common application of Hamiltonian simulation is adiabatic state preparation.</span></span> <span data-ttu-id="50e79-161">여기에는 두 개의 Hamiltonians $H\_{\text{start}} $ 및 $H\_{\text{start}} $과, Hamiltonian $H\_{\text{start}} $의 그라운드 상태에 해당 하는 퀀텀 상태 $ \ket{\psi (0)} $가 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-161">Here, one is provided with two Hamiltonians $H\_{\text{start}}$ and $H\_{\text{end}}$, and a quantum state $\ket{\psi(0)}$ that is a ground state of the start Hamiltonian $H\_{\text{start}}$.</span></span> <span data-ttu-id="50e79-162">일반적 $H으로 $ \ket{\psi (0)} $는 계산 기준 상태 $ \ket{0\cdots 0} $로 쉽게 준비할 수 있도록 {\text{start}} $\_를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-162">Typically, $H\_{\text{start}}$ is chosen such that $\ket{\psi(0)}$ is easy to prepare from a computational basis state $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="50e79-163">시간이 종속 된 시뮬레이션 문제에서 이러한 Hamiltonians을 보간 하는 경우 sufficientl {\text{end}} $\_$H 최종 Hamiltonian의 그라운드 상태에서 확률이 높은 종료 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-163">By interpolating between these Hamiltonians in the time-dependent simulation problem sufficientl slowly, it is possible to end up, with high probability, in a ground state of the final Hamiltonian $H\_{\text{end}}$.</span></span> <span data-ttu-id="50e79-164">Hamiltonian 그라운드 상태에 대 한 좋은 근사치을 준비 하는 것은 시간에 종속 된 Hamiltonian 시뮬레이션 알고리즘에 대해 서브루틴으로 호출 하 여 이러한 방식으로 진행 될 수 있지만, 다른 개념적으로 variational 양자와 같은 다른 방법으로 eigensolver 찾기가 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-164">Though preparing good approximations to Hamiltonian ground states could proceed in this manner by calling upon on time-dependent Hamiltonian simulation algorithms as a subroutine, other conceptually different approaches such as the variational quantum eigensolver are possible.</span></span>

<span data-ttu-id="50e79-165">그러나 퀀텀 화학의 또 다른 응용 프로그램은 화학 반응의 중간 단계를 나타내는 Hamiltonians의 그라운드 상태 에너지를 추정 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-165">Yet another application ubiquitous in quantum chemistry is estimating the ground state energy of Hamiltonians representing the intermediate steps of chemical reaction.</span></span> <span data-ttu-id="50e79-166">예를 들어 이러한 체계는 adiabatic 상태 준비를 사용 하 여 그라운드 상태를 만든 다음, 제한 된 오류와 함께이 에너지를 추출 하는 단계 예측의 서브루틴으로 시간 독립적 Hamiltonian 시뮬레이션을 통합할 수 있습니다. 성공 확률입니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-166">Such a scheme could, for instance, rely on adiabatic state preparation to create the ground state, and then incorporate time-independent Hamiltonian simulation as a subroutine in phase estimation characterization to extract this energy with some finite error and probability of success.</span></span> 

<span data-ttu-id="50e79-167">시뮬레이션 알고리즘을 `SimulationAlgorithm` 사용자 정의 형식으로 추상화 하 여 기능을 더욱 정교한 퀀텀 알고리즘에 편리 하 게 통합할 수 `TimeDependentSimulationAlgorithm`.</span><span class="sxs-lookup"><span data-stu-id="50e79-167">Abstracting simulation algorithms as the user-defined types `SimulationAlgorithm` and `TimeDependentSimulationAlgorithm` allow us to conveniently incorporate their functionality into more sophisticated quantum algorithms.</span></span> <span data-ttu-id="50e79-168">이는 일반적으로 사용 되는 이러한 서브루틴에 대해 동일한 작업을 motivates 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-168">This motivates us to do the same for these commonly used subroutines.</span></span>

<span data-ttu-id="50e79-169">따라서 편리한 함수를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-169">Thus we define the convenient function</span></span>

```qsharp
function InterpolatedEvolution(
        interpolationTime: Double, 
        evolutionGeneratorStart: EvolutionGenerator,
        evolutionGeneratorEnd: EvolutionGenerator,
        timeDependentSimulationAlgorithm: TimeDependentSimulationAlgorithm)
        : (Qubit[] => Unit is Adj + Ctl) {
        ...
}
 
```

<span data-ttu-id="50e79-170">이렇게 하면 adiabatic 상태 준비의 모든 단계를 구현 하는 단일 작업이 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-170">This returns a unitary operation that implements all steps of adiabatic state preparation.</span></span> <span data-ttu-id="50e79-171">첫 번째 매개 변수 `interpolatedTime`는 두 번째 매개 변수 `evolutionGeneratorStart` 설명 하는 시작 Hamiltonian와 세 번째 매개 변수 `evolutionGeneratorEnd`에서 설명 하는 end Hamiltonian 간에 선형으로 보간 하는 시간을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-171">The first parameter `interpolatedTime` defines the time over which we linearly interpolate between the start Hamiltonian described by the second parameter `evolutionGeneratorStart` and the end Hamiltonian described by the third parameter `evolutionGeneratorEnd`.</span></span> <span data-ttu-id="50e79-172">네 번째 매개 변수 `timeDependentSimulationAlgorithm`은 시뮬레이션 알고리즘을 선택 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-172">The fourth parameter `timeDependentSimulationAlgorithm` is where one makes the choice of simulation algorithm.</span></span> <span data-ttu-id="50e79-173">`interpolatedTime` 시간이 충분 한 경우 초기 접지 상태는 시간에 따라 좌우 되는 시뮬레이션 전체에 걸쳐 Hamiltonian의 순간 그라운드 상태로 유지 되므로 end Hamiltonian의 그라운드 상태로 종료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-173">Note that if `interpolatedTime` is long enough, an initial ground state remains an instantaneous ground state of the Hamiltonian over the entire duration of time-dependent simulation, and thus ends in the ground state of the end Hamiltonian.</span></span>

<span data-ttu-id="50e79-174">또한 일반적인 퀀텀 화학 실험의 모든 단계를 자동으로 수행 하는 유용한 작업을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-174">We also define a helpful operation that automatically performs all steps of a typical quantum chemistry experiment.</span></span> <span data-ttu-id="50e79-175">예를 들어 다음과 같이 adiabatic 상태 준비로 생성 된 상태의 에너지 추정치를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-175">For instance we have the following, which returns an energy estimate of the state produced by adiabatic state preparation:</span></span>

```qsharp
operation AdiabaticStateEnergyEstimate( 
    nQubits : Int, 
    statePrepUnitary: (Qubit[] => Unit),
    adiabaticUnitary: (Qubit[] => Unit),
    qpeUnitary: (Qubit[] => Unit is Adj + Ctl),
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double)) 
    : Double {
...
}
```

<span data-ttu-id="50e79-176">`nQubits`는 초기 퀀텀 상태를 인코딩하는 데 사용 되는 수 비트 수입니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-176">`nQubits` is the number of qubits used to encode the initial quantum state.</span></span> <span data-ttu-id="50e79-177">`statePrepUnitary` 계산 기준 $ \ket{0\cdots 0} $에서 시작 상태를 준비 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-177">`statePrepUnitary` prepares the start state from the computational basis $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="50e79-178">`adiabaticUnitary`은 `InterpolatedEvolution` 함수에서 생성 된 것과 같은 adiabatic 상태 준비를 구현 하는 단일 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-178">`adiabaticUnitary` is the unitary operation that implements adiabatic state preparation, such as produced by the  `InterpolatedEvolution` function.</span></span> <span data-ttu-id="50e79-179">`qpeUnitary`은 결과 퀀텀 상태에서 단계 예측을 수행 하는 데 사용 되는 단일 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-179">`qpeUnitary` is the unitary operation that is used to perform phase estimation on the resulting quantum state.</span></span> <span data-ttu-id="50e79-180">`phaseEstAlgorithm` 단계 추정 알고리즘을 선택 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-180">`phaseEstAlgorithm` is our choice of phase estimation algorithm.</span></span>

> [!TIP]
> <span data-ttu-id="50e79-181">Adiabatic 상태 준비의 응용 프로그램은 샘플에 설명 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-181">Applications of adiabatic state preparation are covered in the samples.</span></span> <span data-ttu-id="50e79-182">Adiabatic 상태 준비의 수동 구현을 사용 하는 Ising 모델 및 `AdiabaticEvolution` 함수 사용에 대 한 자세한 내용은 [ **AdiabaticIsing** 샘플](https://github.com/Microsoft/Quantum/tree/master/Samples/src/AdiabaticIsing)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="50e79-182">For the Ising model using a manual implementation of adiabatic state preparation versus using the `AdiabaticEvolution` function, please see the [**AdiabaticIsing** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/AdiabaticIsing).</span></span>
> <span data-ttu-id="50e79-183">Ising 모델에서 단계 예측 및 adiabatic 상태 준비는 [ **IsingPhaseEstimation** 샘플](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingPhaseEstimation)을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="50e79-183">For phase estimation and adiabatic state preparation in the Ising model, please see the [**IsingPhaseEstimation** sample](https://github.com/Microsoft/Quantum/tree/master/Samples/src/IsingPhaseEstimation).</span></span>

> [!TIP]
> <span data-ttu-id="50e79-184">[분자 Hydrogen의 시뮬레이션](https://github.com/Microsoft/Quantum/tree/master/Samples/src/H2SimulationCmdLine) 은 흥미로운 간단한 샘플입니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-184">The [simulation of molecular Hydrogen](https://github.com/Microsoft/Quantum/tree/master/Samples/src/H2SimulationCmdLine) is an interesting and brief sample.</span></span> <span data-ttu-id="50e79-185">모델 및 실험적 결과가 [O'Malley et](https://arxiv.org/abs/1512.06860) 에 보고 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-185">The model and experimental results reported in [O'Malley et. al.](https://arxiv.org/abs/1512.06860)</span></span> <span data-ttu-id="50e79-186">Pauli 행렬이 필요 하 고 $ \hat H = g\_{0}합니다. I\_0I\_1 + g\_1 {Z\_0} + g\_2 {Z\_1} + g\_3 {Z\_0} {Z\_1} + g\_4 {Y\_0} {Y\_1} + g\_5 {X\_0} {X\_1} $입니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-186">only requires Pauli matrices and takes the form $\hat H = g\_{0}I\_0I\_1+g\_1{Z\_0}+g\_2{Z\_1}+g\_3{Z\_0}{Z\_1}+g\_4{Y\_0}{Y\_1}+g\_5{X\_0}{X\_1}$.</span></span> <span data-ttu-id="50e79-187">이는 두 Hydrogen 원소 사이의 거리 $R $에서 상수 $g $가 계산 되는 2 개의 비트 비트만을 필요로 하는 효과적인 Hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="50e79-187">This is an effective Hamiltonian only requiring only 2 qubits, where the constants $g$ are computed from the distance $R$ between the two Hydrogen atoms.</span></span> <span data-ttu-id="50e79-188">라고 함수를 사용 하 여 paulis는 unitaries로 변환 된 다음 Trotter-Suzuki 분해를 사용 하 여 짧은 기간에 걸쳐 발전 했습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-188">Using canon functions, the Paulis are converted to unitaries and then evolved over short periods of time using the Trotter-Suzuki decomposition.</span></span> <span data-ttu-id="50e79-189">Adiabatic 상태 준비를 사용 하지 않고 $H _2 $ 그라운드 상태에 대 한 적절 한 근사값을 만들 수 있으므로 canon의 단계 예측을 활용 하 여 직접 상태 에너지를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-189">A good approximation to the $H_2$ ground state can be created without using adiabatic state preparation, and so the ground state energy may be found directly by utilizing phase estimation from the canon.</span></span>

## <a name="shors-algorithm"></a><span data-ttu-id="50e79-190">Shor의 알고리즘</span><span class="sxs-lookup"><span data-stu-id="50e79-190">Shor's Algorithm</span></span> ##
<span data-ttu-id="50e79-191">Shor의 알고리즘은 현재 일반적으로 intractable 문제를 해결 하는 데 퀀텀 컴퓨터를 사용할 수 있다는 것을 보여 주므로 퀀텀 컴퓨팅에서 가장 중요 한 개발 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-191">Shor's algorithm remains one of the most significant developments in quantum computing because it showed that quantum computers could be used to solve important, currently classically intractable problems.</span></span>
<span data-ttu-id="50e79-192">Shor의 알고리즘은 퀀텀 컴퓨터를 사용 하 여 많은 수의 수를 제공 하는 빠른 방법을 제공 하며,이는 *팩터링*이라는 문제입니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-192">Shor's algorithm provides a fast way to factor large numbers using a quantum computer, a problem called *factoring*.</span></span>
<span data-ttu-id="50e79-193">수많은 현재 인 cryptosystems의 보안은 팩터링에 대 한 빠른 알고리즘이 없다는 가정을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-193">The security of many present-day cryptosystems is based on the assumption that no fast algorithm exists for factoring.</span></span>
<span data-ttu-id="50e79-194">따라서 Shor의 알고리즘은 퀀텀 전 세계의 보안을 고려 하는 방법에 큰 영향을 미칩니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-194">Thus Shor's algorithm has had a profound impact on how we think about security in a post-quantum world.</span></span>

<span data-ttu-id="50e79-195">Shor의 알고리즘은 하이브리드 알고리즘으로 간주할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-195">Shor's algorithm can be thought of as a hybrid algorithm.</span></span>
<span data-ttu-id="50e79-196">퀀텀 컴퓨터는 계산 하드 태스크를 수행 하는 데 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-196">The quantum computer is used to perform a computationally hard task known as period finding.</span></span>
<span data-ttu-id="50e79-197">그런 다음 기간 검색의 결과를 일반적으로 처리 하 여 요인을 예측 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-197">The results from period finding are then classically processed to estimate the factors.</span></span>
<span data-ttu-id="50e79-198">다음 두 단계를 검토 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-198">We review these two steps below.</span></span>

### <a name="period-finding"></a><span data-ttu-id="50e79-199">기간 찾기</span><span class="sxs-lookup"><span data-stu-id="50e79-199">Period Finding</span></span> ###

<span data-ttu-id="50e79-200">퀀텀 푸리에 변환 및 단계 예측의 작동 방식에 대해 살펴보았습니다 ( [퀀텀 알고리즘](xref:microsoft.quantum.libraries.standard.algorithms)참조), 이러한 도구를 사용 하 여 *기간 찾기*라는 일반적으로 하드 계산 문제를 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-200">Having seen how the quantum Fourier transform and phase estimation work (see [Quantum algorithms](xref:microsoft.quantum.libraries.standard.algorithms)), we can use these tools to solve a classically hard computational problem called *period finding*.</span></span>  <span data-ttu-id="50e79-201">다음 섹션에서는 팩터링 하는 기간 찾기를 적용 하는 방법을 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-201">In the next section, we will see how to apply period finding to factoring.</span></span>

<span data-ttu-id="50e79-202">$ 및 $N $ $a 두 개의 정수를 지정 하는 경우 ($a < N $), order 찾기가 라고도 하는 기간 찾기를 목표로 하는 $r $ of $a $의 _주문_ $N을 찾는 것입니다. 여기서 $r $는 $a ^ r \equiv 1 \text{Mod} N $와 같이 최소 양의 정수로 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-202">Given two integers $a$ and $N$, where $a<N$, the goal of period finding, also called order finding, is to find the _order_ $r$ of $a$ modulo $N$, where $r$ is defined to be the least positive integer such that $a^r \equiv 1 \text{ mod } N$.</span></span>  

<span data-ttu-id="50e79-203">퀀텀 컴퓨터를 사용 하 여 순서를 찾으려면 _a $: $ $ U_a\ket {x} \equiv \ket{(ax) \text{mod} N}의 단일 $U 연산자에 적용 되는 단계 추정 알고리즘을 사용할 수 있습니다. $ $ 고유 벡터 of $U _a $은 정수 $s $ 및 $0 \ leq s \text{r-$1에 대 한 것입니다. , $ $ \ket{x_s} \equiv 1/\sqrt{r} \sum\_{k = 0} ^ {r-1} e ^ {\frac{-2\pi i N o} {r}} \ket{a ^ k\text {mod} N}, $ $는 $U _a $의 _eigenstates_ 입니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-203">To find the order using a quantum computer, we can use the phase estimation algorithm applied to the following unitary operator $U_a$: $$ U_a\ket{x} \equiv \ket{(ax)\text{ mod }N} .$$ The eigenvectors of $U_a$ are for integer $s$ and $0\leq s \leq r - 1$, $$\ket{x_s} \equiv 1 / \sqrt{r} \sum\_{k=0}^{r-1} e^{\frac{-2\pi i sk}{r}} \ket{a^k\text{ mod }N},$$ are _eigenstates_ of $U_a$.</span></span>
<span data-ttu-id="50e79-204">$U _a $의 고유 값는 $ $ U\_a \ket{x\_s} = e ^ {2 \ pi i s/r} \ket{x\_s}입니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-204">The eigenvalues of $U_a$ are $$ U\_a \ket{x\_s} = e^{2\pi i s / r} \ket{x\_s} .</span></span> $$

<span data-ttu-id="50e79-205">따라서 단계 예측은 $e ^ {2 \ pi i s/r} $에서 고유 값를 출력 합니다. 여기서 $r $은 $s/r $의 [연속 된 분수](https://en.wikipedia.org/wiki/Continued_fraction) 를 사용 하 여 효율적으로 학습할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-205">Phase estimation thus outputs the eigenvalues $e^{2\pi i s / r}$ from which $r$ can be learned efficiently using [continued fractions](https://en.wikipedia.org/wiki/Continued_fraction) from $s / r$.</span></span>

<span data-ttu-id="50e79-206">퀀텀 기간 찾기를 위한 회로 다이어그램은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-206">The circuit diagram for quantum period finding is:</span></span>

![](./../../media/QPE.svg)

<span data-ttu-id="50e79-207">여기서 $2n $ \ket는 ${0}$로 초기화 되 고 $n $ 이상 비트는 $ \ket{1}$로 초기화 됩니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-207">Here $2n$ qubits are initialized to $\ket{0}$ and $n$ qubits are initialized to $\ket{1}$.</span></span>
<span data-ttu-id="50e79-208">판독기는 eigenstates를 포함 하는 퀀텀 레지스터가 $ \ket{1}$로 초기화 되는 이유를 궁금할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-208">The reader again may wonder why the quantum register to hold the eigenstates is initialized to $\ket{1}$.</span></span>
<span data-ttu-id="50e79-209">$R $의 순서를 알 수 없으므로 $ \ket{x_s} $ 상태를 직접 준비할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-209">As one does not know the order $r$ in advance, we cannot actually prepare $\ket{x_s}$ states directly.</span></span>
<span data-ttu-id="50e79-210">다행히 $1/\ sqrt {r} \sum\_{s = 0} ^ {r-1} \ket{x\_s} = \ket{1}$로 전환 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-210">Luckily, it turns out that $1/\sqrt{r} \sum\_{s=0}^{r-1} \ket{x\_s} = \ket{1}$.</span></span>
<span data-ttu-id="50e79-211">$ \Ket{x} $!을 (를) 실제로 준비 하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-211">We don't need to actually prepare $\ket{x}$!</span></span>
<span data-ttu-id="50e79-212">$ \Ket{1}$ 상태에서 $n $ 이상 비트의 퀀텀 레지스터를 준비할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-212">We can just prepare a quantum register of $n$ qubits in state $\ket{1}$.</span></span> 

<span data-ttu-id="50e79-213">회로에는 QFT와 여러 개의 제어 된 게이트가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-213">The circuit contains the QFT and several controlled gates.</span></span>
<span data-ttu-id="50e79-214">QFT 게이트가 [이전](xref:microsoft.quantum.libraries.standard.algorithms)에 설명 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-214">The QFT gate has been described [previously](xref:microsoft.quantum.libraries.standard.algorithms).</span></span>
<span data-ttu-id="50e79-215">제어 하는 $U _a $ gate는 $ \ket{x} $를 $ \ket{(ax) \text{mod} N} $로 매핑하고, 해당 컨트롤은 $ \ket{1}$이 고 $ \ket{x} $를 $ \ket{x} $에 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-215">The controlled-$U_a$ gate maps $\ket{x}$ to $\ket{(ax)\text{ mod } N}$ if the control qubit is $\ket{1}$, and maps $\ket{x}$ to $\ket{x}$ otherwise.</span></span>

<span data-ttu-id="50e79-216">$ (A ^ nx) \text{mod} N $을 얻기 위해 일반적으로 _ {a ^ n} $를 $U 적용 하기만 하면 됩니다. 여기서는 $a ^ n \text{mod} N $를 계산 하 여 퀀텀 회로에 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-216">To achieve $(a^nx)\text{ mod } N$,  we can simply apply controlled-$U_{a^n}$, where we calculate $a^n \text{ mod } N$ classically to plug into the quantum circuit.</span></span>  
<span data-ttu-id="50e79-217">이러한 모듈식 산술 연산을 수행 하기 위한 회로는 [퀀텀 산술 설명서](./algorithms.md#arithmetic)에 설명 되어 있습니다. 특히 제어 되는 $U\_{a ^ i} $ 작업을 구현 하려면 모듈식 지 수 회로가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-217">The circuits to achieve such modular arithmetic have been described in the [quantum arithmetic documentation](./algorithms.md#arithmetic), specifically we require a modular exponentiation circuit to implement the controlled-$U\_{a^i}$ operations.</span></span>

<span data-ttu-id="50e79-218">위의 회로는 [퀀텀 단계 예측](xref:microsoft.quantum.characterization.quantumphaseestimation) 에 해당 하 고 주문 찾기를 명시적으로 사용 하도록 설정 하는 반면 필요한 것은 필요한 비트 수를 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-218">While the circuit above corresponds to [Quantum Phase Estimation](xref:microsoft.quantum.characterization.quantumphaseestimation) and explicitly enables order finding, we can reduce the number of qubits required.</span></span> <span data-ttu-id="50e79-219">[ArXiv: Beauregard/0205095v3의 8 페이지에](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8)설명 된 대로 주문 찾기에 대해의 방법을 따르거나 Microsoft에서 제공 하는 단계 예측 루틴 중 하나를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-219">We can either follow Beauregard's method for order finding as described [on Page 8 of arXiv:quant-ph/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8), or use one of the phase estimation routines available in Microsoft.Quantum.Canon.</span></span> <span data-ttu-id="50e79-220">예를 들어 [강력한 단계 예측](xref:microsoft.quantum.characterization.robustphaseestimation) 은 또 하나의 추가 비트를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-220">For example, [Robust Phase Estimation](xref:microsoft.quantum.characterization.robustphaseestimation) also uses one extra qubit.</span></span>
 
### <a name="factoring"></a><span data-ttu-id="50e79-221">프로필과</span><span class="sxs-lookup"><span data-stu-id="50e79-221">Factoring</span></span> ###
<span data-ttu-id="50e79-222">팩터링의 목표는 정수 $N $의 두 소수 요소를 확인 하는 것입니다. 여기서 $N $는 $n $ 비트 숫자입니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-222">The goal of factoring is to determine the two prime factors of integer $N$, where $N$ is an $n$-bit number.</span></span>  
<span data-ttu-id="50e79-223">팩터링은 아래에 설명 된 단계로 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-223">Factoring consists of the steps described below.</span></span> <span data-ttu-id="50e79-224">이러한 단계는 클래식 전처리 루틴 (1-4)의 세 부분으로 나뉩니다. $a \text{mod} N $ (5)의 순서를 확인 하는 퀀텀 컴퓨팅 루틴 그리고 일반적인 후 처리 루틴은 순서 (6-9)에서 프라임 요인을 파생 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-224">The steps are split into three parts: a classical preprocessing routine (1-4); a quantum computing routine to find the order of $a \text{ mod } N$ (5); and a classical postprocessing routine to derive the prime factors from the order (6-9).</span></span>

<span data-ttu-id="50e79-225">기존 전처리 루틴은 다음 단계로 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-225">The classical preprocessing routine consists of the following steps:</span></span>
1. <span data-ttu-id="50e79-226">$N $가 짝수 이면 프라임 비율 $2 $를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-226">If $N$ is even, return the prime factor $2$.</span></span>
2. <span data-ttu-id="50e79-227">$N = p ^ q $ $p \geq1 $, $q \geq1 $의 경우 소수 $p $를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-227">If $N=p^q$ for $p\geq1$, $q\geq2$, return the prime factor $p$.</span></span>  <span data-ttu-id="50e79-228">이 단계는 일반적으로 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-228">This step is performed classically.</span></span>
3. <span data-ttu-id="50e79-229">$1 < $a < N-$1 인 난수를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-229">Choose a random number $a$ such that $1 < a < N-1$.</span></span>
4. <span data-ttu-id="50e79-230">$ \Text{gcd} (a, N) > 1 $ 이면 프라임 요소 $ \text{gcd} (a, N) $를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-230">If $\text{gcd}(a,N)>1$, return the prime factor $\text{gcd}(a,N)$.</span></span> <span data-ttu-id="50e79-231">이 단계는 함으로써 유클리드 알고리즘을 사용 하 여 계산 됩니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-231">This step is computed using Euclid's algorithm.</span></span>
<span data-ttu-id="50e79-232">소수 요소가 반환 되지 않은 경우에는 퀀텀 루틴이 진행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-232">If no prime factor has been returned, we proceed to the quantum routine:</span></span>
5. <span data-ttu-id="50e79-233">퀀텀 기간 찾기 알고리즘을 호출 하 여 $r $ of $a \text{mod} N $의 순서를 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-233">Call the quantum period finding algorithm to calculate the order $r$ of $a \text{ mod } N$.</span></span> <span data-ttu-id="50e79-234">클래식 후 처리 루틴에서 $r $를 사용 하 여 프라임 요인을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-234">Use $r$ in the classical postprocessing routine to determine the prime factors:</span></span>
6. <span data-ttu-id="50e79-235">$R $가 홀수 이면 전처리 단계 (3)로 돌아갑니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-235">If $r$ is odd, go back to preprocessing step (3).</span></span>
7. <span data-ttu-id="50e79-236">$R $가 짝수이 고 $a ^ {r/2} =-1 \ 텍스트 {mod} N $ 인 경우 전처리 단계 (3)로 돌아갑니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-236">If $r$ is even and $a^{r/2} = -1\text{ mod }N$, go back to preprocessing step (3).</span></span>
8. <span data-ttu-id="50e79-237">$ \Text{gcd} (a ^ {r/2} + 1, N) $이 특수 한 인수 $N $ 인 경우 $ \text{gcd} (a ^ {r/2} + 1, N) $를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-237">If $\text{gcd}(a^{r/2}+1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}+1, N)$.</span></span>
9. <span data-ttu-id="50e79-238">$ \Text{gcd} (a ^ {r/2}-1, N) $이 특수 한 인수 $N $ 인 경우 $ \text{gcd} (a ^ {r/2}-1, N) $를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-238">If $\text{gcd}(a^{r/2}-1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}-1, N)$.</span></span>


<span data-ttu-id="50e79-239">팩터링 알고리즘은 확률 수 있습니다. 즉, $ $r $가 짝수이 고 $a ^ {r/2} \neq-1 \neq mod} N $ 인 확률을 사용 하 여 프라임 계수를 생성 하는 것으로 표시 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-239">The factoring algorithm is probabilistic: it can been shown that with probability at least one half that $r$ will be even and $a^{r/2} \neq -1 \text{ mod }N$, thus producing a prime factor.</span></span>  <span data-ttu-id="50e79-240">[자세한 내용은](xref:microsoft.quantum.more-information) [shor의 원래 용지](https://doi.org/10.1109/SFCS.1994.365700) 또는의 *기본 퀀텀 계산* 텍스트 중 하나를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="50e79-240">(See [Shor's original paper](https://doi.org/10.1109/SFCS.1994.365700) for details, or one of the *Basic quantum computing* texts in [For more information](xref:microsoft.quantum.more-information)).</span></span>
<span data-ttu-id="50e79-241">소수 요소가 반환 되지 않는 경우에는 (1) 단계에서 알고리즘을 반복 하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-241">If a prime factor is not returned, then we simply repeat the algorithm from step (1).</span></span>  <span data-ttu-id="50e79-242">$ 시도를 $n 후에는 모든 시도가 실패 한 확률은 최대 $2 ^ {-n} $입니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-242">After $n$ tries, the probability that every attempt has failed is at most $2^{-n}$.</span></span>
<span data-ttu-id="50e79-243">따라서 알고리즘을 적은 횟수로 성공 하는 것은 거의 보장 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="50e79-243">Thus after repeating the algorithm a small number of times success is virtually assured.</span></span>
