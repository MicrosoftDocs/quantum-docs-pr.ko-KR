---
title: 'Q # 식'
description: 'Q #에서 상수, 변수, 연산자, 작업 및 함수를 식으로 지정, 참조 및 결합 하는 방법을 이해 합니다.'
author: QuantumWriter
ms.author: Alan.Geller@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.language.expressions
ms.openlocfilehash: 095be52af27f827f3e52d39a70702f50d6d59ee8
ms.sourcegitcommit: db23885adb7ff76cbf8bd1160d401a4f0471e549
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/01/2020
ms.locfileid: "82683919"
---
# <a name="expressions"></a>표현식

## <a name="grouping"></a>Grouping(그룹화)

식이 지정 된 경우 괄호로 묶인 동일한 식이 동일한 형식의 식입니다.
예를 들어 `(7)` ,은 `Int` 식 `([1,2,3])` 이며는 `Int`s `((1,2))` 형식의 식이고는 형식이 `(Int, Int)`인 식입니다.

[형식 모델](xref:microsoft.quantum.language.type-model#tuple-types) 에 설명 된 단순 값과 단일 요소 튜플의 동등성은 그룹 및 `(6)` `(6)` 단일 요소 튜플로 인 한 모호성을 제거 합니다.

## <a name="symbols"></a>기호

형식의 `'T` 값에 바인딩하거나 할당 된 기호의 이름은 형식의 `'T`식입니다.
예를 들어, 기호가 `count` 정수 값 `5`에 바인딩되면 `count` 는 정수 식입니다.

## <a name="numeric-expressions"></a>숫자 식

숫자 식은, `Int` `BigInt`또는 `Double`형식의 식입니다.
즉, 정수 또는 부동 소수점 숫자 중 하나입니다.

`Int`Q #의 리터럴은 후행 "l" 또는 "L"이 필요 하거나 허용 되지 않는다는 점을 제외 하 고 c #의 정수 리터럴과 동일 합니다.
16 진수 및 이진 정수는 각각 "0x" 및 "0b" 접두사를 사용 하 여 지원 됩니다.

`BigInt`Q #의 리터럴은 .NET의 큰 정수 문자열과 같으며 그 뒤에는 "l" 또는 "L"이 있습니다.
16 진수 큰 정수는 "0x" 접두사를 사용 하 여 지원 됩니다.
따라서 다음은 리터럴의 모든 유효한 사용입니다 `BigInt` .

```qsharp
let bigZero = 0L;
let bigHex = 0x123456789abcdef123456789abcdefL;
let bigOne = bigZero + 1L;
```

`Double`Q #의 리터럴은 후행 "d" 또는 "D"가 필요 하거나 허용 되지 않는다는 점을 제외 하 고 c #의 이중 리터럴과 동일 합니다.

모든 요소 형식의 배열 식이 `Int` 지정 된 경우 `Length` 기본 제공 함수를 사용 하 여 식을 구성 하 `(` 고, 배열 식이 괄호로 묶여 있으며 `)`,를 사용 하 여 식을 만들 수 있습니다.
예를 들어가 `a` 배열에 바인딩된 경우 `Length(a)` 는 정수 식입니다.
가 `b` `Int[][]`정수 배열의 `Length(b)` 배열인 경우는의 `b`하위 배열 수이 고 `Length(b[1])` 은의 `b`두 번째 하위 배열에 있는 정수 수입니다.

동일한 형식의 두 숫자 식이 지정 된 경우 이항 `+`연산자, `-`, `*`및 `/` 를 사용 하 여 새 숫자 식을 만들 수 있습니다.
새 식의 형식은 구성 식의 형식과 동일 합니다.

두 개의 정수 식이 지정 되 면 이항 `^` 연산자 (power)를 사용 하 여 새 정수 식을 만들 수 있습니다.
마찬가지로를 `^` 두 개의 double 식과 함께 사용 하 여 새 double 식을 만들 수 있습니다.
마지막으로 `^` ,은 왼쪽에서 큰 정수를 사용 하 고 오른쪽에는 정수를 사용 하 여 새 큰 정수 식을 만들 수 있습니다.
이 경우 두 번째 매개 변수는 32 비트에 맞아야 합니다. 그렇지 않으면 런타임 오류가 발생 합니다.

두 개의 정수 또는 큰 정수 식이 지정 된 `%` 경우 (모듈러스), `&&&` (비트 and), `|||` (비트 or) 또는 `^^^` (비트 XOR) 연산자를 사용 하 여 새 정수 또는 큰 정수 식의 형식을 지정할 수 있습니다.

왼쪽에 정수 또는 큰 정수 식이 있고 오른쪽에 정수 식이 지정 된 경우 `<<<` (산술 왼쪽 시프트) 또는 `>>>` (산술 오른쪽 시프트) 연산자를 사용 하 여 왼쪽 식과 동일한 형식의 새 식을 만들 수 있습니다.

이동 작업에 대 한 두 번째 매개 변수 (이동 크기)는 0 보다 크거나 같아야 합니다. 음수 시프트 금액의 동작은 정의 되지 않습니다.
시프트 연산의 이동 양은 32 비트에도 맞아야 합니다. 그렇지 않으면 런타임 오류가 발생 합니다.
이동할 숫자가 정수 이면 시프트 금액이 해석 `mod 64`됩니다. 즉, 1의 교대조와 65의 시프트는 동일한 효과를 가집니다.

정수 및 큰 정수 값 모두에 대해 시프트는 산술 연산입니다.
음수 값을 왼쪽 이나 오른쪽으로 이동 하면 음수가 반환 됩니다.
즉, 한 단계를 왼쪽 또는 오른쪽으로 이동 하는 것은 각각 2로의 곱하기 또는 나누기와 정확히 동일 합니다.

정수 나누기와 정수 모듈러스는 c #과 같은 음수에 대해 동일한 동작을 수행 합니다.
즉, `a % b` 는 항상와 `a` `b * (a / b) + a % b` 동일한 기호를 가집니다 `a`.이는 항상와 동일 합니다.
예를 들어:

 `A` | `B` | `A / B` | `A % B`
---------|----------|---------|---------
 5 | 2 | 2 | 1
 5 | -2 | -2 | 1
 -5 | 2 | -2 | -1
 -5 | -2 | 2 | -1

큰 정수 나누기와 모듈러스는 동일한 방식으로 작동 합니다.

숫자 식이 지정 된 경우 `-` 단항 연산자를 사용 하 여 새 식을 지정할 수 있습니다.
새 식은 구성 식과 동일한 형식이 됩니다.

정수 또는 큰 정수 식이 지정 된 경우 `~~~` (비트 보수) 단항 연산자를 사용 하 여 동일한 유형의 새 식을 설정할 수 있습니다.

## <a name="boolean-expressions"></a>부울 식

두 `Bool` 리터럴 값은 `true` 및 `false`입니다.

동일한 기본 형식의 두 식이 지정 된 경우 `==` 및 `!=` 이항 연산자를 사용 하 여 `Bool` 식을 생성할 수 있습니다.
식은 두 식이 같으면 true이 고, 그렇지 않으면 false입니다.

사용자 정의 형식의 값을 비교할 수 없습니다. 래핑 해제 된 값만 비교할 수 있습니다. 예를 들어 "래핑 해제" 연산자 `!` ( [Q # 형식 모델 페이지](xref:microsoft.quantum.language.type-model#user-defined-types)에서 설명)를 사용 하는 경우

```qsharp
newtype WrappedInt = Int;     // Yes, this is a contrived example
let x = WrappedInt(1);
let y = WrappedInt(2);
let z = x! == y!;             // This will compile and yield z = false.
let t = x == y;               // This will cause a compiler error.
```

값에 대 `Qubit` 한 같음 비교는 id 같음입니다. 즉, 두 식이 동일한의 비트를 식별 하는지 여부입니다.
이 비교로 두 비트의 상태를 비교, 액세스, 측정 또는 수정할 수 없습니다.

반올림 결과 때문 `Double` 에 값에 대 한 같음 비교가 잘못 될 수 있습니다.
예를 `49.0 * (1.0/49.0) != 1.0`들면입니다.

두 숫자 식이 지정 된 경우 이항 `>`연산자, `<`, `>=`및 `<=` 를 사용 하 여 첫 번째 식이 두 번째 식 보다 크거나 같고 보다 작거나 같은 경우 true 인 새 부울 식을 생성할 수 있습니다.

부울 식을 두 개 지정 하는 `and` 경우 `or` 및 이항 연산자를 사용 하 여 두 식 중 하나 (응답 또는 둘 다)가 true 인 경우 true 인 새 부울 식을 생성할 수 있습니다.

부울 식이 지정 된 경우 `not` 단항 연산자를 사용 하 여 구성 식이 false 인 경우 true 인 새 부울 식을 생성할 수 있습니다.

## <a name="string-expressions"></a>문자열 식

Q #에서는 `fail` 문과 `Log` 표준 함수에 문자열을 사용할 수 있습니다.

Q #의 문자열은 리터럴 또는 보간된 문자열입니다.
문자열 리터럴은 대부분의 언어에서 간단한 문자열 리터럴과 유사 `"`합니다. 큰따옴표 안의 유니코드 문자 시퀀스입니다.
문자열 내 `\` 에서 백슬래시 문자를 사용 하 여 큰따옴표 문자를 이스케이프 하 고 새 줄을로 `\n`, 캐리지 리턴을로 `\r`, 탭을로 삽입할 수 있습니다. `\t`
예:

```qsharp
"\"Hello world!\", she said.\n"
```

문자열 보간에 대 한 Q # 구문은 c # 7.0 구문의 하위 집합입니다. Q #에서는 축 자 (여러 줄) 보간된 문자열을 지원 하지 않습니다.
C # 구문에 대 한 [*보간된 문자열*](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/interpolated-strings) 을 참조 하세요.

보간된 문자열 내부의 식은 c # 구문이 아니라 Q # 구문을 따릅니다.
유효한 Q # 식은 보간된 문자열에 나타날 수 있습니다.

## <a name="qubit-expressions"></a>Bit 식

유일한 `Qubit` 식은 `Qubit` `Qubit` 배열의 배열 요소 또는 값에 바인딩되는 기호입니다.
리터럴이 없습니다 `Qubit` .

## <a name="pauli-expressions"></a>Pauli 식

,, `Pauli` 및 `PauliZ`의 `PauliI`네 `PauliX`가지 `PauliY`값은 모두 유효한 `Pauli` 식입니다.

그 외에도 유일한 `Pauli` 식은 `Pauli` `Pauli` 배열의 배열 요소 또는 값에 바인딩되는 기호입니다.

## <a name="result-expressions"></a>결과 식

두 `Result` 값 `One` 및 `Zero`는 유효한 `Result` 식입니다.

그 외에도 유일한 `Result` 식은 `Result` `Result` 배열의 배열 요소 또는 값에 바인딩되는 기호입니다.
특히 `One` 는 정수와 `1`동일 하지 않으며 두 요소 사이에 직접 변환 되지 않습니다.
및 `Zero` `0`의 경우에도 마찬가지입니다.

## <a name="range-expressions"></a>범위 식

3 개의 `Int` 식 `start` `step`, 및 `stop`가 지정 된 `start .. step .. stop` 경우이 전달 될 때까지 `start` `start+step` `start+step+step` `stop` 첫 번째 요소가이 고, 두 번째 요소가이 고, 세 번째 요소가 인 범위 식입니다.
예를 들어, `step` 가 양수인 경우 범위는 비어 있을 수 있습니다 `stop < start`.
범위의 `stop` 마지막 요소는 `start` 와 `stop` 의 차이가의 `step`정수 배수가 면가 됩니다. 즉, 범위는 양쪽 끝에 포함 됩니다.

`Int` 두 `start` 식 `stop`및 `start .. stop` 가 지정 된 경우는와 같은 범위 식입니다. `start .. 1 .. stop`
가 보다 `start`작은 경우 `step` `stop` 에도 암시는 + 1입니다. 이 경우 범위는 비어 있습니다.

몇 가지 예제 범위는 다음과 같습니다.

- `1..3`은 1, 2, 3의 범위입니다.
- `2..2..5`는 범위 2, 4입니다.
- `2..2..6`는 2, 4, 6 범위입니다.
- `6..-2..2`는 6, 4, 2 범위입니다.
- `2..1`는 빈 범위입니다.
- `2..6..7`는 범위 2입니다.
- `2..2..1`는 빈 범위입니다.
- `1..-1..2`는 빈 범위입니다.

## <a name="callable-expressions"></a>호출 가능 식

호출 가능 리터럴은 컴파일 범위에서 정의 된 작업 또는 함수의 이름입니다.
예를 들어 `X` 는 표준 라이브러리 `X` 작업 `Message` 을 참조 하는 작업 리터럴이어야,는 표준 라이브러리 `Message` 함수를 참조 하는 함수 리터럴입니다.

작업에서 `Adjoint` 함수를 지 원하는 경우 `Adjoint op` 는 연산 식입니다.
마찬가지로 작업에서 `Controlled` 함수를 지 원하는 경우 `Controlled op` 는 연산 식입니다.
이러한 식의 형식은 [함수](xref:microsoft.quantum.language.type-model#functors)에서 지정 합니다.

함수 (`Adjoint` 및 `Controlled`)는를 사용 하 여 `!` `[]`래핑 해제 연산자와 배열 인덱싱을 제외 하 고 다른 모든 연산자 보다 더 가깝게 바인딩합니다.
따라서 다음은 작업에서 사용 되는 함수를 지원 한다고 가정 하 여 모든 법률입니다.

```qsharp
Adjoint Op(qs)
Controlled Op(controls, targets)
Controlled Adjoint Op(controls, targets)
Adjoint WrappedOp!(qs)
```

호출 가능 리터럴은 값으로 사용 될 수 있습니다. 예를 들어 변수에 할당 하거나 다른 호출 가능으로 전달 합니다.
이 경우 호출 가능에 형식 매개 변수가 있으면 해당 매개 변수를 호출 가능 값의 일부로 제공 해야 합니다.
호출 가능 값은 지정 되지 않은 형식 매개 변수를 가질 수 없습니다.

예를 들어가 `Fun` 시그니처 `'T1->Unit`를 사용 하는 함수인 경우는 다음과 같습니다.

```qsharp
let f = Fun<Int>;            // f is Int->Unit.
SomeOtherFun(Fun<Double>);   // A Double->Unit is passed to SomeOtherFun.
let g = Fun;                 // This causes a compilation error.
SomeOtherFun(Fun);           // This also causes a compilation error.
```

## <a name="callable-invocation-expressions"></a>호출 가능 호출 식

호출 가능 식의 입력 형식에 대 한 호출 가능 (연산 또는 함수) 식과 튜플 식이 지정 된 경우 호출 식은 튜플 식을 호출 가능 식에 추가 하 여 구성 될 수 있습니다.
호출 식의 형식은 호출 가능 시그니처의 출력 형식입니다.

예를 들어가 `Op` 서명이 `((Int, Qubit) => Double)`포함 된 작업 인 경우 `Op(3, qubit1)` 는 형식의 `Double`식입니다.
마찬가지로가 시그니처 `Sin` `(Double -> Double)`를 사용 하는 함수인 경우 `Sin(0.1)` 는 형식의 `Double`식입니다.
마지막으로가 `Builder` 시그니처 `(Int -> (Int -> Int))`를 사용 하는 함수인 경우 `Builder(3)` 는에서 Int로의 함수입니다.

호출 가능 값 식의 결과를 호출 하려면 호출 가능 식 주위에 괄호 쌍을 추가 해야 합니다.
따라서 이전 단락에서 호출 `Builder` 결과를 호출 하려면 올바른 구문은 다음과 같습니다.

```qsharp
(Builder(3))(2)
```

형식 매개 변수가 있는 호출 가능를 호출할 때 실제 형식 매개 변수는 꺾쇠 괄호 `<` 내에서 호출 `>` 가능 식 뒤에 지정할 수 있습니다.
이는 일반적으로 Q # 컴파일러가 실제 형식을 유추 하므로 필요 하지 않습니다.
형식 매개 변수가 있는 인수가 지정 되지 않은 상태로 남아 있는 경우 부분 응용 프로그램에 필요 합니다 (아래 참조).
또한 다른 함수를 사용 하는 작업을 호출할 수 있는 경우에도 유용 합니다.

예를 들어, `Func` 에 시그니처가 `('T1, 'T2, 'T1) -> 'T2`있고 `Op1` , `Op2` 에 시그니처가 `(Qubit[] => Unit is Adj)`있고, `Op3` 가 첫 `(Qubit[] => Unit)`번째 인수로를 `Func` 사용 `Op1` 하 여를 호출 하 `Op2` 고,를 세 번째 `Op3` 인수로 호출 하는 시그니처가 있는 경우입니다.

```qsharp
let combinedOp = Func<(Qubit[] => Unit), (Qubit[] => Unit is Adj)>(Op1, Op2, Op3);
```

및 `Op3` `Op1` 에 다른 형식이 있으므로 형식 사양이 필요 합니다. 따라서 컴파일러는 사양을 사용 하지 않고이를 모호 하 게 처리 합니다.

### <a name="partial-application"></a>부분 응용 프로그램

호출 가능 식이 지정 된 경우 호출 가능에 인수의 하위 집합을 제공 하 여 새 호출 가능을 만들 수 있습니다.
이를 _부분 응용 프로그램_이라고 합니다.

Q #에서 부분적으로 적용 되는 호출 가능 인수에는 밑줄 ( `_`)을 사용 하 여 일반 호출 식을 작성 하는 방법으로 표현 됩니다.
결과로 생성 되는 호출 가능의 결과 형식은 기본 호출 가능 및 작업에 대 한 동일한 특수화와 동일 합니다.
부분 응용 프로그램의 입력 형식은 단순히 지정 된 인수가 제거 된 원래 형식입니다.

부분 응용 프로그램을 만들 때 변경 가능한 변수가 지정 된 인수로 전달 되 면 변수의 현재 값이 사용 됩니다.
나중에 변수 값을 변경 해도 부분 응용 프로그램에는 영향을 주지 않습니다.

예를 들어, `Op` 의 형식은 `((Int, ((Qubit, Qubit), Double)) => Unit is Adj)`다음과 같습니다.

- `Op(5,(_,_))`에는 `(((Qubit,Qubit), Double) => Unit is Adj)`형식, 등이 `Op(5,_)`있습니다.
- `Op(_,(_,1.0))`의 형식은 `((Int, (Qubit,Qubit)) => Unit is Adj)`입니다.
- `Op(_,((q1,q2),_))`의 형식은 `((Int,Double) => Unit is Adj)`입니다.
   여기서는 단일 튜플 동등성을 적용 했습니다.

부분적으로 적용 되는 호출 가능에서 컴파일러가 유추할 수 없는 형식 매개 변수를 포함 하는 경우 호출 사이트에서 제공 해야 합니다.
부분 응용 프로그램에는 지정 되지 않은 형식 매개 변수를 사용할 수 없습니다.

예를 들어, `Op` 의 형식은 `(('T1, Qubit, 'T1) => Unit : Adjoint)`다음과 같습니다.

```qsharp
let f1 = Op<Int>(_, qb, _); // f1 has type ((Int,Int) => Unit is Adj)
let f2 = Op(5, qb, _);      // f2 has type (Int => Unit is Adj)
let f3 = Op(_,qb, _);       // f3 generates a compilation error
```

### <a name="recursion"></a>재귀

Q # callables은 직접 또는 간접적으로 재귀적으로 사용할 수 있습니다.
즉, 작업 또는 함수가 자신을 호출 하거나 호출 가능 작업을 직접 또는 간접적으로 호출 하는 다른 호출 가능 함수를 호출할 수 있습니다.

그러나 재귀 사용에 대 한 두 가지 중요 한 설명은 다음과 같습니다.

- 작업에서 재귀를 사용 하면 특정 최적화에 방해가 될 수 있습니다.
  이는 알고리즘의 실행 시간에 상당한 영향을 미칠 수 있습니다.
- 실제 퀀텀 장치에서 실행 되는 경우 스택 공간이 제한 될 수 있으므로, 심층 재귀가 런타임 오류가 발생할 수 있습니다.
  특히 Q # 컴파일러 및 런타임에서는 마무리 재귀를 식별 하 고 최적화 하지 않습니다.

## <a name="tuple-expressions"></a>튜플 식

튜플 리터럴은 `(` 및 `)`로 묶인 적절 한 형식의 요소 식 시퀀스로, 쉼표로 구분 됩니다.
예를 들어 `(1, One)` 은 `(Int, Result)` 식입니다.

리터럴 이외의 튜플 식은 튜플 값에 바인딩된 기호, 튜플 배열의 배열 요소 및 튜플을 반환 하는 호출 가능 호출입니다.

## <a name="user-defined-type-expressions"></a>사용자 정의 형식 식

사용자 정의 형식의 리터럴은 형식 이름과 해당 형식의 기본 튜플 형식의 튜플 리터럴로 구성 됩니다.
예를 들어, `IntPair` 가를 기반으로 `(Int, Int)` `IntPair(2,3)` 하는 사용자 정의 형식인 경우는 해당 형식의 유효한 리터럴입니다.

리터럴 외에 사용자 정의 형식의 유일한 식은 해당 형식의 값에 바인딩된 기호, 해당 형식의 배열 요소, 해당 형식을 반환 하는 호출 가능 호출입니다.

## <a name="unwrap-expressions"></a>래핑 해제 식

Q #에서 래핑 해제 연산자는 후행 감탄 부호 `!`입니다.
예를 들어, `IntPair` 가 기본 형식의 `(Int, Int)`사용자 정의 형식이 고 `s` 값 `IntPair(2,3)` `s!` 이 인 변수인 경우는 `(2,3)`입니다.

사용자 정의 형식에 대해 정의 합니다. 래핑 해제 연산자는 반복 될 수 있습니다. 예를 `s!!` 들어는 이중 래핑 해제 된 값을 `s`나타냅니다.
따라서가 기본 `WrappedPair` `IntPair`형식의 사용자 `t` 정의 형식이 고가 값 `WrappedPair(IntPair(1,2))` `t!!` 이 포함 된 변수인 경우은 `(1,2)`입니다.

연산자 `!` 는 배열 인덱싱 및 조각화를 위해 이외의 `[]` 다른 모든 연산자 보다 우선 순위가 높습니다.
`!`및 `[]` bind 메서드에 액세스할; 즉, `a[i]![3]` 는의 `((a[i])!)[3]` `i` `a`' 번째 요소를 가져와 래핑 해제 한 다음 래핑 해제 된 값 (배열 이어야 함)의 세 번째 요소를 가져오기로 읽어야 합니다.

`!` 연산자의 우선 순위에는 명확 하지 않을 수 있는 영향이 하나 있습니다.
함수 또는 작업에서 래핑 해제 되는 값을 반환 하는 경우 인수 튜플이 래핑 되지 않고 호출에 바인딩되도록 함수 또는 작업 호출을 괄호로 묶어야 합니다.
예를 들어:

```qsharp
let f = (Foo(arg))!;    // Calls Foo(arg), then unwraps the result
let g = Foo(arg)!;      // Syntax error
```

## <a name="array-expressions"></a>배열 식

배열 리터럴은 `[` 및 `]`로 묶인 하나 이상의 요소 식의 시퀀스로, 쉼표로 구분 됩니다.
모든 요소는 동일한 형식과 호환 되어야 합니다.

공통 요소 형식이 작업 또는 함수 형식이 면 모든 요소에 동일한 입력 및 출력 형식이 있어야 합니다.
배열의 요소 형식은 모든 요소에서 지원 되는 모든 함수을 지원 합니다.
`Op1`예 `Op2` `Op3` 를 들어, 및 모두가 `Qubit[] => Unit`이지만,를 `Op1` 지원 `Adjoint` `Op2` `Controlled`하 고를 지원 하며 `Op3` 를 지원 합니다.

- `[Op1, Op2]`는 작업의 `(Qubit[] => Unit)` 배열입니다.
- `[Op1, Op3]`는 작업의 `(Qubit[] => Unit is Adj)` 배열입니다.
- `[Op2, Op3]`는 작업의 `(Qubit[] => Unit is Ctl)` 배열입니다.

빈 배열 리터럴 `[]`는 허용 되지 않습니다.
대신를 `new ★[0]`사용 하 `★` 는 대신를 사용 합니다. 여기서은 적절 한 형식에 대 한 자리 표시자입니다 .를 사용 하면 원하는 길이 0 배열을 만들 수 있습니다

동일한 형식의 두 배열이 지정 된 경우 이항 `+` 연산자를 사용 하 여 두 배열의 연결 인 새 배열을 만들 수 있습니다.
예를 `[1,2,3] + [4,5,6]` 들어은 `[1,2,3,4,5,6]`입니다.

### <a name="array-creation"></a>배열 만들기

형식 및 `Int` 식이 지정 된 경우 연산자를 `new` 사용 하 여 지정 된 크기의 새 배열을 할당할 수 있습니다.
예를 `new Int[i+1]` 들어는 `Int` `i+1` 요소로 새 배열을 할당 합니다.

새 배열의 요소는 형식 종속 기본값으로 초기화 됩니다.
대부분의 경우이 값은 0으로 변형 된 것입니다.

엔터티를 참조 하는 callables 및 callables의 경우 적절 한 기본값이 없습니다.
따라서 이러한 형식의 경우 기본값은 런타임 오류를 발생 시 키 지 않고 사용할 수 없는 잘못 된 참조입니다.
이는 c #, Java 등의 언어에서 null 참조와 비슷합니다.
요소가 안전 하 게 사용 되기 전에는 기본값이 아닌 값을 사용 하 여 valbits 또는 callables을 포함 하는 배열을 적절 하 게 초기화 해야 합니다. 적절 한 초기화 루틴은에서 <xref:microsoft.quantum.arrays>찾을 수 있습니다.

각 형식에 대 한 기본값은 다음과 같습니다.

Type | 기본값
---------|----------
 `Int` | `0`
 `BigInt` | `0L`
 `Double` | `0.0`
 `Bool` | `false`
 `String` | `""`
 `Qubit` | _invalid qubit_
 `Pauli` | `PauliI`
 `Result` | `Zero`
 `Range` | 빈 범위`1..1..0`
 `Callable` | _invalid callable_
 `Array['T]` | `'T[0]`

튜플 형식은 요소에 의해 초기화 됩니다.


### <a name="jagged-arrays"></a>가변 배열

"배열의 배열"이 라고도 하는 가변 배열은 요소가 배열인 배열입니다. 가변 배열의 요소는 크기가 다를 수 있습니다. 다음 예에서는 곱하기 테이블을 나타내는 가변 배열을 선언 하 고 초기화 하는 방법을 보여 줍니다.

```qsharp
let N = 4;
mutable multiplicationTable = new Int[][N];
for (i in 1..N) {

    mutable row = new Int[i];
    for (j in 1..i) {
        set row w/= j-1 <- i * j;
    }
    set multiplicationTable w/= i-1 <- row;
}
```


### <a name="array-slices"></a>배열 조각

배열 식과 `Range` 식이 지정 된 경우 `[` 및 `]` 배열 조각 연산자를 사용 하 여 새 식을 설정할 수 있습니다.
새 식은 배열과 동일한 형식이 되며의 `Range`요소에 의해 인덱싱된 배열 항목이에 `Range`정의 된 순서 대로 포함 됩니다.
예를 들어, `a` `Double`가 s의 배열에 바인딩된 경우는의 `a[3..-1..0]` `Double[]` `a` 처음 4 개 요소를 포함 하지만에 `a`표시 되는 역순으로를 포함 하는 식입니다.

`Range` 이 비어 있으면 결과 배열 조각의 길이가 0이 됩니다.

배열 식이 단순 식별자가 아니면 조각화 하기 위해 괄호로 묶어야 합니다.
예를 들어 및 `a` `b` 가 모두 s의 `Int`배열인 경우 연결의 조각이 다음과 같이 표시 됩니다.

```qsharp
(a+b)[1..2..7]
```

Q #의 모든 배열은 0부터 시작 합니다.
즉, 배열의 `a` 첫 번째 요소는 항상 `a[0]`입니다.

0.8 릴리스부터는 범위 조각화를 위한 상황별 식을 지원 합니다. 특히 범위 분할 식의 컨텍스트에서는 범위 시작 값과 끝 값을 생략할 수 있습니다. 이 경우 컴파일러는 범위에 대해 의도 된 구분 기호를 유추 하기 위해 다음 규칙을 적용 합니다. 

예를 들어 range start 값을 생략 하면 유추 된 시작 값이 
- 지정 된 단계가 없거나 지정 된 단계가 양수 이면 0이 고, 그렇지 않으면입니다. 
- 지정 된 단계가 음수인 경우 분리 된 배열의 길이에서 1을 뺀 값입니다. 

범위 끝 값이 생략 된 경우에는 유추 된 끝 값이 
- 지정 된 단계가 없고 지정 된 단계가 양수인 경우 분리 된 배열의 길이가 1을 뺀 값입니다. 
- 지정 된 단계가 음수 이면 0이 반환 됩니다. 

```qsharp
let arr = [1,2,3,4,5,6];
let slice1  = arr[3...];      // slice1 is [4,5,6];
let slice2  = arr[0..2...];   // slice2 is [1,3,5];
let slice3  = arr[...2];      // slice3 is [1,2,3];
let slice4  = arr[...2..3];   // slice4 is [1,3];
let slice5  = arr[...2...];   // slice5 is [1,3,5];
let slice7  = arr[4..-2...];  // slice7 is [5,3,1];
let slice8  = arr[...-1..3];  // slice8 is [6,5,4];
let slice9  = arr[...-1...];  // slice9 is [6,5,4,3,2,1];
let slice10 = arr[...];       // slice10 is [1,2,3,4,5,6];
```

## <a name="array-element-expressions"></a>배열 요소 식

배열 식과 `Int` 식이 지정 된 경우 `[` 및 `]` 배열 요소 연산자를 사용 하 여 새 식을 설정할 수 있습니다.
새 식은 배열의 요소 형식과 동일한 형식이 됩니다.
예를 들어, `a` 가 s `Double` `a[4]` 의 배열에 바인딩되면은 `Double` 식입니다.

배열 식이 단순 식별자가 아닌 경우 요소를 선택 하기 위해 괄호로 묶어야 합니다.
예를 들어 및 `a` `b` 가 모두 s의 `Int`배열인 경우 연결의 요소가 다음과 같이 표시 됩니다.

```qsharp
(a+b)[13]
```

Q #의 모든 배열은 0부터 시작 합니다.
즉, 배열의 `a` 첫 번째 요소는 항상 `a[0]`입니다.


## <a name="copy-and-update-expressions"></a>복사 및 업데이트 식

기존 배열에서 복사 및 업데이트 식을 통해 새 배열을 만들 수 있습니다.
복사 및 `expression1 w/ expression2 <- expression3`업데이트 식은 형식의 식이 며, 여기서 `expression1` 은 특정 형식의 `T[]` `T`형식 이어야 합니다. 두 번째 `expression2` 는에서 `expression1` 배열과 비교 하 여 수정할 요소의 인덱스를 정의 하 고, 형식 `Int` 또는 형식 중 하나 여야 `Range`합니다. 가 `expression2` 형식이 `Int` `expression3` 면은 형식 `T`이어야 합니다. 가 `expression2` 형식이 `Range` `expression3` 면은 형식 `T[]`이어야 합니다.

`arr w/ idx <- value` 복사 및 업데이트 식은의 해당 요소로 설정 된 모든 요소를 포함 하는 새 배열을 생성 합니다. `arr`이 요소는의 요소 `idx`를 제외 하 고는의 `value`해당 요소로 설정 됩니다. 예를 들어에 `arr` 배열이 `[0,1,2,3]`포함 된 경우 
- `arr w/ 0 <- 10`는 배열 `[10,1,2,3]`입니다.
- `arr w/ 2 <- 10`는 배열 `[0,1,10,3]`입니다.
- `arr w/ 0..2..3 <- [10,12]`는 배열 `[10,1,12,3]`입니다.

사용자 정의 형식에 명명 된 항목에 대 한 유사한 식이 있습니다. 예를 들어 형식 

```qsharp
newtype Complex = (Re : Double, Im : Double);
```
에 `c` 형식의 `Complex(1.,-1.)`값 `c w/ Re <- 0.` 이 포함 된 경우는로 `Complex` `Complex(0.,-1.)`계산 되는 형식의 식입니다.

## <a name="conditional-expressions"></a>조건 식

동일한 형식 및 부울 식의 다른 두 식이 지정 된 경우 물음표 `?` 및 세로 막대 `|`를 사용 하 여 조건 식을 지정할 수 있습니다.
예를 `a==b ? c | d`들면입니다.
이 예에서는 조건식 `c` `a==b` 의 값이 true 이면이 고 `d` , 그렇지 않으면 false입니다.

두 식은 동일한 입력 및 출력을 포함 하는 작업으로 평가 될 수 있지만 다른 함수을 지원 합니다.
이 경우 조건식의 형식은 두 식에서 지원 되는 모든 함수를 지 원하는 입력 및 출력을 사용 하는 작업입니다.
`Op1`예 `Op2` `Op3` 를 들어, 및 모두가 `Qubit[]=>Unit`이지만,를 `Op1` 지원 `Adjoint` `Op2` `Controlled`하 고를 지원 하며 `Op3` 를 지원 합니다.

- `flag ? Op1 | Op2`은 `(Qubit[] => Unit)` 작업입니다.
- `flag ? Op1 | Op3`은 `(Qubit[] => Unit is Adj)` 작업입니다.
- `flag ? Op2 | Op3`은 `(Qubit[] => Unit is Ctl)` 작업입니다.

가능한 두 결과 식 중 하나에 함수 또는 작업 호출이 포함 된 경우 해당 호출은 호출의 값이 되는 경우에만 수행 됩니다.
`a==b ? C(qs) | D(qs)`예를 들어 `a==b` ,이 true 이면 `C` 작업이 호출 되 고 false 인 경우에만 `D` 호출 됩니다.
이는 다른 언어의 단락과 비슷합니다.


## <a name="operator-precedence"></a>연산자 우선 순위

모든 이항 연산자는를 제외 하 고 오른쪽 결합성 `^`이 있습니다.

`[` 대괄호 및는 배열 조각화 및 인덱싱의 경우 모든 연산자 앞에 `]`바인딩합니다.

함수 `Adjoint` 및 `Controlled` 는 배열 인덱싱 후 다른 모든 연산자 앞에 바인딩합니다.

연산 및 함수 호출에 대 한 괄호는 모든 연산자 앞에, 배열 인덱싱 및 함수 후에도 바인딩됩니다.

우선 순위 순으로 최고에서 최저 순으로 연산자.

연산자 | 숫자 | 설명 | 피연산자 형식
---------|----------|---------|---------------
 붙이지`!` | 단항 | 래핑 취소 | 사용자 정의 형식
 `-`, `~~~`, `not` | 단항 | 숫자 음수, 비트 보수, 논리 부정 | `Int``BigInt` `Double` `-`,의 `Int` 경우,,의 경우,의 경우 `BigInt` `~~~` `Bool``not`
 `^` | 이진 | 정수 거듭제곱 | `Int`또는 `BigInt` 기준 `Int` 의 경우 지 수의 경우입니다.
 `/`, `*`, `%` | 이진 | 나누기, 곱하기, 정수 모듈러스 | `Int``Double` `BigInt` ,,, 또는 `BigInt` 의 경우 `/` `*` `Int``%`
 `+`, `-` | 이진 | 더하기 또는 문자열 및 배열 연결, 빼기 | `Int`, `BigInt` , `Double`또는 `String` 에 대 한 배열 형식입니다.`+`
 `<<<`, `>>>` | 이진 | 왼쪽 시프트, 오른쪽 시프트 | `Int` 또는 `BigInt`
 `<`, `<=`, `>`, `>=` | 이진 | 보다 작음, 작거나 같음, 보다 큼, 보다 큼, 크거나 같음 비교 | `Int`, `BigInt` 또는`Double`
 `==`, `!=` | 이진 | 같음, 같지 않음 비교 | 모든 기본 형식
 `&&&` | 이진 | 비트 AND | `Int` 또는 `BigInt`
 `^^^` | 이진 | 비트 XOR | `Int` 또는 `BigInt`
 <code>\|\|\|</code> | 이진 | 비트 OR | `Int` 또는 `BigInt`
 `and` | 이진 | 논리적 AND | `Bool`
 `or` | 이진 | 논리적 OR | `Bool`
 `..` | Binary/삼항 | Range 연산자 | `Int`
 `?` `|` | 진 | 조건부 | `Bool`왼쪽의 경우
`w/` `<-` | 진 | 복사 및 업데이트 | [복사 및 업데이트 식](#copy-and-update-expressions) 참조
