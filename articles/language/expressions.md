---
title: 'Q # 식'
description: 'Q #에서 상수, 변수, 연산자, 작업 및 함수를 식으로 지정, 참조 및 결합 하는 방법을 이해 합니다.'
author: QuantumWriter
ms.author: Alan.Geller@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.language.expressions
ms.openlocfilehash: fbde873f220d737db17f889d00be33541e3eb59b
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907412"
---
# <a name="expressions"></a>식

## <a name="grouping"></a>Grouping(그룹화)

식이 지정 된 경우 괄호로 묶인 동일한 식이 동일한 형식의 식입니다.
예를 들어 `(7)`은 `Int` 식 이며, `([1,2,3])` `Int`s 배열 형식의 식이고 `((1,2))` 형식이 `(Int, Int)`인 식입니다.

[형식 모델](xref:microsoft.quantum.language.type-model#tuple-types) 에 설명 된 단순 값과 단일 요소 튜플의 동등성은 `(6)` 그룹의 모호성을 제거 하 고 단일 요소 튜플로 `(6)` 합니다.

## <a name="symbols"></a>Symbols

`'T` 형식의 값에 바인딩하거나 할당 된 기호의 이름은 `'T`형식의 식입니다.
예를 들어 `count` 기호가 `5`정수 값에 바인딩되면 `count`는 정수 식입니다.

## <a name="numeric-expressions"></a>숫자 식

숫자 식은 `Int`, `BigInt`또는 `Double`형식의 식입니다.
즉, 정수 또는 부동 소수점 숫자 중 하나입니다.

Q #의 `Int` 리터럴은 후행 "l" 또는 " C#l"이 필요 하거나 허용 되지 않는다는 점을 제외 하 고의 정수 리터럴과 동일 합니다.
16 진수 및 이진 정수는 각각 "0x" 및 "0b" 접두사를 사용 하 여 지원 됩니다.

Q #의 `BigInt` 리터럴은 .NET의 큰 정수 문자열과 같으며 그 뒤에는 "l" 또는 "L"이 있습니다.
16 진수 큰 정수는 "0x" 접두사를 사용 하 여 지원 됩니다.
따라서 다음은 `BigInt` 리터럴의 모든 유효한 사용입니다.

```qsharp
let bigZero = 0L;
let bigHex = 0x123456789abcdef123456789abcdefL;
let bigOne = bigZero + 1L;
```

Q #의 `Double` 리터럴은 후행 "d" 또는 " C#d"가 필요 하거나 허용 되지 않는다는 점을 제외 하 고의 이중 리터럴과 동일 합니다.

모든 요소 형식의 배열 식이 지정 된 경우 `Length` 기본 제공 함수를 사용 하 여 `Int` 식을 구성 하 고, 배열 식이 괄호로 묶여 `(` 및 `)`수 있습니다.
예를 들어 `a` 배열에 바인딩된 경우 `Length(a)`는 정수 식입니다.
`b` `Int[][]`정수 배열의 배열인 경우 `Length(b)`는 `b`의 하위 배열 수이 고, `Length(b[1])`은 `b`에서 두 번째 하위 배열의 정수 개수입니다.

동일한 형식의 두 숫자 식이 지정 된 경우 이항 연산자 `+`, `-`, `*`및 `/`를 사용 하 여 새 숫자 식을 만들 수 있습니다.
새 식의 형식은 구성 식의 형식과 동일 합니다.

두 개의 정수 식이 지정 된 경우 이항 연산자 `^` (power)를 사용 하 여 새 정수 식을 만들 수 있습니다.
마찬가지로 두 개의 double 식에서 `^`를 사용 하 여 새 double 식을 만들 수 있습니다.
마지막으로 `^` 왼쪽의 큰 정수를 사용 하 고 오른쪽에 정수를 사용 하 여 새 큰 정수 식을 만들 수 있습니다.
이 경우 두 번째 매개 변수는 32 비트에 맞아야 합니다. 그렇지 않으면 런타임 오류가 발생 합니다.

두 개의 정수 또는 큰 정수 식이 지정 된 경우 `%` (모듈러스), `&&&` (비트 AND), `|||` (비트 OR) 또는 `^^^` (비트 XOR) 연산자를 사용 하 여 새 정수 또는 큰 정수 식을 지정할 수 있습니다.

왼쪽에 정수 또는 큰 정수 식이 있고 오른쪽에 정수 식이 지정 된 경우 `<<<` (산술 왼쪽 시프트) 또는 `>>>` (산술 오른쪽 시프트) 연산자를 사용 하 여 왼쪽 식과 같은 형식의 새 식을 만들 수 있습니다.

이동 작업에 대 한 두 번째 매개 변수 (이동 크기)는 0 보다 크거나 같아야 합니다. 음수 시프트 금액의 동작은 정의 되지 않습니다.
시프트 연산의 이동 양은 32 비트에도 맞아야 합니다. 그렇지 않으면 런타임 오류가 발생 합니다.
이동할 숫자가 정수 이면 시프트 금액이 `mod 64`로 해석 됩니다. 즉, 1의 교대조와 65의 시프트는 동일한 효과를 가집니다.

정수 및 큰 정수 값 모두에 대해 시프트는 산술 연산입니다.
음수 값을 왼쪽 이나 오른쪽으로 이동 하면 음수가 반환 됩니다.
즉, 한 단계를 왼쪽 또는 오른쪽으로 이동 하는 것은 각각 2로의 곱하기 또는 나누기와 정확히 동일 합니다.

정수 나누기와 정수 모듈러스는와 C#음수에 대해 동일한 동작을 수행 합니다.
즉, `a % b`는 항상 `a`와 동일한 기호 이며 `b * (a / b) + a % b`는 항상 `a`와 동일 합니다.
다음은 그 예입니다.

 `A` | `B` | `A / B` | `A % B`
---------|----------|---------|---------
 5 | 2 | 2 | 1
 5 | -2 | -2 | 1
 -5 | 2 | -2 | -1
 -5 | -2 | 2 | -1

큰 정수 나누기와 모듈러스는 동일한 방식으로 작동 합니다.

숫자 식이 지정 된 경우 `-` 단항 연산자를 사용 하 여 새 식을 설정할 수 있습니다.
새 식은 구성 식과 동일한 형식이 됩니다.

정수 또는 큰 정수 식이 지정 된 경우에는 `~~~` (비트 보수) 단항 연산자를 사용 하 여 동일한 유형의 새 식이 형성 될 수 있습니다.

## <a name="boolean-expressions"></a>부울 식

두 `Bool` 리터럴 값은 `true` 및 `false`됩니다.

동일한 기본 형식의 두 식이 지정 된 경우 `==` 및 `!=` 이항 연산자를 사용 하 여 `Bool` 식을 생성할 수 있습니다.
식은 두 식이 같으면 true이 고, 그렇지 않으면 false입니다.

사용자 정의 형식의 값을 비교할 수 없습니다. 래핑 해제 된 값만 비교할 수 있습니다. 예를 들어 "래핑 해제" 연산자 `!` ( [Q # 형식 모델 페이지](xref:microsoft.quantum.language.type-model#user-defined-types)에 설명 되어 있음)를 사용 합니다.

```qsharp
newtype WrappedInt = Int;     // Yes, this is a contrived example
let x = WrappedInt(1);
let y = WrappedInt(2);
let z = x! == y!;             // This will compile and yield z = false.
let t = x == y;               // This will cause a compiler error.
```

`Qubit` 값에 대 한 같음 비교는 id 같음입니다. 즉, 두 식이 동일한의 비트를 식별 하는지 여부입니다.
이 비교로 두 비트의 상태를 비교, 액세스, 측정 또는 수정할 수 없습니다.

`Double` 값에 대 한 같음 비교는 반올림 결과 때문에 잘못 될 수 있습니다.
예를 들어 `49.0 * (1.0/49.0) != 1.0`합니다.

두 개의 숫자 식을 지정 하는 경우 이항 연산자 `>`, `<`, `>=`및 `<=`를 사용 하 여 첫 번째 식이 두 번째 식 보다 크거나 같고 보다 작거나 같은 경우 true 인 새 부울 식을 생성할 수 있습니다.

두 부울 식을 지정 하는 경우 `and` 및 `or` 이항 연산자를 사용 하 여 두 식이 모두 true 인 경우 true 인 새 부울 식을 생성할 수 있습니다.

부울 식을 지정 하면 `not` 단항 연산자를 사용 하 여 구성 식이 false 인 경우 true 인 새 부울 식을 생성할 수 있습니다.

## <a name="string-expressions"></a>문자열 식

Q #에서는 `fail` 문과 `Log` 표준 함수에 문자열을 사용할 수 있습니다.

Q #의 문자열은 리터럴 또는 보간된 문자열입니다.
문자열 리터럴은 대부분의 언어에서 간단한 문자열 리터럴과 유사 합니다. 큰따옴표 안에 포함 된 유니코드 문자 시퀀스 `"`입니다.
문자열 내에서 백슬래시 문자 `\`를 사용 하 여 큰따옴표 문자를 이스케이프 처리 하 고, `\n`으로 새 줄을 삽입 하 고, `\r`로 캐리지 리턴을 삽입 하 고, 탭을 `\t`로 삽입할 수 있습니다.
예:

```qsharp
"\"Hello world!\", she said.\n"
```

문자열 보간에 대 한 Q # 구문은 C# 7.0 구문의 하위 집합입니다. Q #에서는 축 자 (여러 줄) 보간된 문자열을 지원 하지 않습니다.
C# 구문의 [*보간된 문자열*](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/interpolated-strings) 을 참조 하세요.

보간된 문자열 내부의 식은 Q # 구문을 따르지 않고 C# 구문은 따릅니다.
유효한 Q # 식은 보간된 문자열에 나타날 수 있습니다.

## <a name="qubit-expressions"></a>Bit 식

유일한 `Qubit` 식은 `Qubit` 배열의 `Qubit` 값 또는 배열 요소에 바인딩되는 기호입니다.
`Qubit` 리터럴이 없습니다.

## <a name="pauli-expressions"></a>Pauli 식

`PauliI`, `PauliX`, `PauliY`및 `PauliZ`의 네 가지 `Pauli` 값은 모두 유효한 `Pauli` 식입니다.

그 외에도 `Pauli` 식은 `Pauli` 배열의 `Pauli` 값 또는 배열 요소에 바인딩되는 기호입니다.

## <a name="result-expressions"></a>결과 식

`One` 및 `Zero`의 두 `Result` 값은 유효한 `Result` 식입니다.

그 외에도 `Result` 식은 `Result` 배열의 `Result` 값 또는 배열 요소에 바인딩되는 기호입니다.
특히 `One`는 정수 `1`와 동일 하지 않으며 둘 사이에 직접 변환할 수 없습니다.
`Zero` 및 `0`에도 마찬가지입니다.

## <a name="range-expressions"></a>범위 식

3 개의 `Int` 식 `start`, `step`및 `stop`지정 된 경우 `start .. step .. stop`가 전달 될 때까지 첫 번째 요소가 `start`이 고, 두 번째 요소가 `start+step`되 고, 세 번째 요소가 `start+step+step`되는 범위 식 `stop`입니다.
예를 들어 `step` 양수이 고 `stop < start`경우 범위가 비어 있을 수 있습니다.
`start`와 `stop`의 차이가 `step`의 정수 배수가 면 범위의 마지막 요소가 `stop` 됩니다. 즉, 범위는 양쪽 끝에 포함 됩니다.

두 개의 `Int` 식 `start` 및 `stop`지정 된 경우 `start .. stop`은 `start .. 1 .. stop`와 같은 범위 식입니다.
`stop`이 `start`보다 작은 경우에도 암시 된 `step` + 1입니다. 이 경우 범위는 비어 있습니다.

몇 가지 예제 범위는 다음과 같습니다.

- `1..3`은 1, 2, 3의 범위입니다.
- `2..2..5` 범위는 2, 4입니다.
- `2..2..6`은 2, 4, 6의 범위입니다.
- `6..-2..2` 범위는 6, 4, 2입니다.
- `2..1`은 빈 범위입니다.
- `2..6..7` 범위는 2입니다.
- `2..2..1`은 빈 범위입니다.
- `1..-1..2`은 빈 범위입니다.

## <a name="callable-expressions"></a>호출 가능 식

호출 가능 리터럴은 컴파일 범위에서 정의 된 작업 또는 함수의 이름입니다.
예를 들어 `X`은 표준 라이브러리 `X` 작업을 참조 하는 작업 리터럴이어야 `Message`는 표준 라이브러리 `Message` 함수를 참조 하는 함수 리터럴입니다.

작업에서 `Adjoint` 함수를 지 원하는 경우 `Adjoint op`은 연산 식입니다.
마찬가지로 작업에서 `Controlled` 함수를 지 원하는 경우 `Controlled op`은 연산 식입니다.
이러한 식의 형식은 [함수](xref:microsoft.quantum.language.type-model#functors)에서 지정 합니다.

함수 (`Adjoint` 및 `Controlled`) `[]``!`는 다른 모든 연산자 보다 더 밀접 하 게 바인딩합니다.
따라서 다음은 작업에서 사용 되는 함수를 지원 한다고 가정 하 여 모든 법률입니다.

```qsharp
Adjoint Op(qs)
Controlled Op(controls, targets)
Controlled Adjoint Op(controls, targets)
Adjoint WrappedOp!(qs)
```

호출 가능 리터럴은 값으로 사용 될 수 있습니다. 예를 들어 변수에 할당 하거나 다른 호출 가능으로 전달 합니다.
이 경우 호출 가능에 형식 매개 변수가 있으면 해당 매개 변수를 호출 가능 값의 일부로 제공 해야 합니다.
호출 가능 값은 지정 되지 않은 형식 매개 변수를 가질 수 없습니다.

예를 들어 `Fun`가 시그니처 `'T1->Unit`를 사용 하는 함수인 경우:

```qsharp
let f = Fun<Int>;            // f is Int->Unit.
SomeOtherFun(Fun<Double>);   // A Double->Unit is passed to SomOtherFun.
let g = Fun;                 // This causes a compilation error.
SomeOtherFun(Fun);           // This also causes a compilation error.
```

## <a name="callable-invocation-expressions"></a>호출 가능 호출 식

호출 가능 식의 입력 형식에 대 한 호출 가능 (연산 또는 함수) 식과 튜플 식이 지정 된 경우 호출 식은 튜플 식을 호출 가능 식에 추가 하 여 구성 될 수 있습니다.
호출 식의 형식은 호출 가능 시그니처의 출력 형식입니다.

예를 들어 `Op`가 signature `((Int, Qubit) => Double)`를 사용 하는 작업 인 경우 `Op(3, qubit1)`는 `Double`형식의 식입니다.
마찬가지로 `Sin`가 시그니처 `(Double -> Double)`를 사용 하는 함수인 경우 `Sin(0.1)`는 `Double`형식의 식입니다.
마지막으로 `Builder`가 시그니처 `Builder(3)` `(Int -> (Int -> Int))`를 사용 하는 함수인 경우는에서 Int로의 함수입니다.

호출 가능 값 식의 결과를 호출 하려면 호출 가능 식 주위에 괄호 쌍을 추가 해야 합니다.
따라서 이전 단락에서 `Builder` 호출 결과를 호출 하려면 올바른 구문은 다음과 같습니다.

```qsharp
(Builder(3))(2)
```

형식이 매개 변수가 있는 호출 가능 매개 변수를 호출 하는 경우 실제 형식 매개 변수는 꺾쇠 괄호 안에 지정 하 고 호출 가능 식 뒤에 `>` `<` 수 있습니다.
이는 일반적으로 Q # 컴파일러가 실제 형식을 유추 하므로 필요 하지 않습니다.
형식 매개 변수가 있는 인수가 지정 되지 않은 상태로 남아 있는 경우 부분 응용 프로그램에 필요 합니다 (아래 참조).
또한 다른 함수를 사용 하는 작업을 호출할 수 있는 경우에도 유용 합니다.

예를 들어 `Func` 서명 `('T1, 'T2, 'T1) -> 'T2`있는 경우 `Op1` 및 `Op2`에 서명 `(Qubit[] => Unit is Adj)`가 있고 `Op3`에 `(Qubit[] => Unit)`를 사용 하 여 첫 번째 인수로 `Func`를 호출 하 고, 두 번째 인수로 `Op1`를 호출 하 고, 세 번째 인수로 `Op2`를 호출 합니다.`Op3`

```qsharp
let combinedOp = Func<(Qubit[] => Unit), (Qubit[] => Unit is Adj)>(Op1, Op2, Op3);
```

`Op3` 및 `Op1`에 다른 형식이 있기 때문에 형식 사양이 필요 합니다. 따라서 컴파일러는 사양을 사용 하지 않고이를 모호 하 게 처리 합니다.

### <a name="partial-application"></a>부분 응용 프로그램

호출 가능 식이 지정 된 경우 호출 가능에 인수의 하위 집합을 제공 하 여 새 호출 가능을 만들 수 있습니다.
이를 _부분 응용 프로그램_이라고 합니다.

Q #에서 부분적으로 적용 되는 호출 가능는 일반적인 호출 식을 작성 하지만 지정 되지 않은 인수에 밑줄 `_`사용 하 여 표현 됩니다.
결과로 생성 되는 호출 가능의 결과 형식은 기본 호출 가능 및 작업에 대 한 동일한 특수화와 동일 합니다.
부분 응용 프로그램의 입력 형식은 단순히 지정 된 인수가 제거 된 원래 형식입니다.

부분 응용 프로그램을 만들 때 변경 가능한 변수가 지정 된 인수로 전달 되 면 변수의 현재 값이 사용 됩니다.
나중에 변수 값을 변경 해도 부분 응용 프로그램에는 영향을 주지 않습니다.

예를 들어 `Op`에 `((Int, ((Qubit, Qubit), Double)) => Unit is Adj)`형식이 있는 경우:

- `Op(5,(_,_))`에 `(((Qubit,Qubit), Double) => Unit is Adj)`형식이 있으므로 `Op(5,_)`있습니다.
- `Op(_,(_,1.0))` `((Int, (Qubit,Qubit)) => Unit is Adj)`형식입니다.
- `Op(_,((q1,q2),_))` `((Int,Double) => Unit is Adj)`형식입니다.
   여기서는 단일 튜플 동등성을 적용 했습니다.

부분적으로 적용 되는 호출 가능에서 컴파일러가 유추할 수 없는 형식 매개 변수를 포함 하는 경우 호출 사이트에서 제공 해야 합니다.
부분 응용 프로그램에는 지정 되지 않은 형식 매개 변수를 사용할 수 없습니다.

예를 들어 `Op`에 `(('T1, Qubit, 'T1) => Unit : Adjoint)`형식이 있는 경우:

```qsharp
let f1 = Op<Int>(_, qb, _); // f1 has type ((Int,Int) => Unit is Adj)
let f2 = Op(5, qb, _);      // f2 has type (Int => Unit is Adj)
let f3 = Op(_,qb, _);       // f3 generates a compilation error
```

### <a name="recursion"></a>재귀

Q # callables은 직접 또는 간접적으로 재귀적으로 사용할 수 있습니다.
즉, 작업 또는 함수가 자신을 호출 하거나 호출 가능 작업을 직접 또는 간접적으로 호출 하는 다른 호출 가능 함수를 호출할 수 있습니다.

그러나 재귀 사용에 대 한 두 가지 중요 한 설명은 다음과 같습니다.

- 작업에서 재귀를 사용 하면 특정 최적화에 방해가 될 수 있습니다.
  이는 알고리즘의 실행 시간에 상당한 영향을 미칠 수 있습니다.
- 실제 퀀텀 장치에서 실행 되는 경우 스택 공간이 제한 될 수 있으므로, 심층 재귀가 런타임 오류가 발생할 수 있습니다.
  특히 Q # 컴파일러 및 런타임에서는 마무리 재귀를 식별 하 고 최적화 하지 않습니다.

## <a name="tuple-expressions"></a>튜플 식

튜플 리터럴은 `(` 및 `)`에 포함 된 적절 한 형식의 요소 식의 시퀀스입니다 (쉼표로 구분 됨).
예를 들어 `(1, One)`은 `(Int, Result)` 식입니다.

리터럴 이외의 튜플 식은 튜플 값에 바인딩된 기호, 튜플 배열의 배열 요소 및 튜플을 반환 하는 호출 가능 호출입니다.

## <a name="user-defined-type-expressions"></a>사용자 정의 형식 식

사용자 정의 형식의 리터럴은 형식 이름과 해당 형식의 기본 튜플 형식의 튜플 리터럴로 구성 됩니다.
예를 들어 `IntPair` `(Int, Int)`를 기반으로 하는 사용자 정의 형식인 경우 `IntPair(2,3)`는 해당 형식의 유효한 리터럴이 됩니다.

리터럴 외에 사용자 정의 형식의 유일한 식은 해당 형식의 값에 바인딩된 기호, 해당 형식의 배열 요소, 해당 형식을 반환 하는 호출 가능 호출입니다.

## <a name="unwrap-expressions"></a>래핑 해제 식

Q #에서 래핑 해제 연산자는 후행 느낌표 `!`입니다.
예를 들어 `IntPair`가 기본 형식이 `(Int, Int)`인 사용자 정의 형식이 고 `s` 값이 `IntPair(2,3)`인 변수인 경우 `s!` `(2,3)`됩니다.

사용자 정의 형식에 대해 정의 합니다. 래핑 해제 연산자는 반복 될 수 있습니다. 예를 들어 `s!!`은 `s`의 이중 래핑 해제 값을 나타냅니다.
따라서 `WrappedPair` 기본 형식이 `IntPair`있는 사용자 정의 형식이 고 `t` 값이 `WrappedPair(IntPair(1,2))`인 변수인 경우 `t!!` `(1,2)`됩니다.

`!` 연산자는 배열 인덱싱 및 조각화를 위해 `[]` 이외의 다른 모든 연산자 보다 우선 순위가 높습니다.
`!` 및 `[]` bind 메서드에 액세스할; 즉, `a[i]![3]`를 `((a[i])!)[3]`으로 읽어야 합니다. `a`의 `i`' 번째 요소를 사용 하 여 래핑 해제 한 다음 래핑 해제 된 값 (배열 이어야 함)의 세 번째 요소를 가져옵니다.

`!` 연산자의 우선 순위에는 명확 하지 않을 수 있는 영향이 하나 있습니다.
함수 또는 작업에서 래핑 해제 되는 값을 반환 하는 경우 인수 튜플이 래핑 되지 않고 호출에 바인딩되도록 함수 또는 작업 호출을 괄호로 묶어야 합니다.
다음은 그 예입니다.

```qsharp
let f = (Foo(arg))!;    // Calls Foo(arg), then unwraps the result
let g = Foo(arg)!;      // Syntax error
```

## <a name="array-expressions"></a>배열 식

배열 리터럴은 `[` 및 `]`에 포함 된 하나 이상의 요소 식 (쉼표로 구분)의 시퀀스입니다.
모든 요소는 동일한 형식과 호환 되어야 합니다.

공통 요소 형식이 작업 또는 함수 형식이 면 모든 요소에 동일한 입력 및 출력 형식이 있어야 합니다.
배열의 요소 형식은 모든 요소에서 지원 되는 모든 함수을 지원 합니다.
예를 들어 `Op1`, `Op2`및 `Op3` 모두 `Qubit[] => Unit`되지만 `Op1`는 `Adjoint`를 지원 하 고 `Op2`를 지원 하며 `Controlled`를 지원 합니다.`Op3`

- `[Op1, Op2]`은 `(Qubit[] => Unit)` 작업의 배열입니다.
- `[Op1, Op3]`은 `(Qubit[] => Unit is Adj)` 작업의 배열입니다.
- `[Op2, Op3]`은 `(Qubit[] => Unit is Ctl)` 작업의 배열입니다.

빈 배열 리터럴 `[]`는 허용 되지 않습니다.
대신 `new ★[0]`를 사용 합니다. 여기서 `★`은 적절 한 형식에 대 한 자리 표시자로 사용 하 여 길이가 0 인 원하는 배열을 만들 수 있습니다.

동일한 형식의 두 배열이 지정 된 경우 이항 `+` 연산자를 사용 하 여 두 배열의 연결 인 새 배열을 만들 수 있습니다.
예를 들어 `[1,2,3] + [4,5,6]` `[1,2,3,4,5,6]`됩니다.

### <a name="array-creation"></a>배열 만들기

형식 및 `Int` 식이 지정 된 경우 `new` 연산자를 사용 하 여 지정 된 크기의 새 배열을 할당할 수 있습니다.
예를 들어 `new Int[i+1]`는 `i+1` 요소로 새 `Int` 배열을 할당 합니다.

새 배열의 요소는 형식 종속 기본값으로 초기화 됩니다.
대부분의 경우이 값은 0으로 변형 된 것입니다.

엔터티를 참조 하는 callables 및 callables의 경우 적절 한 기본값이 없습니다.
따라서 이러한 형식의 경우 기본값은 런타임 오류를 발생 시 키 지 않고 사용할 수 없는 잘못 된 참조입니다.
이는 또는 Java와 C# 같은 언어의 null 참조와 유사 합니다.
요소가 안전 하 게 사용 되기 전에는 기본값이 아닌 값을 사용 하 여 valbits 또는 callables을 포함 하는 배열을 적절 하 게 초기화 해야 합니다. 적절 한 초기화 루틴은 <xref:microsoft.quantum.arrays>에서 찾을 수 있습니다.

각 형식에 대 한 기본값은 다음과 같습니다.

Type | 기본값
---------|----------
 `Int` | `0`
 `BigInt` | `0L`
 `Double` | `0.0`
 `Bool` | `false`
 `String` | `""`
 `Qubit` | _잘못 된 비트_
 `Pauli` | `PauliI`
 `Result` | `Zero`
 `Range` | 빈 범위 `1..1..0`
 `Callable` | _잘못 된 호출 가능_
 `Array['T]` | `'T[0]`

튜플 형식은 요소에 의해 초기화 됩니다.


### <a name="jagged-arrays"></a>가변 배열

"배열의 배열"이 라고도 하는 가변 배열은 요소가 배열인 배열입니다. 가변 배열의 요소는 크기가 다를 수 있습니다. 다음 예에서는 곱하기 테이블을 나타내는 가변 배열을 선언 하 고 초기화 하는 방법을 보여 줍니다.

```qsharp
let N = 4;
mutable multiplicationTable = new Int[][N];
for (i in 1..N) {

    mutable row = new Int[i];
    for (j in 1..i) {
        set row w/= j-1 <- i * j;
    }
    set multiplicationTable w/= i-1 <- row;
}
```


### <a name="array-slices"></a>배열 조각

배열 식과 `Range` 식이 지정 된 경우 `[` 및 `]` 배열 조각 연산자를 사용 하 여 새 식을 지정할 수 있습니다.
새 식은 배열과 형식이 같으며 `Range`의 요소에 의해 인덱싱된 배열 항목이 `Range`에 정의 된 순서 대로 포함 됩니다.
예를 들어 `a` `Double`s 배열에 바인딩되어 있는 경우 `a[3..-1..0]`는 `a`의 처음 4 개 요소를 포함 하는 `Double[]` 식이 며 `a`에 표시 되는 역순입니다.

`Range` 비어 있으면 결과 배열 조각의 길이가 0이 됩니다.

배열 식이 단순 식별자가 아니면 조각화 하기 위해 괄호로 묶어야 합니다.
예를 들어 `a` 및 `b` 모두 `Int`s 인 경우 연결의 조각은 다음과 같이 표시 됩니다.

```qsharp
(a+b)[1..2..7]
```

Q #의 모든 배열은 0부터 시작 합니다.
즉, `a` 배열의 첫 번째 요소는 항상 `a[0]`됩니다.

0\.8 릴리스부터는 범위 조각화를 위한 상황별 식을 지원 합니다. 특히 범위 분할 식의 컨텍스트에서는 범위 시작 값과 끝 값을 생략할 수 있습니다. 이 경우 컴파일러는 범위에 대해 의도 된 구분 기호를 유추 하기 위해 다음 규칙을 적용 합니다. 

예를 들어 range start 값을 생략 하면 유추 된 시작 값이 
- 지정 된 단계가 없거나 지정 된 단계가 양수 이면 0이 고, 그렇지 않으면입니다. 
- 지정 된 단계가 음수인 경우 분리 된 배열의 길이에서 1을 뺀 값입니다. 

범위 끝 값이 생략 된 경우에는 유추 된 끝 값이 
- 지정 된 단계가 없고 지정 된 단계가 양수인 경우 분리 된 배열의 길이가 1을 뺀 값입니다. 
- 지정 된 단계가 음수 이면 0이 반환 됩니다. 

```qsharp
let arr = [1,2,3,4,5,6];
let slice1  = arr[3...];      // slice1 is [4,5,6];
let slice2  = arr[0..2...];   // slice2 is [1,3,5];
let slice3  = arr[...2];      // slice3 is [1,2,3];
let slice4  = arr[...2..3];   // slice4 is [1,3];
let slice5  = arr[...2...];   // slice5 is [1,3,5];
let slice7  = arr[4..-2...];  // slice7 is [5,3,1];
let slice8  = arr[...-1..3];  // slice8 is [6,5,4];
let slice9  = arr[...-1...];  // slice9 is [6,5,4,3,2,1];
let slice10 = arr[...];       // slice10 is [1,2,3,4,5,6];
```

## <a name="array-element-expressions"></a>배열 요소 식

배열 식과 `Int` 식이 지정 된 경우 `[` 및 `]` 배열 요소 연산자를 사용 하 여 새 식을 설정할 수 있습니다.
새 식은 배열의 요소 형식과 동일한 형식이 됩니다.
예를 들어 `a` `Double`s 배열에 바인딩된 경우 `a[4]` `Double` 식입니다.

배열 식이 단순 식별자가 아닌 경우 요소를 선택 하기 위해 괄호로 묶어야 합니다.
예를 들어 `a` 및 `b`가 모두 `Int`s 배열인 경우 연결의 요소는 다음과 같이 표현 됩니다.

```qsharp
(a+b)[13]
```

Q #의 모든 배열은 0부터 시작 합니다.
즉, `a` 배열의 첫 번째 요소는 항상 `a[0]`됩니다.


## <a name="copy-and-update-expressions"></a>복사 및 업데이트 식

기존 배열에서 복사 및 업데이트 식을 통해 새 배열을 만들 수 있습니다.
복사 및 업데이트 식은 `expression1 w/ expression2 <- expression3`폼의 식이 며, `expression1` 형식 `T`에 대 한 `T[]` 형식 이어야 합니다. 두 번째 `expression2`는 `expression1` 배열의 배열과 비교 하 여 수정할 요소의 인덱스를 정의 하 고 `Int` 형식 이거나 `Range`형식 이어야 합니다. `expression2` `Int`형식이 면 `expression3` `T`형식 이어야 합니다. `expression2` `Range`형식이 면 `expression3` `T[]`형식 이어야 합니다.

`arr w/ idx <- value` 복사 및 업데이트 식은 `value`의로 설정 된 `idx`요소를 제외 하 고 `arr`의 해당 요소로 설정 된 모든 요소를 사용 하 여 새 배열을 생성 합니다. 예를 들어 `arr` 배열 `[0,1,2,3]`포함 된 경우 
- `arr w/ 0 <- 10` 배열 `[10,1,2,3]`입니다.
- `arr w/ 2 <- 10` 배열 `[0,1,10,3]`입니다.
- `arr w/ 0..2..3 <- [10,12]` 배열 `[10,1,12,3]`입니다.

사용자 정의 형식에 명명 된 항목에 대 한 유사한 식이 있습니다. 예를 들어 형식 

```qsharp
newtype Complex = (Re : Double, Im : Double);
```
`c` `Complex(1.,-1.)`형식 값이 포함 된 경우 `c w/ Re <- 0.`는 `Complex(0.,-1.)`로 계산 되는 `Complex` 형식의 식입니다.

## <a name="conditional-expressions"></a>조건 식

동일한 형식 및 부울 식의 다른 두 식이 지정 된 경우 물음표 `?` 및 세로 막대 `|`를 사용 하 여 조건 식을 지정할 수 있습니다.
예를 들어 `a==b ? c | d`합니다.
이 예에서는 `a==b` true 이면 조건식의 값이 `c` 되 고 false 인 경우 `d` 됩니다.

두 식은 동일한 입력 및 출력을 포함 하는 작업으로 평가 될 수 있지만 다른 함수을 지원 합니다.
이 경우 조건식의 형식은 두 식에서 지원 되는 모든 함수를 지 원하는 입력 및 출력을 사용 하는 작업입니다.
예를 들어 `Op1`, `Op2`및 `Op3` 모두 `Qubit[]=>Unit`되지만 `Op1`는 `Adjoint`를 지원 하 고 `Op2`를 지원 하며 `Controlled`를 지원 합니다.`Op3`

- `flag ? Op1 | Op2`은 `(Qubit[] => Unit)` 작업입니다.
- `flag ? Op1 | Op3`은 `(Qubit[] => Unit is Adj)` 작업입니다.
- `flag ? Op2 | Op3`은 `(Qubit[] => Unit is Ctl)` 작업입니다.

가능한 두 결과 식 중 하나에 함수 또는 작업 호출이 포함 된 경우 해당 호출은 호출의 값이 되는 경우에만 수행 됩니다.
예를 들어 `a==b ? C(qs) | D(qs)`경우 `a==b` true 이면 `C` 작업이 호출 되 고 false 이면 `D`만 호출 됩니다.
이는 다른 언어의 단락과 비슷합니다.


## <a name="operator-precedence"></a>연산자 우선 순위

모든 이항 연산자는 `^`를 제외 하 고 오른쪽 결합성이 있습니다.

배열 조각화 및 인덱싱을 위한 대괄호, `[` 및 `]`는 연산자 앞에 바인딩합니다.

함수 `Adjoint` `Controlled` 및는 배열 인덱싱 후 다른 모든 연산자 앞에 바인딩합니다.

연산 및 함수 호출에 대 한 괄호는 모든 연산자 앞에, 배열 인덱싱 및 함수 후에도 바인딩됩니다.

우선 순위 순으로 최고에서 최저 순으로 연산자.

연산자 | 숫자 | Description | 피연산자 형식
---------|----------|---------|---------------
 후행 `!` | 단항 연산자 | 래핑 취소 | 사용자 정의 형식
 `-`, `~~~`, `not` | 단항 연산자 | 숫자 음수, 비트 보수, 논리 부정 | `Int` `BigInt`, `~~~`에 대 한 `-`, `Bool` 또는 `not`에 대 한 `Int`, `BigInt` 또는 `Double`
 `^` | 이진 | 정수 거듭제곱 | 지 수에 대 한 기준 `Int` `Int` 또는 `BigInt`
 `/`, `*`, `%` | 이진 | 나누기, 곱하기, 정수 모듈러스 | `/` 및 `*`, `Int` 또는 `BigInt`에 대 한 `Int`, `BigInt` 또는 `Double``%`
 `+`, `-` | 이진 | 더하기 또는 문자열 및 배열 연결, 빼기 | `Int`, `BigInt` 또는 `Double`, 추가로 `String` 또는 배열 형식 `+`
 `<<<`, `>>>` | 이진 | 왼쪽 시프트, 오른쪽 시프트 | `Int` 또는 `BigInt`
 `<`, `<=`, `>`, `>=` | 이진 | 보다 작음, 작거나 같음, 보다 큼, 보다 큼, 크거나 같음 비교 | `Int`, `BigInt` 또는 `Double`
 `==`, `!=` | 이진 | 같음, 같지 않음 비교 | 모든 기본 형식
 `&&&` | 이진 | 비트 AND | `Int` 또는 `BigInt`
 `^^^` | 이진 | 비트 XOR | `Int` 또는 `BigInt`
 <code>\|\|\|</code> | 이진 | 비트 OR | `Int` 또는 `BigInt`
 `and` | 이진 | 논리적 AND | `Bool`
 `or` | 이진 | 논리적 OR | `Bool`
 `..` | Binary/삼항 | Range 연산자 | `Int`
 `?` `|` | 진 | 조건부 | 왼쪽의 `Bool`
`w/` `<-` | 진 | 복사 및 업데이트 | [복사 및 업데이트 식](#copy-and-update-expressions) 참조
