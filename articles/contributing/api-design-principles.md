---
title: 'Q # API 디자인 원칙'
description: 'Q # API 디자인 원칙'
author: cgranade
ms.author: chgranad
ms.date: 3/9/2020
ms.topic: article
uid: microsoft.quantum.contributing.api-design
ms.openlocfilehash: 03c32331f8988181ec6fedcfc207d752b4a880b2
ms.sourcegitcommit: d61b388651351e5abd4bfe7a672e88b84a6697f8
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/10/2020
ms.locfileid: "79024205"
---
# <a name="q-api-design-principles"></a>Q # API 디자인 원칙

## <a name="introduction"></a>소개

언어 및 플랫폼으로 서, Q #은 사용자에 게 퀀텀 응용 프로그램을 작성, 실행, 이해 및 탐색 하는 데 역량을 강화 합니다.
사용자에 게 권한을 부여 하기 위해 Q # 라이브러리를 설계할 때 API 디자인 원칙 집합을 따라 디자인을 안내 하 고, 퀀텀 개발 커뮤니티에 사용할 수 있는 라이브러리를 만드는 데 도움을 줍니다.
이 문서에서는 이러한 원칙을 나열 하 고 Q # Api를 설계할 때이를 적용 하는 방법을 보여 주는 예제를 제공 합니다.

> [!TIP]
> 이 문서는 라이브러리 개발 및 심층 라이브러리 기여를 돕기 위한 매우 자세한 문서입니다.
> Q #에서 사용자 고유의 라이브러리를 작성 하는 경우 또는 [q # 라이브러리 리포지토리에](https://github.com/microsoft/QuantumLibraries)더 큰 기능을 제공 하는 경우에 가장 유용 합니다.
>
> 반면에, 일반적으로 퀀텀 개발 키트에 참여 하는 방법을 알아보려면 [기여 가이드](xref:microsoft.quantum.contributing)로 시작 하는 것이 좋습니다.
> Q # 코드의 형식을 지정 하는 방법에 대 한 일반적인 정보를 원하는 경우 [스타일 가이드](xref:microsoft.quantum.contributing.style)를 확인 하는 것이 좋습니다.

## <a name="general-principles"></a>일반 원칙

**주요 원칙:** 퀀텀 응용 프로그램에 포커스를 두기 위한 Api를 노출 합니다.

- 알고리즘과 응용 프로그램의 상위 수준 구조를 반영 하는 작업 및 함수 **이름을 선택 ✅** 합니다.
- 주로 하위 수준 구현 세부 정보에 중점을 둔 Api를 노출 **하지** ⛔️.

**주요 원칙:** 샘플 사용 사례를 사용 하 여 각 API 디자인을 시작 하 여 Api를 직관적으로 사용할 수 있도록 합니다.

- 모든 가능한 사용을 시작에서 디자인 하는 대신 공용 API의 각 구성 요소에 해당 하는 사용 사례가 **있는지 확인 ✅** 합니다.
    유용 하 게 사용할 수 있는 경우에는 공용 Api를 사용 하지 않는 것이 좋습니다. 하지만 API의 각 부분에 유용한 *구체적인* 예제가 있는지 확인 해야 합니다.

  *예:*
  - @"microsoft.quantum.canon.applytoeachca"는 여러 퀀텀 알고리즘에서 공통 작업 인 일관 된 superposition 상태에서 등록을 준비 하는 `ApplyToEachCA(H, _)` 사용할 수 있습니다. 동일한 작업은 준비, 숫자 및 oracle 기반 알고리즘의 다른 많은 작업에도 사용할 수 있습니다.

- 새 API 디자인이 직관적이 고 제안 된 사용 사례를 충족 하는지 확인 하기 위해 새 API 디자인을 브레인스토밍 및 워크숍 **할** ✅.

  *예:*
  - 현재 Q\# 코드를 검사 하 여 새 API 디자인이 기존 구현을 간소화 하 고 명확 하 게 파악할 수 있습니다.
  - 주 대상의 담당자를 통해 제안 된 API 디자인을 검토 합니다.

**주요 원칙:** 읽을 수 있는 코드를 지원 하 고 권장 하는 Api를 디자인 합니다.

- ✅ 도메인 전문가와 전문가가 아닌 사람이 코드를 읽을 **수 있도록 합니다** .
- 설명서를 사용 하 여 구현 세부 정보를 적절 하 게 파악 하기 위해 각 작업의 영향 및 함수를 상위 수준 알고리즘 내에서 **수행** 하는 데 중점을 두고 ✅ 합니다.
- 해당 하는 경우 일반적인 [Q\# 스타일 가이드](xref:microsoft.quantum.contributing.style) **를 따라 ✅** 합니다.

**주요 원칙:** 안정적이 고 이전 버전과의 호환성을 제공 하기 위해 Api를 디자인 합니다.

- ✅ **는** 주요 변경 사항이 필요할 때 기존 api를 정상적으로 사용 중단 합니다.

- ✅ **"** shim" 작업 및 사용 중단 중에 기존 사용자 코드가 제대로 작동 하도록 허용 하는 함수를 제공 합니다.

  *예:*
  - `EstimateExpectation` 호출 된 작업의 이름을 `EstimateAverage`로 바꾸면 기존 코드를 계속 제대로 작동할 수 있도록 새 이름으로 원래 작업을 호출 하는 `EstimateExpectation` 라는 새 작업이 도입 됩니다.

- ✅ @"microsoft.quantum.core.deprecated" 특성을 사용 **하 여 사용자** 에 게 결함를 전달 합니다.

- ✅ 작업 또는 함수의 이름을 바꿀 때 새 이름을 `@Deprecated`에 **대 한 문자열 입력으로 제공 합니다** .

- 미리 보기 릴리스 기간을 6 개월 이상 사용 하지 않거나 지원 되는 릴리스에 대해 2 년 이상 사용 하지 않는 기존 함수 또는 작업은 제거 **하지 않습니다** . ⛔️

## <a name="functions-and-operations"></a>함수 및 작업

**주요 원칙:** 모든 함수와 작업에 API 내에서 잘 정의 된 단일 용도가 있는지 확인 합니다.

- 관련 없는 여러 태스크를 수행 하는 함수 및 작업을 노출 **하지** ⛔️.

**주요 원칙:** 함수 및 작업을 최대한 재사용 가능 하도록 디자인 하 고 향후의 요구를 예상 합니다.

- 동일한 API와 이전에 존재 하는 라이브러리에서 다른 함수 및 작업과 함께 잘 구성 되도록 함수 및 작업 **을 디자인 ✅** .

  *예:*
  - @"microsoft.quantum.canon.delay" 작업은 해당 입력에 대 한 가정을 최소화 하므로 Q # 표준 라이브러리에서 또는 사용자가 정의한 대로 두 작업의 응용 프로그램을 지연 하는 데 사용할 수 있습니다.
    <!-- TODO: define bad example. -->

- ✅는 순수 하 게 결정적으로 **수행** 되는 모든 논리를 작업 대신 함수로 노출 합니다.

  *예:*
  - 부동 소수점 입력을 제곱 하는 서브루틴은 명확 하 게 작성할 수 있으므로 사용자에 게 작업 `Square : Double => Double`아닌 `Squared : Double -> Double`으로 노출 되어야 합니다. 이를 통해 더 많은 위치에서 서브루틴이 호출 될 수 있으며 (예: 다른 함수 내부) 성능 및 최적화에 영향을 줄 수 있는 유용한 최적화 정보를 컴파일러에 제공할 수 있습니다.
  - `ForEach<'TInput, 'TOutput>('TInput => 'TOutput, 'TInput[]) => 'TOutput[]` 및 `Mapped<'TInput, 'TOutput>('TInput -> 'TOutput, 'TInput[]) -> 'TOutput[]`는 명확성을 고려 하 여 수행 되는 보장의 차이가 있습니다. 두 가지 모두 다른 상황에서 유용 합니다.
  - 퀀텀 작업의 응용 프로그램을 변환 하는 API 루틴은 결정적 방식으로 수행 될 수 있으므로 `CControlled<'T>(op : 'T => Unit) => ((Bool, 'T) => Unit)`와 같은 함수로 사용할 수 있습니다.

- 필요에 따라 형식 매개 변수를 사용 하 여 각 함수 및 작업에 대 한 적절 한 입력 **형식을 일반화 ✅** 합니다.

  *예:*
  - `ApplyToEach`는 가장 일반적인 응용 프로그램의 특정 형식이 아닌 `<'T>(('T => Unit), 'T[]) => Unit` `((Qubit => Unit), Qubit[]) => Unit`입니다.

> [!TIP]
> 향후 요구 사항을 예상 하는 것이 중요 하지만 사용자에 대 한 구체적인 문제를 해결 하는 것도 중요 합니다.
> 따라서이 키 원칙을 사용 하는 경우 "just-in-time" Api 개발을 방지 하기 위해 항상 신중 하 게 고려 하 고 균형을 유지 해야 합니다.

**주요 원칙:** 예측 가능 하 고 호출 가능의 용도를 전달 하는 함수 및 작업에 대 한 입력 및 출력 형식을 선택 합니다.

- 튜플 **형식을 사용 하** 여 함께 간주할 때만 중요 한 입력 및 출력을 논리적으로 그룹화 할 ✅. 이러한 경우에는 사용자 정의 형식을 사용 하는 것이 좋습니다.

  *예:*
  - 다른 함수의 로컬 최소을 출력 하는 함수는 입력으로 검색 간격의 범위를 사용 해야 할 수 있습니다 .이 경우 `LocalMinima(fn : (Double -> Double), (left : Double, right : Double)) : Double` 적절 한 서명이 될 수 있습니다.
  - 매개 변수 이동 기법을 사용 하 여 기계 학습 분류자의 파생을 예측 하는 작업은 이동 된 매개 변수 벡터와 이동 되지 않은 매개 변수 벡터를 입력으로 사용 해야 할 수 있습니다. 이 경우 `(unshifted : Double[], shifted : Double[])`와 유사한 입력이 적절할 수 있습니다.

- 다양 한 함수 및 작업에서 일관 되 게 입력 및 출력 튜플의 **항목 순서를** ✅ 합니다.

  *예:*
  - 각각 회전 각도와 대상 비트를 입력으로 사용 하는 두 개의 함수 또는 함수를 고려 하는 경우 각 입력 튜플에 동일한 순서로 정렬 되어 있는지 확인 합니다. 즉, `ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl` 및 `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)`를 사용 하 여 `ApplyRotation(target : Qubit, angle : Double) : Unit is Adj + Ctl` 하 고 `DelayedRotation(angle : Double, target : Qubit) : (Unit => Unit is Adj + Ctl)`합니다.

**주요 원칙:** 부분 응용 프로그램과 같은 Q\# 언어 기능에서 잘 작동 하도록 함수 및 작업을 디자인 합니다.

- 가장 일반적으로 적용 되는 입력이 먼저 발생 하도록 입력 **튜플의 순서를** ✅ 합니다. 즉, 부분 응용 프로그램은 currying과 비슷하게 작동 합니다.

  *예:*
  - 입력으로 부동 소수점 숫자와의 비트를 사용 하는 작업 `ApplyRotation`는 `Qubit => Unit`형식의 입력을 필요로 하는 작업에 사용 하기 위해 먼저 부동 소수점 입력과 함께 부분적으로 적용 될 수 있습니다. 따라서 `operation ApplyRotation(angle : Double, target : Qubit) : Unit is Adj + Ctl`의 서명이
      는 부분 응용 프로그램에서 가장 일관 된 방식으로 작동 합니다.
  - 일반적으로이 지침은 입력 튜플의 모든 모든 데이터를 앞에 배치 하는 것을 의미 하지만 좋은 결정을 사용 하 고 API가 실제로 호출 되는 방식을 검사 합니다.

## <a name="user-defined-types"></a>사용자 정의 형식

**주요 원칙:** 사용자 정의 형식을 사용 하 여 api를 더 쉽게 표현 하 고 편리 하 게 사용할 수 있도록 합니다.

- 새 사용자 정의 **형식을 도입 하** 여 길고 복잡 한 형식에 대 한 유용한 약어를 제공 ✅ 합니다.

  *예:*
  - 세 개의 비트율 비트 배열 입력을 포함 하는 작업 유형을 일반적으로 입력으로 사용 하거나 출력으로 반환 하 여와 같은 UDT를 제공 하는 경우 `newtype TimeDependentBlockEncoding = ((Qubit[], Qubit[], Qubit[]) => Unit is Adj + Ctl)`
      는 유용한 약어를 제공 하는 데 도움이 됩니다.

- 지정 된 기본 형식이 매우 특별 한 의미 에서만 사용 되어야 함을 나타내기 위해 새 사용자 정의 **형식을 도입 ✅** .

  *예:*
  - 기존 데이터를 퀀텀 레지스터로 인코딩하는 작업으로 특별히 해석 해야 하는 작업은 `newtype InputEncoder = (Apply : (Qubit[] => Unit))`사용자 정의 형식으로 레이블을 지정 하는 것이 적합할 수 있습니다.

- 이후 확장성을 허용 하는 명명 된 항목을 포함 하는 새로운 사용자 정의 형식 (예: 앞으로 추가 명명 된 항목을 포함할 수 있는 결과 구조) **을 소개 하** 는 ✅.

  *예:*
  - 작업 `TrainModel`에서 많은 구성 옵션을 노출 하는 경우 이러한 옵션을 새로운 UDT `TrainingOptions` UDT로 제공 하 고 새 `DefaultTrainingOptions : Unit -> TrainingOptions` 함수를 제공 하 여 라이브러리 개발자가 적절 하 게 새 UDT 항목을 추가할 수 있도록 하는 동시에 TrainingOptions UDT 값의 특정 명명 된 항목을 재정의할 수 있습니다.

- ✅ **는** 사용자가 올바른 튜플 분해을 알아야 하도록 기본 설정 된 새 사용자 정의 형식에 대해 명명 된 항목을 선언 합니다.

  *예:*
  - 극좌표 형 분해에서 복소수를 표시 하는 경우 `newtype ComplexPolar = (Magnitude: Double, Argument: Double)` `newtype ComplexPolar = (Double, Double)`하는 것이 좋습니다.

**주요 원칙:** 에서 사용자 정의 형식을 사용 하 여 인지 부하를 줄이고 사용자가 추가 개념 및 명명법을 배우지 않아도 됩니다.

- 사용자가 래핑 해제 연산자 (`!`)를 자주 사용 하거나 래핑 해제의 여러 수준을 자주 필요로 하는 사용자 정의 형식을 도입 **하지** ⛔️. 가능한 완화 전략은 다음과 같습니다.

  - 단일 항목으로 사용자 정의 형식을 노출 하는 경우 해당 항목의 이름을 정의 하는 것이 좋습니다. 예를 들어 `newtype Encoder = (Qubit[] => Unit is Adj + Ctl)`에 대 한 기본 설정 `newtype Encoder = (Apply : (Qubit[] => Unit is Adj + Ctl))` 고려 하십시오.

  - 다른 함수 및 작업이 "래핑된" UDT 인스턴스를 직접 수락할 수 있도록 합니다.

- ⛔️는 추가 표현을를 제공 하지 않고 기본 제공 형식이 중복 되는 새로운 사용자 정의 형식을 도입 **하지 않습니다** .

  *예:*
  - UDT `newtype QubitRegister = Qubit[]`는 `Qubit[]`에 대 한 추가 표현을을 제공 하지 않으므로 띄는 혜택 없이 사용 하기가 더 어려워집니다.
  - UDT `newtype LittleEndian = Qubit[]`는 기본 레지스터를 사용 하 고 해석 하는 방법을 문서화 하므로 기본 형식에 대해 추가 표현을을 제공 합니다.

- 반드시 필요한 경우가 아니면 접근자 함수 **를 도입할 ⛔️** .   이 경우 명명 된 항목을 강력 하 게 선호 합니다.

  *예:*
  - UDT `newtype Complex = (Double, Double)`를 도입할 때 `newtype Complex = (Real : Double, Imag : Double)`에 대 한 정의를 수정 하 여 함수 `GetReal : Complex -> Double` 및 `GetImag : Complex -> Double`를 도입 하는 것이 좋습니다.

## <a name="namespaces-and-organization"></a>네임 스페이스 및 조직

**주요 원칙:** 예측 가능 하 고 각 네임 스페이스의 함수, 작업 및 사용자 정의 형식에 대 한 용도를 명확 하 게 전달 하는 네임 스페이스 이름을 선택 합니다.

- ✅ **네임** 스페이스를 `Publisher.Product.DomainArea`으로 합니다.

  *예:*
  - Microsoft에서 퀀텀 개발 키트의 퀀텀 시뮬레이션 기능의 일부로 게시 한 함수, 작업 및 Udt는 `Microsoft.Quantum.Simulation` 네임 스페이스에 배치 됩니다.
  - `Microsoft.Quantum.Math`는 수학 도메인 영역과 관련 된 퀀텀 개발 키트의 일부로 Microsoft에서 게시 한 네임 스페이스를 나타냅니다.

- 특정 기능에 사용 되는 작업, 함수 및 사용자 정의 형식을 해당 기능을 설명 하는 네임 스페이스 **에 추가 하** 여 해당 기능이 여러 문제 도메인에서 사용 되는 경우에도 ✅ 합니다.

  *예:*
  - Microsoft에서 퀀텀 개발 키트의 일부로 게시 한 상태 준비 Api는 `Microsoft.Quantum.Preparation`에 배치 됩니다.
  - Microsoft에서 퀀텀 개발 키트의 일부로 게시 한 퀀텀 시뮬레이션 Api는 `Microsoft.Quantum.Simulation`에 배치 됩니다.

- 특정 도메인 내 에서만 사용 되는 작업, 함수 및 사용자 정의 형식을 유틸리티의 도메인을 나타내는 네임 **스페이스로 ✅ 합니다** . 필요한 경우 네임 스페이스를 사용 하 여 각 도메인별 네임 스페이스 내에서 포커스가 있는 작업을 표시 합니다.

  *예:*
  - Microsoft에서 게시 하는 퀀텀 기계 학습 라이브러리는 대부분 @"microsoft.quantum.machinelearning" 네임 스페이스에 저장 되지만 예제 데이터 집합은 @"microsoft.quantum.machinelearning.datasets" 네임 스페이스에 의해 제공 됩니다.
  - Microsoft에서 퀀텀 개발 키트의 일부로 게시 한 퀀텀 화학 Api는 `Microsoft.Quantum.Chemistry`에 배치 해야 합니다. Wigner 분해 구현과 관련 된 기능을 `Microsoft.Quantum.Chemistry.JordanWigner`에 배치 하 여 퀀텀 화학 도메인 영역에 대 한 기본 인터페이스가 구현과 관련이 없도록 할 수 있습니다.

**주요 원칙:** 네임 스페이스와 액세스 한정자를 함께 사용 하 여 사용자에 게 노출 되는 API 노출에 대해 의도적인 다음 Api의 구현 및 테스트와 관련 된 내부 세부 정보를 숨깁니다.

- ✅ 하는 경우 API를 구현 하는 데 필요한 모든 함수 및 작업을 구현 하는 API와 동일한 네임 스페이스 **에 저장 하지만, "** private" 또는 "internal" 키워드로 표시 하 여 라이브러리에 대 한 공용 api 표면의 일부가 아님을 표시 합니다. 밑줄 (`_`)로 시작 하는 이름을 사용 하 여 전용 및 내부 작업과 공용 callables의 함수를 시각적으로 구분할 수 있습니다.

  *예:*
  - 작업 이름 `_Features`는 지정 된 네임 스페이스 및 어셈블리에 전용 함수를 나타내며 `internal` 키워드와 함께 사용할 수 있습니다.

- 드문 경우 지만 지정 된 네임 스페이스에 대 한 API를 구현 하기 위해 광범위 한 전용 함수 또는 작업 집합이 필요한 경우 **, 구현** 중인 네임 스페이스와 일치 하는 새 네임 스페이스에 ✅ 하 고 `.Private`종료 합니다.

- 모든 단위 테스트를 테스트 중인 네임 스페이스와 일치 하는 네임 스페이스 **에 저장 하** 고 `.Tests`에서 종료 ✅.

## <a name="naming-conventions-and-vocabulary"></a>명명 규칙 및 어휘

**주요 원칙:** 퀀텀 초보자 및 전문가를 비롯 하 여 다양 한 대상에서 명확 하 고, 액세스 가능 하며, 읽을 수 있는 이름 및 용어를 선택 합니다.

- 차별적인 또는 exclusionary 식별자 이름과 API 문서 주석에는 용어를 사용 **하지 않습니다** . ⛔️

- API 문서 **주석을 사용 하 여 관련** 컨텍스트, 예제 및 참조를 제공 하는 ✅. 특히 더 어려운 개념을 제공 합니다.

- 불필요 하 게 까다로운 식별자 이름을 사용 하지 않거나 중요 한 퀀텀 알고리즘 정보를 읽는 데 필요한 식별자 이름을 사용 **하지** ⛔️ 합니다.

  *예:*
  - "Grover 반복"에 "진폭 증폭 반복"을 사용 하는 것이 좋습니다.

- 구현 **하지 않고** 호출 가능 하 고 의도 한 영향을 명확 하 게 전달 하는 작업 및 함수 이름을 선택 ✅ 합니다. 구현은 다음을 수행할 수 있습니다.

  *예:*
  - 후자가 이전에 구현 되는 방식을 전달 하므로 "Hadamard test"에 "예상 겹치기"를 사용 하는 것이 좋습니다.

- 모든 Q\# Api에서 일관 된 방식으로 단어 **를 사용 ✅** 합니다.

  - **동사의**

    - **Assert**: 물리적 리소스를 사용 하 여 대상 컴퓨터와 해당 비트의 상태에 대 한 가정이 있는지 확인 합니다. 이 동사를 사용 하는 작업은 라이브러리 및 실행 프로그램의 기능에 영향을 주지 않고 항상 안전 하 게 제거 되어야 합니다. 팩트와 달리 어설션은 일반적인 경우에는 표준에 따라 결정 될 수 있습니다. 예를 들어,이는, 실행 환경 등의 외부 상태에 따라 달라질 수 있습니다. 외부 상태에 대 한 종속성은 일종의 부작용 이므로 어설션이 함수 대신 작업으로 노출 되어야 합니다.

    - **예상**: 하나 이상의 반복 되는 측정값을 사용 하 여 측정 결과에서 기존 수량을 예측 합니다.

      *예:*
      - @"microsoft.quantum.characterization.estimatefrequency"
      - @"microsoft.quantum.characterization.estimateoverlapbetweenstates"

    - **준비**: 특정 초기 상태 (일반적으로 $ \ket{00\cdots 0} $)에서 시작 하 여 해당 하는 작업의 상태를 원하는 끝 상태로 전환 하는 데 퀀텀 작업 또는 일련의 작업을 적용 합니다. 일반적으로 지정 된 시작 상태를 제외 하 고 상태에 대해 작업을 수행 하면 정의 되지 않은 단일 변환이 발생할 **수** 있지만 작업 및 해당 adjoint "취소"를 유지 하 고 작업을 적용 하지 **않아야** 합니다.

      *예:*
      - @"microsoft.quantum.preparation.preparearbitrarystate"
      - @"microsoft.quantum.preparation.prepareuniformsuperposition"

    - **Measure**: 하나 이상의 이상에 퀀텀 작업 또는 일련의 작업을 적용 하 여 기존 데이터를 다시 읽습니다.

      *예:*
      - @"microsoft.quantum.intrinsic.measure"
      - @"microsoft.quantum.arithmetic.measurefxp"
      - @"microsoft.quantum.arithmetic.measureinteger"

    - **적용**: 하나 이상의 이상에 퀀텀 작업 또는 일련의 작업을 적용 하 여 해당 하는 비트의 상태를 일관 된 방식으로 변경 합니다. 이 동사는 Q\# 명명법에서 가장 일반적으로 사용 되는 **동사 이며 보다** 구체적인 동사가 더 직접적으로 관련 된 경우에는 사용 하면 안 됩니다.

  - **명사**:

    - **팩트**: 대상 컴퓨터의 상태, 해당 환경 또는 컴퓨터의 기능에 대 한 상태가 아닌 입력에만 의존 하는 부울 조건입니다. 어설션과 달리 팩트는 해당 팩트에 제공 되는 *값* 만을 인식 합니다. 다음은 그 예입니다.

      *예:*
      - @"microsoft.quantum.diagnostics.equalityfacti": 두 정수 입력에 대 한 같음 팩트를 나타냅니다. 입력으로 제공 된 정수는 서로 같거나 다른 프로그램 상태와는 독립적입니다.

    - **옵션:** 함수 또는 작업에 대해 "선택적 인수"로 작동할 수 있는 여러 개의 명명 된 항목이 포함 된 UDT입니다. 다음은 그 예입니다.

      *예:*
      - @"microsoft.quantum.machinelearning.trainingoptions" UDT에는 학습 률, 미니 배치 크기 및 ML 학습에 대해 구성 가능한 기타 매개 변수에 대 한 명명 된 항목이 포함 되어 있습니다.

  - **형용사**:

    - ⛔️ **New**: 많은 프로그래밍 언어 (예: C++, C#, Java, TypeScript, PowerShell)에서 동사로 사용 되는 혼동을 방지 하기 위해 **이 형용사를 사용 하면 안 됩니다** .

  - **전치사:** 경우에 따라 전치사를 사용 하 여 함수 및 작업 이름에서 명사와 동사의 역할을 보다 명확 하 게 구분 하거나 명확 하 게 지정할 수 있습니다. 그러나 신중 하 고 일관 된 작업을 수행 해야 합니다.

    - **As:** 함수의 입력 및 출력이 동일한 정보를 나타내지만 출력은 해당 정보를 원래 표현이 아닌 *X* **로** 나타냅니다. 이는 형식 변환 함수에 특히 일반적입니다.

      *예:*
      - `IntAsDouble(2)`은 입력 (`2`)과 출력 (`2.0`)이 동일한 정보를 qualitatively 하지만 다른 Q\# 데이터 형식을 사용 하 여이 작업을 수행 한다는 것을 나타냅니다.

    - **시작:** 일관성을 유지 하기 위해이 **전치사를** 사용 하 여 형식 변환 함수 또는 다른 모든 경우를 사용 하면 안 **됩니다.**

    - ⛔️ **:** 이 전치사는 많은 프로그래밍 언어의 동사로 사용과 혼동 하지 않도록 하기 위해 사용해 서는 **안 됩니다.**
